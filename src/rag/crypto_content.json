[
  {
    "content": "Módulo algorithms: Módulo que contiene los algoritmos de encriptación.",
    "source": "algorithms",
    "type": "module",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método AESGCM.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(self, key: bytes):\n        utils._check_byteslike(\"key\", key)\n        if len(key) not in (16, 24, 32):\n            raise ValueError(\"AESGCM key must be 128, 192, or 256 bits.\")\n        self._key = key",
    "source": "cryptography.hazmat.primitives.ciphers.aead.AESGCM.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase CaosEncryption: CAOS v4.1 - Cifrado optimizado con AES-GCM y PBKDF2.",
    "source": "algorithms.caos_v4.CaosEncryption",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.__init__: Inicializa el cifrador con parámetros optimizados.\n\nArgs:\n    password: Contraseña para derivación de clave\n    iterations: Número de iteraciones PBKDF2 (si None, se calcula automáticamente)\n    key_size: Tamaño de clave en bytes (32 = 256 bits)\n    use_parallel: Usar procesamiento paralelo para operaciones intensivas\n\nCódigo:\n    def __init__(\n        self,\n        password: str,\n        iterations: Optional[int] = None,\n        key_size: int = 32,\n        use_parallel: bool = True\n    ):\n        \"\"\"\n        Inicializa el cifrador con parámetros optimizados.\n        Args:\n            password: Contraseña para derivación de clave\n            iterations: Número de iteraciones PBKDF2 (si None, se calcula automáticamente)\n            key_size: Tamaño de clave en bytes (32 = 256 bits)\n            use_parallel: Usar procesamiento paralelo para operaciones intensivas\n        \"\"\"\n        self.password = password.encode(\"utf-8\") if isinstance(password, str) else password\n        self.key_size = key_size\n        self.use_parallel = use_parallel\n        self.backend = default_backend()\n        # Calcular iteraciones óptimas si no se especifican\n        if iterations is None:\n            self.iterations = self._calculate_optimal_iterations()\n        else:\n            self.iterations = max(MIN_ITERATIONS, min(iterations, MAX_ITERATIONS))\n        # Inicializar caché de claves\n        self._key_cache = {}\n        self._cache_lock = threading.Lock()",
    "source": "algorithms.caos_v4.CaosEncryption.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.decrypt: Desencripta datos con verificación de integridad mejorada y manejo de errores más claro.\nSoporta tanto datos binarios como strings en Base64.\n\nCódigo:\n    def decrypt(self, encrypted_data: Union[bytes, str]) -> bytes:\n        \"\"\"\n        Desencripta datos con verificación de integridad mejorada y manejo de errores más claro.\n        Soporta tanto datos binarios como strings en Base64.\n        \"\"\"\n        try:\n            # Si el input es un string, asumimos que es Base64\n            if isinstance(encrypted_data, str):\n                try:\n                    encrypted_data = base64.b64decode(encrypted_data)\n                except Exception as e:\n                    raise ValueError(\n                        \"Error al decodificar Base64. \"\n                        \"Asegúrate de que el mensaje encriptado esté en formato Base64 válido.\"\n                    ) from e\n            # Verificación de longitud mínima\n            min_length = 16 + 12 + 16  # salt + nonce + tag mínimo\n            if len(encrypted_data) < min_length:\n                raise ValueError(\n                    f\"Los datos encriptados son demasiado cortos ({len(encrypted_data)} bytes). \"\n                    f\"Se requieren al menos {min_length} bytes para un mensaje válido.\"\n                )\n            # Extraer componentes\n            salt = encrypted_data[:16]\n            nonce = encrypted_data[16:28]\n            ciphertext = encrypted_data[28:]\n            # Derivar clave de manera segura\n            try:\n                key = self._derive_key(salt)\n            except Exception as e:\n                raise ValueError(\n                    \"Error al derivar la clave. \"\n                    \"Esto puede deberse a un problema con la contraseña o el salt.\"\n                ) from e\n            # Procesar datos (en paralelo si es posible)\n            try:\n                plaintext = self._parallel_process(ciphertext, key, nonce, False)\n            except Exception as e:\n                raise ValueError(\n                    \"Error al procesar los datos cifrados. \"\n                    \"La contraseña podría ser incorrecta o los datos podrían estar corruptos.\"\n                ) from e\n            # Verificar que tenemos suficientes datos para el checksum\n            if len(plaintext) < 16:\n                raise ValueError(\n                    \"Los datos desencriptados son demasiado cortos para contener un checksum válido.\"\n                )\n            # Extraer checksum y datos\n            stored_checksum = plaintext[:16]\n            actual_data = plaintext[16:]\n            # Calcular checksum actual\n            current_checksum = self._calculate_checksum(actual_data)\n            # Verificación de integridad constante en tiempo\n            if not bytes_eq(stored_checksum, current_checksum):\n                # Proporcionar más información de diagnóstico\n                raise ValueError(\n                    \"La verificación de integridad falló. \"\n                    f\"Checksum almacenado: {stored_checksum.hex()}, \"\n                    f\"Checksum calculado: {current_checksum.hex()}. \"\n                    \"Esto puede deberse a: \"\n                    \"1) Contraseña incorrecta \"\n                    \"2) Datos modificados o corruptos \"\n                    \"3) Mensaje encriptado con una versión diferente del algoritmo\"\n                )\n            return actual_data\n        except ValueError as ve:\n            # Re-lanzar los errores de validación con mensajes más descriptivos\n            raise ve\n        except Exception as e:\n            # Capturar cualquier otro error y proporcionar un mensaje más útil\n            raise ValueError(\n                f\"Error al desencriptar: {str(e)}. \"\n                \"Por favor, verifica que: \"\n                \"1) La contraseña es correcta \"\n                \"2) El mensaje fue encriptado con CAOS V4 \"\n                \"3) El mensaje no ha sido modificado\"\n            ) from e",
    "source": "algorithms.caos_v4.CaosEncryption.decrypt",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.decrypt_file: Desencripta archivo con verificación de integridad.\n\nCódigo:\n    def decrypt_file(self, input_path: str, output_path: str) -> None:\n        \"\"\"Desencripta archivo con verificación de integridad.\"\"\"\n        with open(input_path, \"rb\") as infile:\n            encrypted_data = infile.read()\n        decrypted_data = self.decrypt(encrypted_data)\n        with open(output_path, \"wb\") as outfile:\n            outfile.write(decrypted_data)",
    "source": "algorithms.caos_v4.CaosEncryption.decrypt_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.encrypt: Encripta datos con optimizaciones de rendimiento y seguridad.\n\nCódigo:\n    def encrypt(self, data: bytes) -> bytes:\n        \"\"\"\n        Encripta datos con optimizaciones de rendimiento y seguridad.\n        \"\"\"\n        # Generar sal y nonce\n        salt = os.urandom(16)\n        nonce = os.urandom(12)\n        # Derivar clave de manera segura\n        key = self._derive_key(salt)\n        # Calcular checksum antes de encriptar\n        checksum = self._calculate_checksum(data)\n        # Procesar datos (en paralelo si es posible)\n        ciphertext = self._parallel_process(checksum + data, key, nonce, True)\n        # Retornar con estructura optimizada\n        return salt + nonce + ciphertext",
    "source": "algorithms.caos_v4.CaosEncryption.encrypt",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.encrypt_file: Encripta archivo con procesamiento por chunks.\n\nCódigo:\n    def encrypt_file(self, input_path: str, output_path: str) -> None:\n        \"\"\"Encripta archivo con procesamiento por chunks.\"\"\"\n        with open(input_path, \"rb\") as infile:\n            data = infile.read()\n        encrypted_data = self.encrypt(data)\n        with open(output_path, \"wb\") as outfile:\n            outfile.write(encrypted_data)",
    "source": "algorithms.caos_v4.CaosEncryption.encrypt_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase Cipher: Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
    "source": "cryptography.hazmat.primitives.ciphers.base.Cipher",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Cipher.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(\n        self,\n        algorithm: CipherAlgorithm,\n        mode: Mode,\n        backend: typing.Any = None,\n    ) -> None:\n        if not isinstance(algorithm, CipherAlgorithm):\n            raise TypeError(\"Expected interface of CipherAlgorithm.\")\n        if mode is not None:\n            # mypy needs this assert to narrow the type from our generic\n            # type. Maybe it won't some time in the future.\n            assert isinstance(mode, modes.Mode)\n            mode.validate_for_algorithm(algorithm)\n        self.algorithm = algorithm\n        self.mode = mode",
    "source": "cryptography.hazmat.primitives.ciphers.base.Cipher.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase InvalidSignature: Common base class for all non-exit exceptions.",
    "source": "cryptography.exceptions.InvalidSignature",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método PBKDF2HMAC.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes,\n        iterations: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n        if not ossl.pbkdf2_hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                \"{} is not supported for PBKDF2 by this backend.\".format(\n                    algorithm.name\n                ),\n                _Reasons.UNSUPPORTED_HASH,\n            )\n        self._used = False\n        self._algorithm = algorithm\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        self._salt = salt\n        self._iterations = iterations",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método PBKDF2HMAC.derive: Deterministically generates and returns a new key based on the existing\nkey material.\n\nCódigo:\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"PBKDF2 instances can only be used once.\")\n        self._used = True\n        return rust_openssl.kdf.derive_pbkdf2_hmac(\n            key_material,\n            self._algorithm,\n            self._salt,\n            self._iterations,\n            self._length,\n        )",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.derive",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método PBKDF2HMAC.verify: Checks whether the key generated by the key material matches the\nexpected derived key. Raises an exception if they do not match.\n\nCódigo:\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.verify",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase Path: PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
    "source": "pathlib.Path",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.absolute: Return an absolute version of this path.  This function works\neven if the path doesn't point to anything.\n\nNo normalization is done, i.e. all '.' and '..' will be kept along.\nUse resolve() to get the canonical path to a file.\n\nCódigo:\n    def absolute(self):\n        \"\"\"Return an absolute version of this path.  This function works\n        even if the path doesn't point to anything.\n        No normalization is done, i.e. all '.' and '..' will be kept along.\n        Use resolve() to get the canonical path to a file.\n        \"\"\"\n        # XXX untested yet!\n        if self.is_absolute():\n            return self\n        # FIXME this must defer to the specific flavour (and, under Windows,\n        # use nt._getfullpathname())\n        obj = self._from_parts([os.getcwd()] + self._parts, init=False)\n        obj._init(template=self)\n        return obj",
    "source": "pathlib.Path.absolute",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.as_posix: Return the string representation of the path with forward (/)\nslashes.\n\nCódigo:\n    def as_posix(self):\n        \"\"\"Return the string representation of the path with forward (/)\n        slashes.\"\"\"\n        f = self._flavour\n        return str(self).replace(f.sep, '/')",
    "source": "pathlib.Path.as_posix",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.as_uri: Return the path as a 'file' URI.\n\nCódigo:\n    def as_uri(self):\n        \"\"\"Return the path as a 'file' URI.\"\"\"\n        if not self.is_absolute():\n            raise ValueError(\"relative path can't be expressed as a file URI\")\n        return self._flavour.make_uri(self)",
    "source": "pathlib.Path.as_uri",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.chmod: Change the permissions of the path, like os.chmod().\n\nCódigo:\n    def chmod(self, mode):\n        \"\"\"\n        Change the permissions of the path, like os.chmod().\n        \"\"\"\n        self._accessor.chmod(self, mode)",
    "source": "pathlib.Path.chmod",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.exists: Whether this path exists.\n\nCódigo:\n    def exists(self):\n        \"\"\"\n        Whether this path exists.\n        \"\"\"\n        try:\n            self.stat()\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False\n        return True",
    "source": "pathlib.Path.exists",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.expanduser: Return a new path with expanded ~ and ~user constructs\n(as returned by os.path.expanduser)\n\nCódigo:\n    def expanduser(self):\n        \"\"\" Return a new path with expanded ~ and ~user constructs\n        (as returned by os.path.expanduser)\n        \"\"\"\n        if (not (self._drv or self._root) and\n            self._parts and self._parts[0][:1] == '~'):\n            homedir = self._flavour.gethomedir(self._parts[0][1:])\n            return self._from_parts([homedir] + self._parts[1:])\n        return self",
    "source": "pathlib.Path.expanduser",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.glob: Iterate over this subtree and yield all existing files (of any\nkind, including directories) matching the given relative pattern.\n\nCódigo:\n    def glob(self, pattern):\n        \"\"\"Iterate over this subtree and yield all existing files (of any\n        kind, including directories) matching the given relative pattern.\n        \"\"\"\n        sys.audit(\"pathlib.Path.glob\", self, pattern)\n        if not pattern:\n            raise ValueError(\"Unacceptable pattern: {!r}\".format(pattern))\n        drv, root, pattern_parts = self._flavour.parse_parts((pattern,))\n        if drv or root:\n            raise NotImplementedError(\"Non-relative patterns are unsupported\")\n        selector = _make_selector(tuple(pattern_parts), self._flavour)\n        for p in selector.select_from(self):\n            yield p",
    "source": "pathlib.Path.glob",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.group: Return the group name of the file gid.\n\nCódigo:\n    def group(self):\n        \"\"\"\n        Return the group name of the file gid.\n        \"\"\"\n        return self._accessor.group(self)",
    "source": "pathlib.Path.group",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_absolute: True if the path is absolute (has both a root and, if applicable,\na drive).\n\nCódigo:\n    def is_absolute(self):\n        \"\"\"True if the path is absolute (has both a root and, if applicable,\n        a drive).\"\"\"\n        if not self._root:\n            return False\n        return not self._flavour.has_drv or bool(self._drv)",
    "source": "pathlib.Path.is_absolute",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_block_device: Whether this path is a block device.\n\nCódigo:\n    def is_block_device(self):\n        \"\"\"\n        Whether this path is a block device.\n        \"\"\"\n        try:\n            return S_ISBLK(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_block_device",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_char_device: Whether this path is a character device.\n\nCódigo:\n    def is_char_device(self):\n        \"\"\"\n        Whether this path is a character device.\n        \"\"\"\n        try:\n            return S_ISCHR(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_char_device",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_dir: Whether this path is a directory.\n\nCódigo:\n    def is_dir(self):\n        \"\"\"\n        Whether this path is a directory.\n        \"\"\"\n        try:\n            return S_ISDIR(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_dir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_fifo: Whether this path is a FIFO.\n\nCódigo:\n    def is_fifo(self):\n        \"\"\"\n        Whether this path is a FIFO.\n        \"\"\"\n        try:\n            return S_ISFIFO(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_fifo",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_file: Whether this path is a regular file (also True for symlinks pointing\nto regular files).\n\nCódigo:\n    def is_file(self):\n        \"\"\"\n        Whether this path is a regular file (also True for symlinks pointing\n        to regular files).\n        \"\"\"\n        try:\n            return S_ISREG(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_mount: Check if this path is a POSIX mount point\n\nCódigo:\n    def is_mount(self):\n        \"\"\"\n        Check if this path is a POSIX mount point\n        \"\"\"\n        # Need to exist and be a dir\n        if not self.exists() or not self.is_dir():\n            return False\n        try:\n            parent_dev = self.parent.stat().st_dev\n        except OSError:\n            return False\n        dev = self.stat().st_dev\n        if dev != parent_dev:\n            return True\n        ino = self.stat().st_ino\n        parent_ino = self.parent.stat().st_ino\n        return ino == parent_ino",
    "source": "pathlib.Path.is_mount",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_relative_to: Return True if the path is relative to another path or False.\n        \n\nCódigo:\n    def is_relative_to(self, *other):\n        \"\"\"Return True if the path is relative to another path or False.\n        \"\"\"\n        try:\n            self.relative_to(*other)\n            return True\n        except ValueError:\n            return False",
    "source": "pathlib.Path.is_relative_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_reserved: Return True if the path contains one of the special names reserved\nby the system, if any.\n\nCódigo:\n    def is_reserved(self):\n        \"\"\"Return True if the path contains one of the special names reserved\n        by the system, if any.\"\"\"\n        return self._flavour.is_reserved(self._parts)",
    "source": "pathlib.Path.is_reserved",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_socket: Whether this path is a socket.\n\nCódigo:\n    def is_socket(self):\n        \"\"\"\n        Whether this path is a socket.\n        \"\"\"\n        try:\n            return S_ISSOCK(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_socket",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_symlink: Whether this path is a symbolic link.\n\nCódigo:\n    def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_symlink",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.iterdir: Iterate over the files in this directory.  Does not yield any\nresult for the special paths '.' and '..'.\n\nCódigo:\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n        for name in self._accessor.listdir(self):\n            if name in {'.', '..'}:\n                # Yielding a path object for these makes little sense\n                continue\n            yield self._make_child_relpath(name)",
    "source": "pathlib.Path.iterdir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.joinpath: Combine this path with one or several arguments, and return a\nnew path representing either a subpath (if all arguments are relative\npaths) or a totally different path (if one of the arguments is\nanchored).\n\nCódigo:\n    def joinpath(self, *args):\n        \"\"\"Combine this path with one or several arguments, and return a\n        new path representing either a subpath (if all arguments are relative\n        paths) or a totally different path (if one of the arguments is\n        anchored).\n        \"\"\"\n        return self._make_child(args)",
    "source": "pathlib.Path.joinpath",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.lchmod: Like chmod(), except if the path points to a symlink, the symlink's\npermissions are changed, rather than its target's.\n\nCódigo:\n    def lchmod(self, mode):\n        \"\"\"\n        Like chmod(), except if the path points to a symlink, the symlink's\n        permissions are changed, rather than its target's.\n        \"\"\"\n        self._accessor.lchmod(self, mode)",
    "source": "pathlib.Path.lchmod",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.link_to: Make the target path a hard link pointing to this path.\n\nNote this function does not make this path a hard link to *target*,\ndespite the implication of the function and argument names. The order\nof arguments (target, link) is the reverse of Path.symlink_to, but\nmatches that of os.link.\n\nCódigo:\n    def link_to(self, target):\n        \"\"\"\n        Make the target path a hard link pointing to this path.\n        Note this function does not make this path a hard link to *target*,\n        despite the implication of the function and argument names. The order\n        of arguments (target, link) is the reverse of Path.symlink_to, but\n        matches that of os.link.\n        \"\"\"\n        self._accessor.link_to(self, target)",
    "source": "pathlib.Path.link_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.lstat: Like stat(), except if the path points to a symlink, the symlink's\nstatus information is returned, rather than its target's.\n\nCódigo:\n    def lstat(self):\n        \"\"\"\n        Like stat(), except if the path points to a symlink, the symlink's\n        status information is returned, rather than its target's.\n        \"\"\"\n        return self._accessor.lstat(self)",
    "source": "pathlib.Path.lstat",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.match: Return True if this path matches the given pattern.\n\nCódigo:\n    def match(self, path_pattern):\n        \"\"\"\n        Return True if this path matches the given pattern.\n        \"\"\"\n        cf = self._flavour.casefold\n        path_pattern = cf(path_pattern)\n        drv, root, pat_parts = self._flavour.parse_parts((path_pattern,))\n        if not pat_parts:\n            raise ValueError(\"empty pattern\")\n        if drv and drv != cf(self._drv):\n            return False\n        if root and root != cf(self._root):\n            return False\n        parts = self._cparts\n        if drv or root:\n            if len(pat_parts) != len(parts):\n                return False\n            pat_parts = pat_parts[1:]\n        elif len(pat_parts) > len(parts):\n            return False\n        for part, pat in zip(reversed(parts), reversed(pat_parts)):\n            if not fnmatch.fnmatchcase(part, pat):\n                return False\n        return True",
    "source": "pathlib.Path.match",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.mkdir: Create a new directory at this given path.\n\nCódigo:\n    def mkdir(self, mode=0o777, parents=False, exist_ok=False):\n        \"\"\"\n        Create a new directory at this given path.\n        \"\"\"\n        try:\n            self._accessor.mkdir(self, mode)\n        except FileNotFoundError:\n            if not parents or self.parent == self:\n                raise\n            self.parent.mkdir(parents=True, exist_ok=True)\n            self.mkdir(mode, parents=False, exist_ok=exist_ok)\n        except OSError:\n            # Cannot rely on checking for EEXIST, since the operating system\n            # could give priority to other errors like EACCES or EROFS\n            if not exist_ok or not self.is_dir():\n                raise",
    "source": "pathlib.Path.mkdir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.open: Open the file pointed by this path and return a file object, as\nthe built-in open() function does.\n\nCódigo:\n    def open(self, mode='r', buffering=-1, encoding=None,\n             errors=None, newline=None):\n        \"\"\"\n        Open the file pointed by this path and return a file object, as\n        the built-in open() function does.\n        \"\"\"\n        return io.open(self, mode, buffering, encoding, errors, newline,\n                       opener=self._opener)",
    "source": "pathlib.Path.open",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.owner: Return the login name of the file owner.\n\nCódigo:\n    def owner(self):\n        \"\"\"\n        Return the login name of the file owner.\n        \"\"\"\n        return self._accessor.owner(self)",
    "source": "pathlib.Path.owner",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.read_bytes: Open the file in bytes mode, read it, and close the file.\n\nCódigo:\n    def read_bytes(self):\n        \"\"\"\n        Open the file in bytes mode, read it, and close the file.\n        \"\"\"\n        with self.open(mode='rb') as f:\n            return f.read()",
    "source": "pathlib.Path.read_bytes",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.read_text: Open the file in text mode, read it, and close the file.\n\nCódigo:\n    def read_text(self, encoding=None, errors=None):\n        \"\"\"\n        Open the file in text mode, read it, and close the file.\n        \"\"\"\n        with self.open(mode='r', encoding=encoding, errors=errors) as f:\n            return f.read()",
    "source": "pathlib.Path.read_text",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.readlink: Return the path to which the symbolic link points.\n\nCódigo:\n    def readlink(self):\n        \"\"\"\n        Return the path to which the symbolic link points.\n        \"\"\"\n        path = self._accessor.readlink(self)\n        obj = self._from_parts((path,), init=False)\n        obj._init(template=self)\n        return obj",
    "source": "pathlib.Path.readlink",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.relative_to: Return the relative path to another path identified by the passed\narguments.  If the operation is not possible (because this is not\na subpath of the other path), raise ValueError.\n\nCódigo:\n    def relative_to(self, *other):\n        \"\"\"Return the relative path to another path identified by the passed\n        arguments.  If the operation is not possible (because this is not\n        a subpath of the other path), raise ValueError.\n        \"\"\"\n        # For the purpose of this method, drive and root are considered\n        # separate parts, i.e.:\n        #   Path('c:/').relative_to('c:')  gives Path('/')\n        #   Path('c:/').relative_to('/')   raise ValueError\n        if not other:\n            raise TypeError(\"need at least one argument\")\n        parts = self._parts\n        drv = self._drv\n        root = self._root\n        if root:\n            abs_parts = [drv, root] + parts[1:]\n        else:\n            abs_parts = parts\n        to_drv, to_root, to_parts = self._parse_args(other)\n        if to_root:\n            to_abs_parts = [to_drv, to_root] + to_parts[1:]\n        else:\n            to_abs_parts = to_parts\n        n = len(to_abs_parts)\n        cf = self._flavour.casefold_parts\n        if (root or drv) if n == 0 else cf(abs_parts[:n]) != cf(to_abs_parts):\n            formatted = self._format_parsed_parts(to_drv, to_root, to_parts)\n            raise ValueError(\"{!r} is not in the subpath of {!r}\"\n                    \" OR one path is relative and the other is absolute.\"\n                             .format(str(self), str(formatted)))\n        return self._from_parsed_parts('', root if n == 1 else '',\n                                       abs_parts[n:])",
    "source": "pathlib.Path.relative_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.rename: Rename this path to the target path.\n\nThe target path may be absolute or relative. Relative paths are\ninterpreted relative to the current working directory, *not* the\ndirectory of the Path object.\n\nReturns the new Path instance pointing to the target path.\n\nCódigo:\n    def rename(self, target):\n        \"\"\"\n        Rename this path to the target path.\n        The target path may be absolute or relative. Relative paths are\n        interpreted relative to the current working directory, *not* the\n        directory of the Path object.\n        Returns the new Path instance pointing to the target path.\n        \"\"\"\n        self._accessor.rename(self, target)\n        return self.__class__(target)",
    "source": "pathlib.Path.rename",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.replace: Rename this path to the target path, overwriting if that path exists.\n\nThe target path may be absolute or relative. Relative paths are\ninterpreted relative to the current working directory, *not* the\ndirectory of the Path object.\n\nReturns the new Path instance pointing to the target path.\n\nCódigo:\n    def replace(self, target):\n        \"\"\"\n        Rename this path to the target path, overwriting if that path exists.\n        The target path may be absolute or relative. Relative paths are\n        interpreted relative to the current working directory, *not* the\n        directory of the Path object.\n        Returns the new Path instance pointing to the target path.\n        \"\"\"\n        self._accessor.replace(self, target)\n        return self.__class__(target)",
    "source": "pathlib.Path.replace",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.resolve: Make the path absolute, resolving all symlinks on the way and also\nnormalizing it (for example turning slashes into backslashes under\nWindows).\n\nCódigo:\n    def resolve(self, strict=False):\n        \"\"\"\n        Make the path absolute, resolving all symlinks on the way and also\n        normalizing it (for example turning slashes into backslashes under\n        Windows).\n        \"\"\"\n        s = self._flavour.resolve(self, strict=strict)\n        if s is None:\n            # No symlink resolution => for consistency, raise an error if\n            # the path doesn't exist or is forbidden\n            self.stat()\n            s = str(self.absolute())\n        # Now we have no symlinks in the path, it's safe to normalize it.\n        normed = self._flavour.pathmod.normpath(s)\n        obj = self._from_parts((normed,), init=False)\n        obj._init(template=self)\n        return obj",
    "source": "pathlib.Path.resolve",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.rglob: Recursively yield all existing files (of any kind, including\ndirectories) matching the given relative pattern, anywhere in\nthis subtree.\n\nCódigo:\n    def rglob(self, pattern):\n        \"\"\"Recursively yield all existing files (of any kind, including\n        directories) matching the given relative pattern, anywhere in\n        this subtree.\n        \"\"\"\n        sys.audit(\"pathlib.Path.rglob\", self, pattern)\n        drv, root, pattern_parts = self._flavour.parse_parts((pattern,))\n        if drv or root:\n            raise NotImplementedError(\"Non-relative patterns are unsupported\")\n        selector = _make_selector((\"**\",) + tuple(pattern_parts), self._flavour)\n        for p in selector.select_from(self):\n            yield p",
    "source": "pathlib.Path.rglob",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.rmdir: Remove this directory.  The directory must be empty.\n\nCódigo:\n    def rmdir(self):\n        \"\"\"\n        Remove this directory.  The directory must be empty.\n        \"\"\"\n        self._accessor.rmdir(self)",
    "source": "pathlib.Path.rmdir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.samefile: Return whether other_path is the same or not as this file\n(as returned by os.path.samefile()).\n\nCódigo:\n    def samefile(self, other_path):\n        \"\"\"Return whether other_path is the same or not as this file\n        (as returned by os.path.samefile()).\n        \"\"\"\n        st = self.stat()\n        try:\n            other_st = other_path.stat()\n        except AttributeError:\n            other_st = self._accessor.stat(other_path)\n        return os.path.samestat(st, other_st)",
    "source": "pathlib.Path.samefile",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.stat: Return the result of the stat() system call on this path, like\nos.stat() does.\n\nCódigo:\n    def stat(self):\n        \"\"\"\n        Return the result of the stat() system call on this path, like\n        os.stat() does.\n        \"\"\"\n        return self._accessor.stat(self)",
    "source": "pathlib.Path.stat",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.symlink_to: Make this path a symlink pointing to the target path.\nNote the order of arguments (link, target) is the reverse of os.symlink.\n\nCódigo:\n    def symlink_to(self, target, target_is_directory=False):\n        \"\"\"\n        Make this path a symlink pointing to the target path.\n        Note the order of arguments (link, target) is the reverse of os.symlink.\n        \"\"\"\n        self._accessor.symlink(target, self, target_is_directory)",
    "source": "pathlib.Path.symlink_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.touch: Create this file with the given access mode, if it doesn't exist.\n\nCódigo:\n    def touch(self, mode=0o666, exist_ok=True):\n        \"\"\"\n        Create this file with the given access mode, if it doesn't exist.\n        \"\"\"\n        if exist_ok:\n            # First try to bump modification time\n            # Implementation note: GNU touch uses the UTIME_NOW option of\n            # the utimensat() / futimens() functions.\n            try:\n                self._accessor.utime(self, None)\n            except OSError:\n                # Avoid exception chaining\n                pass\n            else:\n                return\n        flags = os.O_CREAT | os.O_WRONLY\n        if not exist_ok:\n            flags |= os.O_EXCL\n        fd = self._raw_open(flags, mode)\n        os.close(fd)",
    "source": "pathlib.Path.touch",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.unlink: Remove this file or link.\nIf the path is a directory, use rmdir() instead.\n\nCódigo:\n    def unlink(self, missing_ok=False):\n        \"\"\"\n        Remove this file or link.\n        If the path is a directory, use rmdir() instead.\n        \"\"\"\n        try:\n            self._accessor.unlink(self)\n        except FileNotFoundError:\n            if not missing_ok:\n                raise",
    "source": "pathlib.Path.unlink",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.with_name: Return a new path with the file name changed.\n\nCódigo:\n    def with_name(self, name):\n        \"\"\"Return a new path with the file name changed.\"\"\"\n        if not self.name:\n            raise ValueError(\"%r has an empty name\" % (self,))\n        drv, root, parts = self._flavour.parse_parts((name,))\n        if (not name or name[-1] in [self._flavour.sep, self._flavour.altsep]\n            or drv or root or len(parts) != 1):\n            raise ValueError(\"Invalid name %r\" % (name))\n        return self._from_parsed_parts(self._drv, self._root,\n                                       self._parts[:-1] + [name])",
    "source": "pathlib.Path.with_name",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.with_stem: Return a new path with the stem changed.\n\nCódigo:\n    def with_stem(self, stem):\n        \"\"\"Return a new path with the stem changed.\"\"\"\n        return self.with_name(stem + self.suffix)",
    "source": "pathlib.Path.with_stem",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.with_suffix: Return a new path with the file suffix changed.  If the path\nhas no suffix, add given suffix.  If the given suffix is an empty\nstring, remove the suffix from the path.\n\nCódigo:\n    def with_suffix(self, suffix):\n        \"\"\"Return a new path with the file suffix changed.  If the path\n        has no suffix, add given suffix.  If the given suffix is an empty\n        string, remove the suffix from the path.\n        \"\"\"\n        f = self._flavour\n        if f.sep in suffix or f.altsep and f.altsep in suffix:\n            raise ValueError(\"Invalid suffix %r\" % (suffix,))\n        if suffix and not suffix.startswith('.') or suffix == '.':\n            raise ValueError(\"Invalid suffix %r\" % (suffix))\n        name = self.name\n        if not name:\n            raise ValueError(\"%r has an empty name\" % (self,))\n        old_suffix = self.suffix\n        if not old_suffix:\n            name = name + suffix\n        else:\n            name = name[:-len(old_suffix)] + suffix\n        return self._from_parsed_parts(self._drv, self._root,\n                                       self._parts[:-1] + [name])",
    "source": "pathlib.Path.with_suffix",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.write_bytes: Open the file in bytes mode, write to it, and close the file.\n\nCódigo:\n    def write_bytes(self, data):\n        \"\"\"\n        Open the file in bytes mode, write to it, and close the file.\n        \"\"\"\n        # type-check for the buffer interface before truncating the file\n        view = memoryview(data)\n        with self.open(mode='wb') as f:\n            return f.write(view)",
    "source": "pathlib.Path.write_bytes",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.write_text: Open the file in text mode, write to it, and close the file.\n\nCódigo:\n    def write_text(self, data, encoding=None, errors=None):\n        \"\"\"\n        Open the file in text mode, write to it, and close the file.\n        \"\"\"\n        if not isinstance(data, str):\n            raise TypeError('data must be str, not %s' %\n                            data.__class__.__name__)\n        with self.open(mode='w', encoding=encoding, errors=errors) as f:\n            return f.write(data)",
    "source": "pathlib.Path.write_text",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase ThreadPoolExecutor: This is an abstract base class for concrete asynchronous executors.",
    "source": "concurrent.futures.thread.ThreadPoolExecutor",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.__init__: Initializes a new ThreadPoolExecutor instance.\n\nArgs:\n    max_workers: The maximum number of threads that can be used to\n        execute the given calls.\n    thread_name_prefix: An optional name prefix to give our threads.\n    initializer: A callable used to initialize worker threads.\n    initargs: A tuple of arguments to pass to the initializer.\n\nCódigo:\n    def __init__(self, max_workers=None, thread_name_prefix='',\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n        Args:\n            max_workers: The maximum number of threads that can be used to\n                execute the given calls.\n            thread_name_prefix: An optional name prefix to give our threads.\n            initializer: A callable used to initialize worker threads.\n            initargs: A tuple of arguments to pass to the initializer.\n        \"\"\"\n        if max_workers is None:\n            # ThreadPoolExecutor is often used to:\n            # * CPU bound task which releases GIL\n            # * I/O bound task (which releases GIL, of course)\n            #\n            # We use cpu_count + 4 for both types of tasks.\n            # But we limit it to 32 to avoid consuming surprisingly large resource\n            # on many core machine.\n            max_workers = min(32, (os.cpu_count() or 1) + 4)\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be greater than 0\")\n        if initializer is not None and not callable(initializer):\n            raise TypeError(\"initializer must be a callable\")\n        self._max_workers = max_workers\n        self._work_queue = queue.SimpleQueue()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._threads = set()\n        self._broken = False\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._thread_name_prefix = (thread_name_prefix or\n                                    (\"ThreadPoolExecutor-%d\" % self._counter()))\n        self._initializer = initializer\n        self._initargs = initargs",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.map: Returns an iterator equivalent to map(fn, iter).\n\nArgs:\n    fn: A callable that will take as many arguments as there are\n        passed iterables.\n    timeout: The maximum number of seconds to wait. If None, then there\n        is no limit on the wait time.\n    chunksize: The size of the chunks the iterable will be broken into\n        before being passed to a child process. This argument is only\n        used by ProcessPoolExecutor; it is ignored by\n        ThreadPoolExecutor.\n\nReturns:\n    An iterator equivalent to: map(func, *iterables) but the calls may\n    be evaluated out-of-order.\n\nRaises:\n    TimeoutError: If the entire result iterator could not be generated\n        before the given timeout.\n    Exception: If fn(*args) raises for any values.\n\nCódigo:\n    def map(self, fn, *iterables, timeout=None, chunksize=1):\n        \"\"\"Returns an iterator equivalent to map(fn, iter).\n        Args:\n            fn: A callable that will take as many arguments as there are\n                passed iterables.\n            timeout: The maximum number of seconds to wait. If None, then there\n                is no limit on the wait time.\n            chunksize: The size of the chunks the iterable will be broken into\n                before being passed to a child process. This argument is only\n                used by ProcessPoolExecutor; it is ignored by\n                ThreadPoolExecutor.\n        Returns:\n            An iterator equivalent to: map(func, *iterables) but the calls may\n            be evaluated out-of-order.\n        Raises:\n            TimeoutError: If the entire result iterator could not be generated\n                before the given timeout.\n            Exception: If fn(*args) raises for any values.\n        \"\"\"\n        if timeout is not None:\n            end_time = timeout + time.monotonic()\n        fs = [self.submit(fn, *args) for args in zip(*iterables)]\n        # Yield must be hidden in closure so that the futures are submitted\n        # before the first iterator value is required.\n        def result_iterator():\n            try:\n                # reverse to keep finishing order\n                fs.reverse()\n                while fs:\n                    # Careful not to keep a reference to the popped future\n                    if timeout is None:\n                        yield fs.pop().result()\n                    else:\n                        yield fs.pop().result(end_time - time.monotonic())\n            finally:\n                for future in fs:\n                    future.cancel()\n        return result_iterator()",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.map",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.shutdown: Clean-up the resources associated with the Executor.\n\nIt is safe to call this method several times. Otherwise, no other\nmethods can be called after this one.\n\nArgs:\n    wait: If True then shutdown will not return until all running\n        futures have finished executing and the resources used by the\n        executor have been reclaimed.\n    cancel_futures: If True then shutdown will cancel all pending\n        futures. Futures that are completed or running will not be\n        cancelled.\n\nCódigo:\n    def shutdown(self, wait=True, *, cancel_futures=False):\n        with self._shutdown_lock:\n            self._shutdown = True\n            if cancel_futures:\n                # Drain all work items from the queue, and then cancel their\n                # associated futures.\n                while True:\n                    try:\n                        work_item = self._work_queue.get_nowait()\n                    except queue.Empty:\n                        break\n                    if work_item is not None:\n                        work_item.future.cancel()\n            # Send a wake-up to prevent threads calling\n            # _work_queue.get(block=True) from permanently blocking.\n            self._work_queue.put(None)\n        if wait:\n            for t in self._threads:\n                t.join()",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.shutdown",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.submit: Submits a callable to be executed with the given arguments.\n\nSchedules the callable to be executed as fn(*args, **kwargs) and returns\na Future instance representing the execution of the callable.\n\nReturns:\n    A Future representing the given call.\n\nCódigo:\n    def submit(self, fn, /, *args, **kwargs):\n        with self._shutdown_lock, _global_shutdown_lock:\n            if self._broken:\n                raise BrokenThreadPool(self._broken)\n            if self._shutdown:\n                raise RuntimeError('cannot schedule new futures after shutdown')\n            if _shutdown:\n                raise RuntimeError('cannot schedule new futures after '\n                                   'interpreter shutdown')\n            f = _base.Future()\n            w = _WorkItem(f, fn, args, kwargs)\n            self._work_queue.put(w)\n            self._adjust_thread_count()\n            return f",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.submit",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_decrypt_cbc: Descifra un texto cifrado con AES en modo CBC.\n\nArgs:\n    ciphertext_b64: Texto cifrado en base64\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef aes_decrypt_cbc(ciphertext_b64, password):\n    \"\"\"\n    Descifra un texto cifrado con AES en modo CBC.\n    Args:\n        ciphertext_b64: Texto cifrado en base64\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Decodificar de base64\n    ciphertext = base64.b64decode(ciphertext_b64)\n    # Extraer salt, iv y texto cifrado\n    salt = ciphertext[:16]\n    iv = ciphertext[16:32]\n    actual_ciphertext = ciphertext[32:]\n    # Derivar clave\n    key, _, _ = derive_key_and_iv(password, salt)\n    # Descifrar\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    padded_text = cipher.decrypt(actual_ciphertext)\n    text = unpad(padded_text, CryptoAES.block_size)\n    return text.decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_decrypt_cbc",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_decrypt_gcm: Descifra un texto cifrado con AES en modo GCM.\n\nArgs:\n    ciphertext_b64: Texto cifrado en base64\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef aes_decrypt_gcm(ciphertext_b64, password):\n    \"\"\"\n    Descifra un texto cifrado con AES en modo GCM.\n    Args:\n        ciphertext_b64: Texto cifrado en base64\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Decodificar de base64\n    ciphertext = base64.b64decode(ciphertext_b64)\n    # Extraer salt, nonce, tag y texto cifrado\n    salt = ciphertext[:16]\n    nonce = ciphertext[16:28]\n    tag = ciphertext[28:44]\n    actual_ciphertext = ciphertext[44:]\n    # Derivar clave\n    key, _, _ = derive_key_and_iv(password, salt, key_length=32, iv_length=12)\n    # Descifrar\n    cipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    text = cipher.decrypt_and_verify(actual_ciphertext, tag)\n    return text.decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_decrypt_gcm",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_encrypt_cbc: Cifra un texto usando AES en modo CBC.\n\nArgs:\n    text: Texto a cifrar\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto cifrado en base64\n\nCódigo:\ndef aes_encrypt_cbc(text, password):\n    \"\"\"\n    Cifra un texto usando AES en modo CBC.\n    Args:\n        text: Texto a cifrar\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto cifrado en base64\n    \"\"\"\n    # Derivar clave e IV\n    key, iv, salt = derive_key_and_iv(password)\n    # Crear cifrador AES en modo CBC\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    # Cifrar el texto\n    text_bytes = text.encode('utf-8')\n    padded_data = pad(text_bytes, CryptoAES.block_size)\n    ciphertext = cipher.encrypt(padded_data)\n    # Combinar salt + iv + ciphertext y convertir a base64\n    result = salt + iv + ciphertext\n    return base64.b64encode(result).decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_encrypt_cbc",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_encrypt_gcm: Cifra un texto usando AES en modo GCM.\n\nArgs:\n    text: Texto a cifrar\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto cifrado en base64\n\nCódigo:\ndef aes_encrypt_gcm(text, password):\n    \"\"\"\n    Cifra un texto usando AES en modo GCM.\n    Args:\n        text: Texto a cifrar\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto cifrado en base64\n    \"\"\"\n    # Derivar clave y nonce\n    key, nonce, salt = derive_key_and_iv(password, key_length=32, iv_length=12)\n    # Crear cifrador AES en modo GCM\n    cipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    # Cifrar el texto\n    text_bytes = text.encode('utf-8')\n    ciphertext, tag = cipher.encrypt_and_digest(text_bytes)\n    # Combinar salt + nonce + tag + ciphertext y convertir a base64\n    result = salt + nonce + tag + ciphertext\n    return base64.b64encode(result).decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_encrypt_gcm",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_example_with_cryptography: Ejemplo de encriptación AES usando la biblioteca cryptography.\n\nCódigo:\ndef aes_example_with_cryptography():\n    \"\"\"Ejemplo de encriptación AES usando la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN AES CON CRYPTOGRAPHY\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar\n    mensaje = \"Este es un mensaje secreto que será encriptado con AES.\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = os.urandom(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un vector de inicialización (IV) aleatorio\n    iv = os.urandom(16)  # AES block size = 16 bytes\n    print(f\"IV (en base64): {base64.b64encode(iv).decode()}\")\n    # Convertir el mensaje a bytes y aplicar padding\n    padder = padding.PKCS7(algorithms.AES.block_size).padder()\n    mensaje_bytes = mensaje.encode('utf-8')\n    padded_data = padder.update(mensaje_bytes) + padder.finalize()\n    # Crear un cifrador AES en modo CBC\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\n    encryptor = cipher.encryptor()\n    # Encriptar el mensaje\n    ciphertext = encryptor.update(padded_data) + encryptor.finalize()\n    print(f\"Mensaje encriptado (en base64): {base64.b64encode(ciphertext).decode()}\")\n    # Desencriptar el mensaje\n    decryptor = cipher.decryptor()\n    padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n    # Quitar el padding\n    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()\n    plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.aes_example_with_cryptography",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_example_with_pycryptodome: Ejemplo de encriptación AES usando la biblioteca PyCryptodome.\n\nCódigo:\ndef aes_example_with_pycryptodome():\n    \"\"\"Ejemplo de encriptación AES usando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN AES CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar\n    mensaje = \"Este es otro mensaje secreto para encriptar con AES usando PyCryptodome.\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = get_random_bytes(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un vector de inicialización (IV) aleatorio\n    iv = get_random_bytes(16)  # AES block size = 16 bytes\n    print(f\"IV (en base64): {base64.b64encode(iv).decode()}\")\n    # Crear un cifrador AES en modo CBC\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    # Encriptar el mensaje (con padding)\n    mensaje_bytes = mensaje.encode('utf-8')\n    padded_data = pad(mensaje_bytes, CryptoAES.block_size)\n    ciphertext = cipher.encrypt(padded_data)\n    print(f\"Mensaje encriptado (en base64): {base64.b64encode(ciphertext).decode()}\")\n    # Desencriptar el mensaje\n    decipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    padded_plaintext = decipher.decrypt(ciphertext)\n    plaintext = unpad(padded_plaintext, CryptoAES.block_size)\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.aes_example_with_pycryptodome",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_gcm_example: Ejemplo de encriptación AES en modo GCM (Galois/Counter Mode) que proporciona autenticación.\n\nCódigo:\ndef aes_gcm_example():\n    \"\"\"Ejemplo de encriptación AES en modo GCM (Galois/Counter Mode) que proporciona autenticación.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN AES-GCM (CON AUTENTICACIÓN)\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar\n    mensaje = \"Mensaje secreto con autenticación usando AES-GCM.\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Datos adicionales autenticados (no encriptados pero autenticados)\n    aad = b\"Datos adicionales autenticados\"\n    print(f\"Datos adicionales: {aad.decode()}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = get_random_bytes(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un nonce aleatorio (similar a un IV pero para GCM)\n    nonce = get_random_bytes(12)  # 12 bytes es el tamaño recomendado para GCM\n    print(f\"Nonce (en base64): {base64.b64encode(nonce).decode()}\")\n    # Crear un cifrador AES en modo GCM\n    cipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    # Añadir los datos adicionales autenticados\n    cipher.update(aad)\n    # Encriptar el mensaje (GCM no requiere padding)\n    mensaje_bytes = mensaje.encode('utf-8')\n    ciphertext, tag = cipher.encrypt_and_digest(mensaje_bytes)\n    print(f\"Mensaje encriptado (en base64): {base64.b64encode(ciphertext).decode()}\")\n    print(f\"Tag de autenticación (en base64): {base64.b64encode(tag).decode()}\")\n    # Desencriptar y verificar el mensaje\n    decipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    decipher.update(aad)\n    try:\n        plaintext = decipher.decrypt_and_verify(ciphertext, tag)\n        print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n        print(\"✓ Autenticación exitosa: El mensaje no ha sido alterado.\")\n    except ValueError:\n        print(\"✗ Error de autenticación: El mensaje o el tag han sido alterados.\")\n    # Demostrar qué sucede si el mensaje es alterado\n    print(\"\\nSimulación de alteración del mensaje:\")\n    # Alterar un byte del mensaje encriptado\n    altered_ciphertext = bytearray(ciphertext)\n    altered_ciphertext[0] = (altered_ciphertext[0] + 1) % 256\n    altered_ciphertext = bytes(altered_ciphertext)\n    # Intentar desencriptar el mensaje alterado\n    decipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    decipher.update(aad)\n    try:\n        plaintext = decipher.decrypt_and_verify(altered_ciphertext, tag)\n        print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n        print(\"✓ Autenticación exitosa: El mensaje no ha sido alterado.\")\n    except ValueError:\n        print(\"✗ Error de autenticación: El mensaje o el tag han sido alterados.\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.aes_gcm_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Módulo algorithms.asymmetric_encryption: Ejemplos de algoritmos de encriptación asimétrica: RSA y Curvas Elípticas (ECC).\nEste script implementa ejemplos básicos de encriptación asimétrica y muestra cómo\nutilizarlos para cifrar/descifrar mensajes.",
    "source": "algorithms.asymmetric_encryption",
    "type": "module",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase InvalidSignature: Common base class for all non-exit exceptions.",
    "source": "cryptography.exceptions.InvalidSignature",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase Path: PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
    "source": "pathlib.Path",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.absolute: Return an absolute version of this path.  This function works\neven if the path doesn't point to anything.\n\nNo normalization is done, i.e. all '.' and '..' will be kept along.\nUse resolve() to get the canonical path to a file.\n\nCódigo:\n    def absolute(self):\n        \"\"\"Return an absolute version of this path.  This function works\n        even if the path doesn't point to anything.\n        No normalization is done, i.e. all '.' and '..' will be kept along.\n        Use resolve() to get the canonical path to a file.\n        \"\"\"\n        # XXX untested yet!\n        if self.is_absolute():\n            return self\n        # FIXME this must defer to the specific flavour (and, under Windows,\n        # use nt._getfullpathname())\n        obj = self._from_parts([os.getcwd()] + self._parts, init=False)\n        obj._init(template=self)\n        return obj",
    "source": "pathlib.Path.absolute",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.as_posix: Return the string representation of the path with forward (/)\nslashes.\n\nCódigo:\n    def as_posix(self):\n        \"\"\"Return the string representation of the path with forward (/)\n        slashes.\"\"\"\n        f = self._flavour\n        return str(self).replace(f.sep, '/')",
    "source": "pathlib.Path.as_posix",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.as_uri: Return the path as a 'file' URI.\n\nCódigo:\n    def as_uri(self):\n        \"\"\"Return the path as a 'file' URI.\"\"\"\n        if not self.is_absolute():\n            raise ValueError(\"relative path can't be expressed as a file URI\")\n        return self._flavour.make_uri(self)",
    "source": "pathlib.Path.as_uri",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.chmod: Change the permissions of the path, like os.chmod().\n\nCódigo:\n    def chmod(self, mode):\n        \"\"\"\n        Change the permissions of the path, like os.chmod().\n        \"\"\"\n        self._accessor.chmod(self, mode)",
    "source": "pathlib.Path.chmod",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.exists: Whether this path exists.\n\nCódigo:\n    def exists(self):\n        \"\"\"\n        Whether this path exists.\n        \"\"\"\n        try:\n            self.stat()\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False\n        return True",
    "source": "pathlib.Path.exists",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.expanduser: Return a new path with expanded ~ and ~user constructs\n(as returned by os.path.expanduser)\n\nCódigo:\n    def expanduser(self):\n        \"\"\" Return a new path with expanded ~ and ~user constructs\n        (as returned by os.path.expanduser)\n        \"\"\"\n        if (not (self._drv or self._root) and\n            self._parts and self._parts[0][:1] == '~'):\n            homedir = self._flavour.gethomedir(self._parts[0][1:])\n            return self._from_parts([homedir] + self._parts[1:])\n        return self",
    "source": "pathlib.Path.expanduser",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.glob: Iterate over this subtree and yield all existing files (of any\nkind, including directories) matching the given relative pattern.\n\nCódigo:\n    def glob(self, pattern):\n        \"\"\"Iterate over this subtree and yield all existing files (of any\n        kind, including directories) matching the given relative pattern.\n        \"\"\"\n        sys.audit(\"pathlib.Path.glob\", self, pattern)\n        if not pattern:\n            raise ValueError(\"Unacceptable pattern: {!r}\".format(pattern))\n        drv, root, pattern_parts = self._flavour.parse_parts((pattern,))\n        if drv or root:\n            raise NotImplementedError(\"Non-relative patterns are unsupported\")\n        selector = _make_selector(tuple(pattern_parts), self._flavour)\n        for p in selector.select_from(self):\n            yield p",
    "source": "pathlib.Path.glob",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.group: Return the group name of the file gid.\n\nCódigo:\n    def group(self):\n        \"\"\"\n        Return the group name of the file gid.\n        \"\"\"\n        return self._accessor.group(self)",
    "source": "pathlib.Path.group",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_absolute: True if the path is absolute (has both a root and, if applicable,\na drive).\n\nCódigo:\n    def is_absolute(self):\n        \"\"\"True if the path is absolute (has both a root and, if applicable,\n        a drive).\"\"\"\n        if not self._root:\n            return False\n        return not self._flavour.has_drv or bool(self._drv)",
    "source": "pathlib.Path.is_absolute",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_block_device: Whether this path is a block device.\n\nCódigo:\n    def is_block_device(self):\n        \"\"\"\n        Whether this path is a block device.\n        \"\"\"\n        try:\n            return S_ISBLK(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_block_device",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_char_device: Whether this path is a character device.\n\nCódigo:\n    def is_char_device(self):\n        \"\"\"\n        Whether this path is a character device.\n        \"\"\"\n        try:\n            return S_ISCHR(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_char_device",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_dir: Whether this path is a directory.\n\nCódigo:\n    def is_dir(self):\n        \"\"\"\n        Whether this path is a directory.\n        \"\"\"\n        try:\n            return S_ISDIR(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_dir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_fifo: Whether this path is a FIFO.\n\nCódigo:\n    def is_fifo(self):\n        \"\"\"\n        Whether this path is a FIFO.\n        \"\"\"\n        try:\n            return S_ISFIFO(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_fifo",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_file: Whether this path is a regular file (also True for symlinks pointing\nto regular files).\n\nCódigo:\n    def is_file(self):\n        \"\"\"\n        Whether this path is a regular file (also True for symlinks pointing\n        to regular files).\n        \"\"\"\n        try:\n            return S_ISREG(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_mount: Check if this path is a POSIX mount point\n\nCódigo:\n    def is_mount(self):\n        \"\"\"\n        Check if this path is a POSIX mount point\n        \"\"\"\n        # Need to exist and be a dir\n        if not self.exists() or not self.is_dir():\n            return False\n        try:\n            parent_dev = self.parent.stat().st_dev\n        except OSError:\n            return False\n        dev = self.stat().st_dev\n        if dev != parent_dev:\n            return True\n        ino = self.stat().st_ino\n        parent_ino = self.parent.stat().st_ino\n        return ino == parent_ino",
    "source": "pathlib.Path.is_mount",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_relative_to: Return True if the path is relative to another path or False.\n        \n\nCódigo:\n    def is_relative_to(self, *other):\n        \"\"\"Return True if the path is relative to another path or False.\n        \"\"\"\n        try:\n            self.relative_to(*other)\n            return True\n        except ValueError:\n            return False",
    "source": "pathlib.Path.is_relative_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_reserved: Return True if the path contains one of the special names reserved\nby the system, if any.\n\nCódigo:\n    def is_reserved(self):\n        \"\"\"Return True if the path contains one of the special names reserved\n        by the system, if any.\"\"\"\n        return self._flavour.is_reserved(self._parts)",
    "source": "pathlib.Path.is_reserved",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_socket: Whether this path is a socket.\n\nCódigo:\n    def is_socket(self):\n        \"\"\"\n        Whether this path is a socket.\n        \"\"\"\n        try:\n            return S_ISSOCK(self.stat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist or is a broken symlink\n            # (see http://web.archive.org/web/20200623061726/https://bitbucket.org/pitrou/pathlib/issues/12/ )\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_socket",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.is_symlink: Whether this path is a symbolic link.\n\nCódigo:\n    def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if not _ignore_error(e):\n                raise\n            # Path doesn't exist\n            return False\n        except ValueError:\n            # Non-encodable path\n            return False",
    "source": "pathlib.Path.is_symlink",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.iterdir: Iterate over the files in this directory.  Does not yield any\nresult for the special paths '.' and '..'.\n\nCódigo:\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n        for name in self._accessor.listdir(self):\n            if name in {'.', '..'}:\n                # Yielding a path object for these makes little sense\n                continue\n            yield self._make_child_relpath(name)",
    "source": "pathlib.Path.iterdir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.joinpath: Combine this path with one or several arguments, and return a\nnew path representing either a subpath (if all arguments are relative\npaths) or a totally different path (if one of the arguments is\nanchored).\n\nCódigo:\n    def joinpath(self, *args):\n        \"\"\"Combine this path with one or several arguments, and return a\n        new path representing either a subpath (if all arguments are relative\n        paths) or a totally different path (if one of the arguments is\n        anchored).\n        \"\"\"\n        return self._make_child(args)",
    "source": "pathlib.Path.joinpath",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.lchmod: Like chmod(), except if the path points to a symlink, the symlink's\npermissions are changed, rather than its target's.\n\nCódigo:\n    def lchmod(self, mode):\n        \"\"\"\n        Like chmod(), except if the path points to a symlink, the symlink's\n        permissions are changed, rather than its target's.\n        \"\"\"\n        self._accessor.lchmod(self, mode)",
    "source": "pathlib.Path.lchmod",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.link_to: Make the target path a hard link pointing to this path.\n\nNote this function does not make this path a hard link to *target*,\ndespite the implication of the function and argument names. The order\nof arguments (target, link) is the reverse of Path.symlink_to, but\nmatches that of os.link.\n\nCódigo:\n    def link_to(self, target):\n        \"\"\"\n        Make the target path a hard link pointing to this path.\n        Note this function does not make this path a hard link to *target*,\n        despite the implication of the function and argument names. The order\n        of arguments (target, link) is the reverse of Path.symlink_to, but\n        matches that of os.link.\n        \"\"\"\n        self._accessor.link_to(self, target)",
    "source": "pathlib.Path.link_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.lstat: Like stat(), except if the path points to a symlink, the symlink's\nstatus information is returned, rather than its target's.\n\nCódigo:\n    def lstat(self):\n        \"\"\"\n        Like stat(), except if the path points to a symlink, the symlink's\n        status information is returned, rather than its target's.\n        \"\"\"\n        return self._accessor.lstat(self)",
    "source": "pathlib.Path.lstat",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.match: Return True if this path matches the given pattern.\n\nCódigo:\n    def match(self, path_pattern):\n        \"\"\"\n        Return True if this path matches the given pattern.\n        \"\"\"\n        cf = self._flavour.casefold\n        path_pattern = cf(path_pattern)\n        drv, root, pat_parts = self._flavour.parse_parts((path_pattern,))\n        if not pat_parts:\n            raise ValueError(\"empty pattern\")\n        if drv and drv != cf(self._drv):\n            return False\n        if root and root != cf(self._root):\n            return False\n        parts = self._cparts\n        if drv or root:\n            if len(pat_parts) != len(parts):\n                return False\n            pat_parts = pat_parts[1:]\n        elif len(pat_parts) > len(parts):\n            return False\n        for part, pat in zip(reversed(parts), reversed(pat_parts)):\n            if not fnmatch.fnmatchcase(part, pat):\n                return False\n        return True",
    "source": "pathlib.Path.match",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.mkdir: Create a new directory at this given path.\n\nCódigo:\n    def mkdir(self, mode=0o777, parents=False, exist_ok=False):\n        \"\"\"\n        Create a new directory at this given path.\n        \"\"\"\n        try:\n            self._accessor.mkdir(self, mode)\n        except FileNotFoundError:\n            if not parents or self.parent == self:\n                raise\n            self.parent.mkdir(parents=True, exist_ok=True)\n            self.mkdir(mode, parents=False, exist_ok=exist_ok)\n        except OSError:\n            # Cannot rely on checking for EEXIST, since the operating system\n            # could give priority to other errors like EACCES or EROFS\n            if not exist_ok or not self.is_dir():\n                raise",
    "source": "pathlib.Path.mkdir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.open: Open the file pointed by this path and return a file object, as\nthe built-in open() function does.\n\nCódigo:\n    def open(self, mode='r', buffering=-1, encoding=None,\n             errors=None, newline=None):\n        \"\"\"\n        Open the file pointed by this path and return a file object, as\n        the built-in open() function does.\n        \"\"\"\n        return io.open(self, mode, buffering, encoding, errors, newline,\n                       opener=self._opener)",
    "source": "pathlib.Path.open",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.owner: Return the login name of the file owner.\n\nCódigo:\n    def owner(self):\n        \"\"\"\n        Return the login name of the file owner.\n        \"\"\"\n        return self._accessor.owner(self)",
    "source": "pathlib.Path.owner",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.read_bytes: Open the file in bytes mode, read it, and close the file.\n\nCódigo:\n    def read_bytes(self):\n        \"\"\"\n        Open the file in bytes mode, read it, and close the file.\n        \"\"\"\n        with self.open(mode='rb') as f:\n            return f.read()",
    "source": "pathlib.Path.read_bytes",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.read_text: Open the file in text mode, read it, and close the file.\n\nCódigo:\n    def read_text(self, encoding=None, errors=None):\n        \"\"\"\n        Open the file in text mode, read it, and close the file.\n        \"\"\"\n        with self.open(mode='r', encoding=encoding, errors=errors) as f:\n            return f.read()",
    "source": "pathlib.Path.read_text",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.readlink: Return the path to which the symbolic link points.\n\nCódigo:\n    def readlink(self):\n        \"\"\"\n        Return the path to which the symbolic link points.\n        \"\"\"\n        path = self._accessor.readlink(self)\n        obj = self._from_parts((path,), init=False)\n        obj._init(template=self)\n        return obj",
    "source": "pathlib.Path.readlink",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.relative_to: Return the relative path to another path identified by the passed\narguments.  If the operation is not possible (because this is not\na subpath of the other path), raise ValueError.\n\nCódigo:\n    def relative_to(self, *other):\n        \"\"\"Return the relative path to another path identified by the passed\n        arguments.  If the operation is not possible (because this is not\n        a subpath of the other path), raise ValueError.\n        \"\"\"\n        # For the purpose of this method, drive and root are considered\n        # separate parts, i.e.:\n        #   Path('c:/').relative_to('c:')  gives Path('/')\n        #   Path('c:/').relative_to('/')   raise ValueError\n        if not other:\n            raise TypeError(\"need at least one argument\")\n        parts = self._parts\n        drv = self._drv\n        root = self._root\n        if root:\n            abs_parts = [drv, root] + parts[1:]\n        else:\n            abs_parts = parts\n        to_drv, to_root, to_parts = self._parse_args(other)\n        if to_root:\n            to_abs_parts = [to_drv, to_root] + to_parts[1:]\n        else:\n            to_abs_parts = to_parts\n        n = len(to_abs_parts)\n        cf = self._flavour.casefold_parts\n        if (root or drv) if n == 0 else cf(abs_parts[:n]) != cf(to_abs_parts):\n            formatted = self._format_parsed_parts(to_drv, to_root, to_parts)\n            raise ValueError(\"{!r} is not in the subpath of {!r}\"\n                    \" OR one path is relative and the other is absolute.\"\n                             .format(str(self), str(formatted)))\n        return self._from_parsed_parts('', root if n == 1 else '',\n                                       abs_parts[n:])",
    "source": "pathlib.Path.relative_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.rename: Rename this path to the target path.\n\nThe target path may be absolute or relative. Relative paths are\ninterpreted relative to the current working directory, *not* the\ndirectory of the Path object.\n\nReturns the new Path instance pointing to the target path.\n\nCódigo:\n    def rename(self, target):\n        \"\"\"\n        Rename this path to the target path.\n        The target path may be absolute or relative. Relative paths are\n        interpreted relative to the current working directory, *not* the\n        directory of the Path object.\n        Returns the new Path instance pointing to the target path.\n        \"\"\"\n        self._accessor.rename(self, target)\n        return self.__class__(target)",
    "source": "pathlib.Path.rename",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.replace: Rename this path to the target path, overwriting if that path exists.\n\nThe target path may be absolute or relative. Relative paths are\ninterpreted relative to the current working directory, *not* the\ndirectory of the Path object.\n\nReturns the new Path instance pointing to the target path.\n\nCódigo:\n    def replace(self, target):\n        \"\"\"\n        Rename this path to the target path, overwriting if that path exists.\n        The target path may be absolute or relative. Relative paths are\n        interpreted relative to the current working directory, *not* the\n        directory of the Path object.\n        Returns the new Path instance pointing to the target path.\n        \"\"\"\n        self._accessor.replace(self, target)\n        return self.__class__(target)",
    "source": "pathlib.Path.replace",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.resolve: Make the path absolute, resolving all symlinks on the way and also\nnormalizing it (for example turning slashes into backslashes under\nWindows).\n\nCódigo:\n    def resolve(self, strict=False):\n        \"\"\"\n        Make the path absolute, resolving all symlinks on the way and also\n        normalizing it (for example turning slashes into backslashes under\n        Windows).\n        \"\"\"\n        s = self._flavour.resolve(self, strict=strict)\n        if s is None:\n            # No symlink resolution => for consistency, raise an error if\n            # the path doesn't exist or is forbidden\n            self.stat()\n            s = str(self.absolute())\n        # Now we have no symlinks in the path, it's safe to normalize it.\n        normed = self._flavour.pathmod.normpath(s)\n        obj = self._from_parts((normed,), init=False)\n        obj._init(template=self)\n        return obj",
    "source": "pathlib.Path.resolve",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.rglob: Recursively yield all existing files (of any kind, including\ndirectories) matching the given relative pattern, anywhere in\nthis subtree.\n\nCódigo:\n    def rglob(self, pattern):\n        \"\"\"Recursively yield all existing files (of any kind, including\n        directories) matching the given relative pattern, anywhere in\n        this subtree.\n        \"\"\"\n        sys.audit(\"pathlib.Path.rglob\", self, pattern)\n        drv, root, pattern_parts = self._flavour.parse_parts((pattern,))\n        if drv or root:\n            raise NotImplementedError(\"Non-relative patterns are unsupported\")\n        selector = _make_selector((\"**\",) + tuple(pattern_parts), self._flavour)\n        for p in selector.select_from(self):\n            yield p",
    "source": "pathlib.Path.rglob",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.rmdir: Remove this directory.  The directory must be empty.\n\nCódigo:\n    def rmdir(self):\n        \"\"\"\n        Remove this directory.  The directory must be empty.\n        \"\"\"\n        self._accessor.rmdir(self)",
    "source": "pathlib.Path.rmdir",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.samefile: Return whether other_path is the same or not as this file\n(as returned by os.path.samefile()).\n\nCódigo:\n    def samefile(self, other_path):\n        \"\"\"Return whether other_path is the same or not as this file\n        (as returned by os.path.samefile()).\n        \"\"\"\n        st = self.stat()\n        try:\n            other_st = other_path.stat()\n        except AttributeError:\n            other_st = self._accessor.stat(other_path)\n        return os.path.samestat(st, other_st)",
    "source": "pathlib.Path.samefile",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.stat: Return the result of the stat() system call on this path, like\nos.stat() does.\n\nCódigo:\n    def stat(self):\n        \"\"\"\n        Return the result of the stat() system call on this path, like\n        os.stat() does.\n        \"\"\"\n        return self._accessor.stat(self)",
    "source": "pathlib.Path.stat",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.symlink_to: Make this path a symlink pointing to the target path.\nNote the order of arguments (link, target) is the reverse of os.symlink.\n\nCódigo:\n    def symlink_to(self, target, target_is_directory=False):\n        \"\"\"\n        Make this path a symlink pointing to the target path.\n        Note the order of arguments (link, target) is the reverse of os.symlink.\n        \"\"\"\n        self._accessor.symlink(target, self, target_is_directory)",
    "source": "pathlib.Path.symlink_to",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.touch: Create this file with the given access mode, if it doesn't exist.\n\nCódigo:\n    def touch(self, mode=0o666, exist_ok=True):\n        \"\"\"\n        Create this file with the given access mode, if it doesn't exist.\n        \"\"\"\n        if exist_ok:\n            # First try to bump modification time\n            # Implementation note: GNU touch uses the UTIME_NOW option of\n            # the utimensat() / futimens() functions.\n            try:\n                self._accessor.utime(self, None)\n            except OSError:\n                # Avoid exception chaining\n                pass\n            else:\n                return\n        flags = os.O_CREAT | os.O_WRONLY\n        if not exist_ok:\n            flags |= os.O_EXCL\n        fd = self._raw_open(flags, mode)\n        os.close(fd)",
    "source": "pathlib.Path.touch",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.unlink: Remove this file or link.\nIf the path is a directory, use rmdir() instead.\n\nCódigo:\n    def unlink(self, missing_ok=False):\n        \"\"\"\n        Remove this file or link.\n        If the path is a directory, use rmdir() instead.\n        \"\"\"\n        try:\n            self._accessor.unlink(self)\n        except FileNotFoundError:\n            if not missing_ok:\n                raise",
    "source": "pathlib.Path.unlink",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.with_name: Return a new path with the file name changed.\n\nCódigo:\n    def with_name(self, name):\n        \"\"\"Return a new path with the file name changed.\"\"\"\n        if not self.name:\n            raise ValueError(\"%r has an empty name\" % (self,))\n        drv, root, parts = self._flavour.parse_parts((name,))\n        if (not name or name[-1] in [self._flavour.sep, self._flavour.altsep]\n            or drv or root or len(parts) != 1):\n            raise ValueError(\"Invalid name %r\" % (name))\n        return self._from_parsed_parts(self._drv, self._root,\n                                       self._parts[:-1] + [name])",
    "source": "pathlib.Path.with_name",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.with_stem: Return a new path with the stem changed.\n\nCódigo:\n    def with_stem(self, stem):\n        \"\"\"Return a new path with the stem changed.\"\"\"\n        return self.with_name(stem + self.suffix)",
    "source": "pathlib.Path.with_stem",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.with_suffix: Return a new path with the file suffix changed.  If the path\nhas no suffix, add given suffix.  If the given suffix is an empty\nstring, remove the suffix from the path.\n\nCódigo:\n    def with_suffix(self, suffix):\n        \"\"\"Return a new path with the file suffix changed.  If the path\n        has no suffix, add given suffix.  If the given suffix is an empty\n        string, remove the suffix from the path.\n        \"\"\"\n        f = self._flavour\n        if f.sep in suffix or f.altsep and f.altsep in suffix:\n            raise ValueError(\"Invalid suffix %r\" % (suffix,))\n        if suffix and not suffix.startswith('.') or suffix == '.':\n            raise ValueError(\"Invalid suffix %r\" % (suffix))\n        name = self.name\n        if not name:\n            raise ValueError(\"%r has an empty name\" % (self,))\n        old_suffix = self.suffix\n        if not old_suffix:\n            name = name + suffix\n        else:\n            name = name[:-len(old_suffix)] + suffix\n        return self._from_parsed_parts(self._drv, self._root,\n                                       self._parts[:-1] + [name])",
    "source": "pathlib.Path.with_suffix",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.write_bytes: Open the file in bytes mode, write to it, and close the file.\n\nCódigo:\n    def write_bytes(self, data):\n        \"\"\"\n        Open the file in bytes mode, write to it, and close the file.\n        \"\"\"\n        # type-check for the buffer interface before truncating the file\n        view = memoryview(data)\n        with self.open(mode='wb') as f:\n            return f.write(view)",
    "source": "pathlib.Path.write_bytes",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Path.write_text: Open the file in text mode, write to it, and close the file.\n\nCódigo:\n    def write_text(self, data, encoding=None, errors=None):\n        \"\"\"\n        Open the file in text mode, write to it, and close the file.\n        \"\"\"\n        if not isinstance(data, str):\n            raise TypeError('data must be str, not %s' %\n                            data.__class__.__name__)\n        with self.open(mode='w', encoding=encoding, errors=errors) as f:\n            return f.write(data)",
    "source": "pathlib.Path.write_text",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función ecc_decrypt: Descifra un texto cifrado con el método híbrido (ECC + AES).\n\nArgs:\n    ciphertext: Datos cifrados (bytes)\n    private_key_pem: Clave privada ECC en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef ecc_decrypt(ciphertext: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con el método híbrido (ECC + AES).\n    Args:\n        ciphertext: Datos cifrados (bytes)\n        private_key_pem: Clave privada ECC en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    try:\n        # Extraer componentes de los datos cifrados\n        # Estructura: [aes_key(32)][nonce(16)][tag(16)][ciphertext]\n        aes_key = ciphertext[:32]\n        nonce = ciphertext[32:48]\n        tag = ciphertext[48:64]\n        encrypted_data = ciphertext[64:]\n        # Descifrar el mensaje con AES\n        cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)\n        plaintext = cipher_aes.decrypt_and_verify(encrypted_data, tag)\n        return plaintext.decode('utf-8')\n    except Exception as e:\n        raise ValueError(f\"Error en el descifrado ECC: {e}\")",
    "source": "algorithms.asymmetric_encryption.ecc_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función ecc_encrypt: Cifra un texto usando cifrado híbrido con curva elíptica (ECC + AES).\n\nNota: ECC no puede cifrar directamente como RSA. En lugar de eso, se usa un\nenfoque híbrido con AES para el cifrado del mensaje y ECC para el intercambio de claves.\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública ECC en formato PEM\n    \nReturns:\n    Datos cifrados (bytes)\n\nCódigo:\ndef ecc_encrypt(plaintext: str, public_key_pem: str) -> bytes:\n    \"\"\"\n    Cifra un texto usando cifrado híbrido con curva elíptica (ECC + AES).\n    Nota: ECC no puede cifrar directamente como RSA. En lugar de eso, se usa un\n    enfoque híbrido con AES para el cifrado del mensaje y ECC para el intercambio de claves.\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública ECC en formato PEM\n    Returns:\n        Datos cifrados (bytes)\n    \"\"\"\n    try:\n        # Generar una clave AES aleatoria para cifrar el mensaje\n        aes_key = get_random_bytes(32)  # 256 bits\n        # Cifrar el mensaje con AES\n        cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n        ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode('utf-8'))\n        # Estructura: [aes_key][nonce][tag][ciphertext]\n        encrypted_data = aes_key + cipher_aes.nonce + tag + ciphertext\n        return encrypted_data\n    except Exception as e:\n        raise ValueError(f\"Error en el cifrado ECC: {e}\")",
    "source": "algorithms.asymmetric_encryption.ecc_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función ecc_sign_verify_example: Ejemplo de firma digital y verificación con Curvas Elípticas (ECC).\n\nCódigo:\ndef ecc_sign_verify_example():\n    \"\"\"Ejemplo de firma digital y verificación con Curvas Elípticas (ECC).\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO DE FIRMA DIGITAL ECC\")\n    print(\"=\" * 50)\n    # Generar un par de claves ECC\n    private_key = ec.generate_private_key(\n        curve=ec.SECP256R1()\n    )\n    public_key = private_key.public_key()\n    # Mensaje a firmar\n    mensaje = \"Este mensaje se firmará con una clave ECC\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Firma digital con ECC\n    signature = private_key.sign(\n        mensaje.encode('utf-8'),\n        ec.ECDSA(hashes.SHA256())\n    )\n    print(f\"Firma digital ECC (codificada en base64): {base64.b64encode(signature).decode('utf-8')}\")\n    # Verificación de la firma\n    try:\n        public_key.verify(\n            signature,\n            mensaje.encode('utf-8'),\n            ec.ECDSA(hashes.SHA256())\n        )\n        print(\"✅ Verificación exitosa: la firma ECC es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma ECC no es válida\")\n    # Verificar con un mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"\\nIntentando verificar con mensaje alterado: {mensaje_alterado}\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje_alterado.encode('utf-8'),\n            ec.ECDSA(hashes.SHA256())\n        )\n        print(\"✅ Verificación exitosa: la firma ECC es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma ECC no es válida (esperado)\")\n    print()",
    "source": "algorithms.asymmetric_encryption.ecc_sign_verify_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función generate_ecc_keys: Genera un par de claves de Curva Elíptica (ECC).\n\nReturns:\n    Tuple con (clave_publica, clave_privada) en formato PEM\n\nCódigo:\ndef generate_ecc_keys() -> Tuple[str, str]:\n    \"\"\"\n    Genera un par de claves de Curva Elíptica (ECC).\n    Returns:\n        Tuple con (clave_publica, clave_privada) en formato PEM\n    \"\"\"\n    try:\n        # Generar un par de claves ECC usando PyCryptodome\n        key = ECC.generate(curve='P-256')\n        # Obtener las claves en formato PEM\n        private_pem = key.export_key(format='PEM').decode('utf-8')\n        public_pem = key.public_key().export_key(format='PEM').decode('utf-8')\n        return public_pem, private_pem\n    except Exception as e:\n        # Si falla PyCryptodome, intentar con cryptography\n        private_key = ec.generate_private_key(curve=ec.SECP256R1())\n        public_key = private_key.public_key()\n        private_pem = private_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption()\n        ).decode('utf-8')\n        public_pem = public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        ).decode('utf-8')\n        return public_pem, private_pem",
    "source": "algorithms.asymmetric_encryption.generate_ecc_keys",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función generate_rsa_keys: Genera un par de claves RSA en formato PKCS#8 estándar.\n\nArgs:\n    key_size: Tamaño de la clave en bits (2048, 3072, 4096, etc.)\n    \nReturns:\n    Tuple con (clave_publica, clave_privada) en formato PEM\n\nCódigo:\ndef generate_rsa_keys(key_size: int = 2048) -> Tuple[str, str]:\n    \"\"\"\n    Genera un par de claves RSA en formato PKCS#8 estándar.\n    Args:\n        key_size: Tamaño de la clave en bits (2048, 3072, 4096, etc.)\n    Returns:\n        Tuple con (clave_publica, clave_privada) en formato PEM\n    \"\"\"\n    try:\n        # Generar claves con cryptography (formato PKCS#8)\n        private_key = rsa.generate_private_key(\n            public_exponent=65537,\n            key_size=key_size\n        )\n        public_key = private_key.public_key()\n        # Serializar la clave privada en formato PKCS#8\n        private_pem = private_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption()\n        ).decode('utf-8')\n        # Serializar la clave pública en formato SubjectPublicKeyInfo (PKCS#8)\n        public_pem = public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        ).decode('utf-8')\n        return public_pem, private_pem\n    except Exception as cryptography_error:\n        # Fallback: Intentar con PyCryptodome\n        try:\n            key = RSA.generate(key_size)\n            private_pem = key.export_key(format='PEM').decode('utf-8')\n            public_pem = key.publickey().export_key(format='PEM').decode('utf-8')\n            return public_pem, private_pem\n        except Exception as pycrypto_error:\n            # Si ambos fallan, mostrar detalles\n            raise ValueError(f\"Error generando claves RSA. Errores: Cryptography: {cryptography_error}, PyCryptodome: {pycrypto_error}\")",
    "source": "algorithms.asymmetric_encryption.generate_rsa_keys",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔑 EJEMPLOS DE ENCRIPTACIÓN ASIMÉTRICA EN PYTHON 🔑\\n\")\n    rsa_example_with_cryptography()\n    rsa_example_with_pycryptodome()\n    rsa_sign_verify_example()\n    ecc_sign_verify_example()\n    save_keys_to_file()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"La encriptación asimétrica proporciona:\")\n    print(\"- Intercambio seguro de claves\")\n    print(\"- Firma digital para autenticación\")\n    print(\"- Confidencialidad en comunicaciones\")\n    print(\"Sin embargo, es más lenta que la encriptación simétrica\")\n    print(\"por lo que se suele usar en combinación con esta (encriptación híbrida)\")\n    print(\"=\" * 50)",
    "source": "algorithms.asymmetric_encryption.main",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función pad: Apply standard padding.\n\nArgs:\n  data_to_pad (byte string):\n    The data that needs to be padded.\n  block_size (integer):\n    The block boundary to use for padding. The output length is guaranteed\n    to be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n\nReturn:\n  byte string : the original data with the appropriate padding added at the end.\n\nCódigo:\ndef pad(data_to_pad, block_size, style='pkcs7'):\n    \"\"\"Apply standard padding.\n    Args:\n      data_to_pad (byte string):\n        The data that needs to be padded.\n      block_size (integer):\n        The block boundary to use for padding. The output length is guaranteed\n        to be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n      byte string : the original data with the appropriate padding added at the end.\n    \"\"\"\n    padding_len = block_size-len(data_to_pad)%block_size\n    if style == 'pkcs7':\n        padding = bchr(padding_len)*padding_len\n    elif style == 'x923':\n        padding = bchr(0)*(padding_len-1) + bchr(padding_len)\n    elif style == 'iso7816':\n        padding = bchr(128) + bchr(0)*(padding_len-1)\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return data_to_pad + padding",
    "source": "Crypto.Util.Padding.pad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_decrypt: Descifra un texto cifrado con RSA usando múltiples métodos para mayor robustez.\n\nArgs:\n    ciphertext: Datos cifrados (bytes)\n    private_key_pem: Clave privada RSA en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef rsa_decrypt(ciphertext: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con RSA usando múltiples métodos para mayor robustez.\n    Args:\n        ciphertext: Datos cifrados (bytes)\n        private_key_pem: Clave privada RSA en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Si la entrada está vacía, devolver cadena vacía\n    if not ciphertext:\n        return ''\n    # Datos de diagnóstico para depuración\n    ciphertext_info = f\"Longitud del texto cifrado: {len(ciphertext)} bytes\"\n    try:\n        ciphertext_start = ciphertext[:20].hex()\n        ciphertext_info += f\", primeros bytes: {ciphertext_start}\"\n    except:\n        pass\n    print(f\"DEBUG: {ciphertext_info}\")\n    # Lista para almacenar errores\n    errors = []\n    # Intentar sanear la clave\n    try:\n        original_key_length = len(private_key_pem)\n        private_key_pem = sanitize_key(private_key_pem)\n        print(f\"DEBUG: Longitud clave original: {original_key_length}, después de sanitizar: {len(private_key_pem)}\")\n    except Exception as e:\n        errors.append(f\"Error en sanitize_key: {str(e)}\")\n    # Información sobre el formato de la clave\n    key_format = \"Desconocido\"\n    if \"BEGIN PRIVATE KEY\" in private_key_pem:\n        key_format = \"PKCS#8\"\n    elif \"BEGIN RSA PRIVATE KEY\" in private_key_pem:\n        key_format = \"PKCS#1\"\n    elif \"BEGIN EC PRIVATE KEY\" in private_key_pem:\n        key_format = \"EC\"\n    print(f\"DEBUG: Formato de clave detectado: {key_format}\")\n    # Método 1: PKCS1_v1_5 con PyCryptodome\n    try:\n        from Crypto.Cipher import PKCS1_v1_5\n        key = RSA.import_key(private_key_pem)\n        print(f\"DEBUG: Cargada clave RSA con PyCryptodome, tamaño: {key.size_in_bits()} bits\")\n        sentinel = get_random_bytes(16)  # Valor aleatorio para indicar descifrado fallido\n        cipher = PKCS1_v1_5.new(key)\n        decrypted = cipher.decrypt(ciphertext, sentinel)\n        if decrypted == sentinel:\n            raise ValueError(\"Descifrado PKCS1_v1_5 fallido\")\n        print(\"DEBUG: Descifrado exitoso con PKCS1_v1_5\")\n        return decrypted.decode('utf-8')\n    except Exception as e1:\n        errors.append(f\"Error con PKCS1_v1_5: {str(e1)}\")\n        print(f\"DEBUG: Fallo PKCS1_v1_5: {str(e1)}\")\n    # Método 2: PKCS1_OAEP con PyCryptodome\n    try:\n        key = RSA.import_key(private_key_pem)\n        print(f\"DEBUG: Intento con PKCS1_OAEP, tamaño clave: {key.size_in_bits()} bits\")\n        cipher = PKCS1_OAEP.new(key)\n        decrypted = cipher.decrypt(ciphertext)\n        print(\"DEBUG: Descifrado exitoso con PKCS1_OAEP\")\n        return decrypted.decode('utf-8')\n    except Exception as e2:\n        errors.append(f\"Error con PKCS1_OAEP: {str(e2)}\")\n        print(f\"DEBUG: Fallo PKCS1_OAEP: {str(e2)}\")\n    # Método 3: Intentar convertir formato de clave PKCS#8 a PKCS#1\n    try:\n        print(\"DEBUG: Intentando convertir formato de clave PKCS#8 a PKCS#1\")\n        # Convertir formato de PKCS#8 a PKCS#1 explícitamente\n        modified_key = private_key_pem.replace(\"-----BEGIN PRIVATE KEY-----\", \n                                            \"-----BEGIN RSA PRIVATE KEY-----\")\n        modified_key = modified_key.replace(\"-----END PRIVATE KEY-----\", \n                                          \"-----END RSA PRIVATE KEY-----\")\n        # Probar con PKCS1_v1_5\n        key = RSA.import_key(modified_key)\n        cipher = PKCS1_v1_5.new(key)\n        sentinel = get_random_bytes(16)\n        decrypted = cipher.decrypt(ciphertext, sentinel)\n        if decrypted == sentinel:\n            raise ValueError(\"Descifrado con clave modificada fallido\")\n        print(\"DEBUG: Descifrado exitoso con clave modificada\")\n        return decrypted.decode('utf-8')\n    except Exception as e3:\n        errors.append(f\"Error con clave modificada: {str(e3)}\")\n        print(f\"DEBUG: Fallo con clave modificada: {str(e3)}\")\n    # Método 4: cryptography directamente\n    try:\n        from cryptography.hazmat.primitives.asymmetric import padding\n        from cryptography.hazmat.primitives import serialization\n        print(\"DEBUG: Intentando descifrar con cryptography\")\n        # Intentar cargar la clave privada en diferentes formatos\n        try:\n            private_key = serialization.load_pem_private_key(\n                private_key_pem.encode('utf-8'),\n                password=None\n            )\n            print(\"DEBUG: Cargada clave con cryptography en formato estándar\")\n        except Exception as load_error:\n            print(f\"DEBUG: Error cargando clave estándar: {str(load_error)}\")\n            # Intentar con transformación adicional si es formato no estándar\n            modified_key = private_key_pem\n            if \"-----BEGIN RSA PRIVATE KEY-----\" in private_key_pem:\n                modified_key = private_key_pem.replace(\"-----BEGIN RSA PRIVATE KEY-----\", \n                                                     \"-----BEGIN PRIVATE KEY-----\")\n                modified_key = modified_key.replace(\"-----END RSA PRIVATE KEY-----\", \n                                                  \"-----END PRIVATE KEY-----\")\n            private_key = serialization.load_pem_private_key(\n                modified_key.encode('utf-8'), \n                password=None\n            )\n            print(\"DEBUG: Cargada clave con cryptography en formato modificado\")\n        # Descifrar con OAEP\n        decrypted = private_key.decrypt(\n            ciphertext,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None\n            )\n        )\n        print(\"DEBUG: Descifrado exitoso con cryptography\")\n        return decrypted.decode('utf-8')\n    except Exception as e4:\n        errors.append(f\"Error con cryptography: {str(e4)}\")\n        print(f\"DEBUG: Fallo con cryptography: {str(e4)}\")\n    # Método 5: Último intento con PKCS1_v1_5 sin padding\n    try:\n        print(\"DEBUG: Intentando descifrar con PKCS1_v1_5 sin padding explícito\")\n        from Crypto.Cipher import PKCS1_v1_5\n        key = RSA.import_key(private_key_pem)\n        # Intento para casos donde el padding puede estar mal\n        # Calcular tamaño del bloque RSA\n        key_size_bytes = key.size_in_bytes()\n        print(f\"DEBUG: Tamaño de clave en bytes: {key_size_bytes}\")\n        # Verificar si el ciphertext tiene el tamaño adecuado\n        if len(ciphertext) != key_size_bytes:\n            print(f\"DEBUG: Advertencia - El texto cifrado ({len(ciphertext)} bytes) no tiene el tamaño esperado del bloque RSA ({key_size_bytes} bytes)\")\n        # Intentar descifrado directo con PKCS1_v1_5\n        cipher = PKCS1_v1_5.new(key)\n        sentinel = None  # Sin valor centinela para este intento\n        decrypted = cipher.decrypt(ciphertext, sentinel)\n        if not decrypted:\n            raise ValueError(\"Descifrado sin padding fallido\")\n        print(\"DEBUG: Descifrado exitoso con PKCS1_v1_5 sin padding\")\n        return decrypted.decode('utf-8', errors='replace')  # Usar replace para manejar posibles errores de codificación\n    except Exception as e5:\n        errors.append(f\"Error con PKCS1_v1_5 sin padding: {str(e5)}\")\n        print(f\"DEBUG: Fallo PKCS1_v1_5 sin padding: {str(e5)}\")\n    # Si todos los métodos fallan, intentar determinar si el problema es la clave o el ciphertext\n    diagnostic = \"Diagnóstico adicional:\\n\"\n    # Comprobar si la clave privada se puede cargar correctamente\n    try:\n        key = RSA.import_key(private_key_pem)\n        diagnostic += f\"- La clave privada parece ser válida (RSA {key.size_in_bits()} bits)\\n\"\n    except Exception as key_error:\n        diagnostic += f\"- La clave privada no se pudo cargar: {str(key_error)}\\n\"\n    # Comprobar si el ciphertext parece válido\n    if len(ciphertext) < 64:\n        diagnostic += f\"- El texto cifrado es muy corto ({len(ciphertext)} bytes) para ser un mensaje cifrado con RSA\\n\"\n    # Sugerir posibles problemas\n    diagnostic += \"- Posibles causas del error:\\n\"\n    diagnostic += \"  * La clave privada no corresponde con la clave pública usada para cifrar\\n\"\n    diagnostic += \"  * El texto cifrado ha sido modificado o corrupto\\n\"\n    diagnostic += \"  * Se está utilizando un algoritmo de padding diferente al usado en el cifrado\\n\"\n    # Si todos los métodos fallan, lanzar una excepción detallada con diagnóstico\n    error_msg = f\"No se pudo descifrar con RSA. {diagnostic}\\nErrores detallados: {', '.join(errors)}\"\n    print(f\"DEBUG: Error final: {error_msg}\")\n    raise ValueError(error_msg)",
    "source": "algorithms.asymmetric_encryption.rsa_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_encrypt: Cifra un texto usando RSA con múltiples intentos para mayor robustez.\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública RSA en formato PEM\n    \nReturns:\n    Datos cifrados (bytes)\n\nCódigo:\ndef rsa_encrypt(plaintext: str, public_key_pem: str) -> bytes:\n    \"\"\"\n    Cifra un texto usando RSA con múltiples intentos para mayor robustez.\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública RSA en formato PEM\n    Returns:\n        Datos cifrados (bytes)\n    \"\"\"\n    # Si la entrada está vacía, devolver bytes vacíos\n    if not plaintext:\n        return b''\n    # Asegurar que el texto sea bytes\n    if isinstance(plaintext, str):\n        plaintext_bytes = plaintext.encode('utf-8')\n    else:\n        plaintext_bytes = plaintext\n    # Lista para almacenar errores\n    errors = []\n    # Intentar sanear la clave\n    try:\n        public_key_pem = sanitize_key(public_key_pem)\n    except Exception as e:\n        errors.append(f\"Error en sanitize_key: {str(e)}\")\n    # Método 1: PKCS1_v1_5 con PyCryptodome\n    try:\n        from Crypto.Cipher import PKCS1_v1_5\n        key = RSA.import_key(public_key_pem)\n        cipher = PKCS1_v1_5.new(key)\n        return cipher.encrypt(plaintext_bytes)\n    except Exception as e1:\n        errors.append(f\"Error con PKCS1_v1_5: {str(e1)}\")\n    # Método 2: PKCS1_OAEP con PyCryptodome\n    try:\n        key = RSA.import_key(public_key_pem)\n        cipher = PKCS1_OAEP.new(key)\n        return cipher.encrypt(plaintext_bytes)\n    except Exception as e2:\n        errors.append(f\"Error con PKCS1_OAEP: {str(e2)}\")\n    # Método 3: cryptography directamente\n    try:\n        from cryptography.hazmat.primitives.asymmetric import padding\n        from cryptography.hazmat.primitives import serialization\n        # Intentar cargar la clave en diferentes formatos\n        try:\n            public_key = serialization.load_pem_public_key(public_key_pem.encode('utf-8'))\n        except Exception:\n            # Intentar con una transformación adicional por si es un formato no estándar\n            modified_pem = public_key_pem.replace(\"-----BEGIN RSA PUBLIC KEY-----\", \n                                                \"-----BEGIN PUBLIC KEY-----\")\n            modified_pem = modified_pem.replace(\"-----END RSA PUBLIC KEY-----\", \n                                              \"-----END PUBLIC KEY-----\")\n            public_key = serialization.load_pem_public_key(modified_pem.encode('utf-8'))\n        encrypted = public_key.encrypt(\n            plaintext_bytes,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None\n            )\n        )\n        return encrypted\n    except Exception as e3:\n        errors.append(f\"Error con cryptography: {str(e3)}\")\n    # Si todos los métodos fallan, lanzar una excepción detallada\n    raise ValueError(f\"No se pudo cifrar con RSA. Errores: {', '.join(errors)}\")",
    "source": "algorithms.asymmetric_encryption.rsa_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_example_with_cryptography: Ejemplo de encriptación RSA utilizando la biblioteca cryptography.\n\nCódigo:\ndef rsa_example_with_cryptography():\n    \"\"\"Ejemplo de encriptación RSA utilizando la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO RSA CON CRYPTOGRAPHY\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048\n    )\n    public_key = private_key.public_key()\n    # Mensaje a encriptar\n    mensaje = \"Este es un mensaje secreto encriptado con RSA\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Encriptar el mensaje con la clave pública\n    ciphertext = public_key.encrypt(\n        mensaje.encode('utf-8'),\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    print(f\"Mensaje encriptado (codificado en base64): {base64.b64encode(ciphertext).decode('utf-8')}\")\n    # Desencriptar el mensaje con la clave privada\n    plaintext = private_key.decrypt(\n        ciphertext,\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print()",
    "source": "algorithms.asymmetric_encryption.rsa_example_with_cryptography",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_example_with_pycryptodome: Ejemplo de encriptación RSA utilizando la biblioteca PyCryptodome.\n\nCódigo:\ndef rsa_example_with_pycryptodome():\n    \"\"\"Ejemplo de encriptación RSA utilizando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO RSA CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    # Mensaje a encriptar\n    mensaje = \"Este es un mensaje secreto encriptado con RSA (PyCryptodome)\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Crear un objeto de cifrado PKCS#1 OAEP\n    cipher_rsa = PKCS1_OAEP.new(public_key)\n    # Encriptar el mensaje\n    ciphertext = cipher_rsa.encrypt(mensaje.encode('utf-8'))\n    print(f\"Mensaje encriptado (codificado en base64): {base64.b64encode(ciphertext).decode('utf-8')}\")\n    # Desencriptar el mensaje\n    cipher_rsa = PKCS1_OAEP.new(private_key)\n    plaintext = cipher_rsa.decrypt(ciphertext)\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print()",
    "source": "algorithms.asymmetric_encryption.rsa_example_with_pycryptodome",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_sign_verify_example: Ejemplo de firma digital y verificación con RSA.\n\nCódigo:\ndef rsa_sign_verify_example():\n    \"\"\"Ejemplo de firma digital y verificación con RSA.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO DE FIRMA DIGITAL RSA\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048\n    )\n    public_key = private_key.public_key()\n    # Mensaje a firmar\n    mensaje = \"Este mensaje necesita ser autenticado con una firma digital\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Firma digital: se firma el hash del mensaje con la clave privada\n    signature = private_key.sign(\n        mensaje.encode('utf-8'),\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    print(f\"Firma digital (codificada en base64): {base64.b64encode(signature).decode('utf-8')}\")\n    # Verificación: se verifica la firma con la clave pública\n    try:\n        public_key.verify(\n            signature,\n            mensaje.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✅ Verificación exitosa: la firma es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma no es válida\")\n    # Verificar con un mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"\\nIntentando verificar con mensaje alterado: {mensaje_alterado}\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje_alterado.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✅ Verificación exitosa: la firma es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma no es válida (esperado, ya que el mensaje fue alterado)\")\n    print()",
    "source": "algorithms.asymmetric_encryption.rsa_sign_verify_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función sanitize_key: Sanitiza una clave para asegurar que esté en formato PEM adecuado.\nManeja múltiples formatos de entrada y corrige problemas comunes.\n\nArgs:\n    key (str): La clave en formato PEM o similar\n\nReturns:\n    str: La clave sanitizada en formato PEM\n\nCódigo:\ndef sanitize_key(key):\n    \"\"\"\n    Sanitiza una clave para asegurar que esté en formato PEM adecuado.\n    Maneja múltiples formatos de entrada y corrige problemas comunes.\n    Args:\n        key (str): La clave en formato PEM o similar\n    Returns:\n        str: La clave sanitizada en formato PEM\n    \"\"\"\n    if not key:\n        return key\n    # Eliminar espacios, tabulaciones y saltos de línea extra\n    key = key.strip()\n    # Si la clave no tiene BEGIN/END, puede que sea solo el cuerpo de la clave\n    if \"BEGIN\" not in key and \"END\" not in key:\n        # Intenta determinar el tipo de clave basado en el contenido\n        is_private = False\n        # Eliminar caracteres no válidos en Base64\n        key = re.sub(r'[^A-Za-z0-9+/=]', '', key)\n        # Intenta decodificar para ver si es una clave privada RSA\n        try:\n            key_bytes = base64.b64decode(key)\n            # Esto es específico para RSA - verificando si parece una clave privada\n            if b'\\x02\\x01\\x00' in key_bytes:\n                is_private = True\n        except:\n            pass  # Ignoramos errores en este intento de detección\n        # Envolver en etiquetas PEM adecuadas\n        if is_private:\n            key = f\"-----BEGIN RSA PRIVATE KEY-----\\n{key}\\n-----END RSA PRIVATE KEY-----\"\n        else:\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{key}\\n-----END PUBLIC KEY-----\"\n    # Normalizar los saltos de línea\n    key = key.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    # Asegurar que las etiquetas BEGIN/END están en líneas separadas\n    key = re.sub(r'(-----BEGIN [^-]+-----)([^\\n])', r'\\1\\n\\2', key)\n    key = re.sub(r'([^\\n])(-----END [^-]+-----)', r'\\1\\n\\2', key)\n    # Formatear correctamente el cuerpo de la clave en bloques de 64 caracteres\n    lines = key.split('\\n')\n    header = None\n    footer = None\n    body_lines = []\n    for i, line in enumerate(lines):\n        if \"BEGIN\" in line:\n            header = line\n        elif \"END\" in line:\n            footer = line\n        elif line.strip():  # Si no es una línea vacía y no es header/footer\n            body_lines.append(line)\n    if header and footer:\n        # Unir todas las líneas del cuerpo y eliminar espacios/caracteres no Base64\n        body = ''.join(body_lines)\n        body = re.sub(r'[^A-Za-z0-9+/=]', '', body)\n        # Reformatear en líneas de 64 caracteres\n        formatted_body = '\\n'.join([body[i:i+64] for i in range(0, len(body), 64)])\n        key = f\"{header}\\n{formatted_body}\\n{footer}\"\n    # Correcciones específicas para problemas conocidos\n    # Problema: Claves PKCS#8 etiquetadas incorrectamente como RSA PRIVATE KEY\n    if \"BEGIN RSA PRIVATE KEY\" in key and \"PRIVATE KEY\" in key:\n        try:\n            # Intentar cargar como PKCS#1\n            key_obj = RSA.import_key(key)\n            # Si llegamos aquí, la clave ya está en formato PKCS#1, no hacemos nada\n        except:\n            # Puede que sea una clave PKCS#8 con etiqueta incorrecta\n            try:\n                # Convertir etiquetas a PKCS#8\n                key = key.replace(\"BEGIN RSA PRIVATE KEY\", \"BEGIN PRIVATE KEY\")\n                key = key.replace(\"END RSA PRIVATE KEY\", \"END PRIVATE KEY\")\n                # Intentar cargar para verificar\n                from cryptography.hazmat.primitives.serialization import load_pem_private_key\n                load_pem_private_key(key.encode(), password=None)\n            except:\n                # Revertir si no funciona\n                key = key.replace(\"BEGIN PRIVATE KEY\", \"BEGIN RSA PRIVATE KEY\")\n                key = key.replace(\"END PRIVATE KEY\", \"END RSA PRIVATE KEY\")\n    return key",
    "source": "algorithms.asymmetric_encryption.sanitize_key",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función save_keys_to_file: Ejemplo de cómo guardar y cargar claves RSA y ECC en archivos.\n\nCódigo:\ndef save_keys_to_file():\n    \"\"\"Ejemplo de cómo guardar y cargar claves RSA y ECC en archivos.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO DE GUARDAR Y CARGAR CLAVES\")\n    print(\"=\" * 50)\n    # Crear directorio para claves si no existe\n    key_dir = Path(\"keys\")\n    key_dir.mkdir(exist_ok=True)\n    # RSA: Generar y guardar claves\n    print(\"Generando y guardando claves RSA...\")\n    private_key_rsa = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048\n    )\n    public_key_rsa = private_key_rsa.public_key()\n    # Serializar y guardar clave privada RSA\n    with open(key_dir / \"rsa_private.pem\", \"wb\") as f:\n        f.write(private_key_rsa.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption()\n        ))\n    # Serializar y guardar clave pública RSA\n    with open(key_dir / \"rsa_public.pem\", \"wb\") as f:\n        f.write(public_key_rsa.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        ))\n    # ECC: Generar y guardar claves\n    print(\"Generando y guardando claves ECC...\")\n    private_key_ecc = ec.generate_private_key(\n        curve=ec.SECP256R1()\n    )\n    public_key_ecc = private_key_ecc.public_key()\n    # Serializar y guardar clave privada ECC\n    with open(key_dir / \"ecc_private.pem\", \"wb\") as f:\n        f.write(private_key_ecc.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption()\n        ))\n    # Serializar y guardar clave pública ECC\n    with open(key_dir / \"ecc_public.pem\", \"wb\") as f:\n        f.write(public_key_ecc.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        ))\n    print(\"Claves guardadas en el directorio 'keys'\")\n    # Cargar claves y probar encriptación\n    print(\"\\nCargando claves y probando encriptación...\")\n    # Cargar clave privada RSA\n    with open(key_dir / \"rsa_private.pem\", \"rb\") as f:\n        loaded_private_key_rsa = serialization.load_pem_private_key(\n            f.read(),\n            password=None\n        )\n    # Cargar clave pública RSA\n    with open(key_dir / \"rsa_public.pem\", \"rb\") as f:\n        loaded_public_key_rsa = serialization.load_pem_public_key(\n            f.read()\n        )\n    # Probar encriptación y desencriptación con las claves cargadas\n    mensaje = \"Prueba de encriptación con claves cargadas desde archivos\"\n    ciphertext = loaded_public_key_rsa.encrypt(\n        mensaje.encode('utf-8'),\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    plaintext = loaded_private_key_rsa.decrypt(\n        ciphertext,\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    print(f\"RSA - Mensaje original: {mensaje}\")\n    print(f\"RSA - Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    # Limpiar: eliminar los archivos de claves creados\n    for key_file in key_dir.glob(\"*.pem\"):\n        key_file.unlink()\n    key_dir.rmdir()\n    print(\"\\nArchivos de claves eliminados\")\n    print()",
    "source": "algorithms.asymmetric_encryption.save_keys_to_file",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función unpad: Remove standard padding.\n\nArgs:\n  padded_data (byte string):\n    A piece of data with padding that needs to be stripped.\n  block_size (integer):\n    The block boundary to use for padding. The input length\n    must be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\nReturn:\n    byte string : data without padding.\nRaises:\n  ValueError: if the padding is incorrect.\n\nCódigo:\ndef unpad(padded_data, block_size, style='pkcs7'):\n    \"\"\"Remove standard padding.\n    Args:\n      padded_data (byte string):\n        A piece of data with padding that needs to be stripped.\n      block_size (integer):\n        The block boundary to use for padding. The input length\n        must be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n        byte string : data without padding.\n    Raises:\n      ValueError: if the padding is incorrect.\n    \"\"\"\n    pdata_len = len(padded_data)\n    if pdata_len == 0:\n        raise ValueError(\"Zero-length input cannot be unpadded\")\n    if pdata_len % block_size:\n        raise ValueError(\"Input data is not padded\")\n    if style in ('pkcs7', 'x923'):\n        padding_len = bord(padded_data[-1])\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if style == 'pkcs7':\n            if padded_data[-padding_len:]!=bchr(padding_len)*padding_len:\n                raise ValueError(\"PKCS#7 padding is incorrect.\")\n        else:\n            if padded_data[-padding_len:-1]!=bchr(0)*(padding_len-1):\n                raise ValueError(\"ANSI X.923 padding is incorrect.\")\n    elif style == 'iso7816':\n        padding_len = pdata_len - padded_data.rfind(bchr(128))\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if padding_len>1 and padded_data[1-padding_len:]!=bchr(0)*(padding_len-1):\n            raise ValueError(\"ISO 7816-4 padding is incorrect.\")\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return padded_data[:-padding_len]",
    "source": "Crypto.Util.Padding.unpad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función basic_hybrid_encryption: Ejemplo básico de encriptación híbrida (RSA + AES).\n\nCódigo:\ndef basic_hybrid_encryption():\n    \"\"\"Ejemplo básico de encriptación híbrida (RSA + AES).\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN HÍBRIDA BÁSICA (RSA + AES)\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar (puede ser de cualquier tamaño)\n    mensaje = \"\"\"Este es un mensaje largo que demuestra las ventajas de la encriptación híbrida.\nLa encriptación híbrida combina la eficiencia de la encriptación simétrica (AES)\ncon la seguridad del intercambio de claves asimétrico (RSA).\nEste enfoque nos permite encriptar mensajes de cualquier tamaño de manera eficiente\nmientras mantenemos la seguridad que proporciona la criptografía de clave pública.\"\"\"\n    print(f\"Mensaje original ({len(mensaje.encode('utf-8'))} bytes):\")\n    print(mensaje)\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 1: Generar un par de claves RSA (receptor)\")\n    # Generar un par de claves RSA (normalmente, el receptor haría esto)\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    print(f\"Par de claves RSA generado (2048 bits)\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 2: Generar una clave simétrica AES aleatoria (emisor)\")\n    # Generar una clave simétrica aleatoria para AES (el emisor hace esto)\n    aes_key = get_random_bytes(32)  # 256 bits\n    print(f\"Clave AES generada: {base64.b64encode(aes_key).decode()}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 3: Encriptar el mensaje con AES (emisor)\")\n    # Encriptar el mensaje con AES (el emisor hace esto)\n    cipher_aes = AES.new(aes_key, AES.MODE_CBC)\n    iv = cipher_aes.iv\n    mensaje_bytes = mensaje.encode('utf-8')\n    ciphertext = cipher_aes.encrypt(pad(mensaje_bytes, AES.block_size))\n    print(f\"IV: {base64.b64encode(iv).decode()}\")\n    print(f\"Mensaje encriptado con AES: {base64.b64encode(ciphertext).decode()[:50]}...\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 4: Encriptar la clave AES con RSA (emisor)\")\n    # Encriptar la clave AES con la clave pública RSA (el emisor hace esto)\n    cipher_rsa = PKCS1_OAEP.new(public_key)\n    encrypted_aes_key = cipher_rsa.encrypt(aes_key)\n    print(f\"Clave AES encriptada con RSA: {base64.b64encode(encrypted_aes_key).decode()[:50]}...\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 5: Enviar al receptor: clave AES encriptada, IV y mensaje encriptado\")\n    # En un escenario real, el emisor enviaría estos tres elementos al receptor:\n    # 1. encrypted_aes_key (clave AES encriptada con RSA)\n    # 2. iv (vector de inicialización para AES)\n    # 3. ciphertext (mensaje encriptado con AES)\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 6: Desencriptar la clave AES con RSA (receptor)\")\n    # Desencriptar la clave AES con la clave privada RSA (el receptor hace esto)\n    cipher_rsa = PKCS1_OAEP.new(private_key)\n    decrypted_aes_key = cipher_rsa.decrypt(encrypted_aes_key)\n    print(f\"Clave AES desencriptada: {base64.b64encode(decrypted_aes_key).decode()}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 7: Desencriptar el mensaje con AES (receptor)\")\n    # Desencriptar el mensaje con la clave AES (el receptor hace esto)\n    cipher_aes = AES.new(decrypted_aes_key, AES.MODE_CBC, iv)\n    padded_plaintext = cipher_aes.decrypt(ciphertext)\n    plaintext = unpad(padded_plaintext, AES.block_size)\n    print(f\"Mensaje desencriptado ({len(plaintext)} bytes):\")\n    print(plaintext.decode('utf-8'))\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.basic_hybrid_encryption",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función caos_v3_decrypt: Desencripta texto previamente encriptado con caos_v3_encrypt.\n\nArgs:\n    encrypted_text: Texto encriptado en formato Base64\n    password: Contraseña para desencriptación\n    rounds: Número de rondas de encriptación\n    \nReturns:\n    Texto desencriptado\n\nCódigo:\ndef caos_v3_decrypt(encrypted_text: str, password: str, rounds: int = DEFAULT_ROUNDS) -> str:\n    \"\"\"\n    Desencripta texto previamente encriptado con caos_v3_encrypt.\n    Args:\n        encrypted_text: Texto encriptado en formato Base64\n        password: Contraseña para desencriptación\n        rounds: Número de rondas de encriptación\n    Returns:\n        Texto desencriptado\n    \"\"\"\n    import base64\n    # Decodificar de base64\n    encrypted_bytes = base64.b64decode(encrypted_text)\n    # Crear instancia de encriptación\n    cipher = CaosEncryption(password, rounds)\n    # Desencriptar\n    decrypted = cipher.decrypt(encrypted_bytes)\n    # Convertir a string\n    try:\n        return decrypted.decode('utf-8')\n    except UnicodeDecodeError:\n        # Si no se puede decodificar como UTF-8, devolver los bytes en base64\n        return base64.b64encode(decrypted).decode('utf-8')",
    "source": "algorithms.custom_encryption.caos_v3_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función caos_v3_encrypt: Encripta texto usando CAOS v3.0.\n\nArgs:\n    text: Texto a encriptar (str o bytes)\n    password: Contraseña para encriptación\n    rounds: Número de rondas de encriptación\n    \nReturns:\n    Texto encriptado en formato Base64\n\nCódigo:\ndef caos_v3_encrypt(text: Union[str, bytes], password: str, rounds: int = DEFAULT_ROUNDS) -> str:\n    \"\"\"\n    Encripta texto usando CAOS v3.0.\n    Args:\n        text: Texto a encriptar (str o bytes)\n        password: Contraseña para encriptación\n        rounds: Número de rondas de encriptación\n    Returns:\n        Texto encriptado en formato Base64\n    \"\"\"\n    import base64\n    # Convertir texto a bytes si es necesario\n    if isinstance(text, str):\n        text_bytes = text.encode('utf-8')\n    else:\n        text_bytes = text\n    # Crear instancia de encriptación\n    cipher = CaosEncryption(password, rounds)\n    # Encriptar y codificar en base64\n    encrypted = cipher.encrypt(text_bytes)\n    return base64.b64encode(encrypted).decode('utf-8')",
    "source": "algorithms.custom_encryption.caos_v3_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Módulo algorithms.caos_v4: CAOS v4.1 - Versión mejorada con optimizaciones de rendimiento y seguridad.\n\nMejoras principales:\n- Procesamiento paralelo para operaciones intensivas\n- Caché optimizado de claves derivadas\n- Protección contra ataques de tiempo\n- Uso de instrucciones AES-NI cuando disponibles\n- Sistema de iteraciones adaptativas",
    "source": "algorithms.caos_v4",
    "type": "module",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método AESGCM.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(self, key: bytes):\n        utils._check_byteslike(\"key\", key)\n        if len(key) not in (16, 24, 32):\n            raise ValueError(\"AESGCM key must be 128, 192, or 256 bits.\")\n        self._key = key",
    "source": "cryptography.hazmat.primitives.ciphers.aead.AESGCM.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase CaosEncryption: CAOS v4.1 - Cifrado optimizado con AES-GCM y PBKDF2.",
    "source": "algorithms.caos_v4.CaosEncryption",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.__init__: Inicializa el cifrador con parámetros optimizados.\n\nArgs:\n    password: Contraseña para derivación de clave\n    iterations: Número de iteraciones PBKDF2 (si None, se calcula automáticamente)\n    key_size: Tamaño de clave en bytes (32 = 256 bits)\n    use_parallel: Usar procesamiento paralelo para operaciones intensivas\n\nCódigo:\n    def __init__(\n        self,\n        password: str,\n        iterations: Optional[int] = None,\n        key_size: int = 32,\n        use_parallel: bool = True\n    ):\n        \"\"\"\n        Inicializa el cifrador con parámetros optimizados.\n        Args:\n            password: Contraseña para derivación de clave\n            iterations: Número de iteraciones PBKDF2 (si None, se calcula automáticamente)\n            key_size: Tamaño de clave en bytes (32 = 256 bits)\n            use_parallel: Usar procesamiento paralelo para operaciones intensivas\n        \"\"\"\n        self.password = password.encode(\"utf-8\") if isinstance(password, str) else password\n        self.key_size = key_size\n        self.use_parallel = use_parallel\n        self.backend = default_backend()\n        # Calcular iteraciones óptimas si no se especifican\n        if iterations is None:\n            self.iterations = self._calculate_optimal_iterations()\n        else:\n            self.iterations = max(MIN_ITERATIONS, min(iterations, MAX_ITERATIONS))\n        # Inicializar caché de claves\n        self._key_cache = {}\n        self._cache_lock = threading.Lock()",
    "source": "algorithms.caos_v4.CaosEncryption.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.decrypt: Desencripta datos con verificación de integridad mejorada y manejo de errores más claro.\nSoporta tanto datos binarios como strings en Base64.\n\nCódigo:\n    def decrypt(self, encrypted_data: Union[bytes, str]) -> bytes:\n        \"\"\"\n        Desencripta datos con verificación de integridad mejorada y manejo de errores más claro.\n        Soporta tanto datos binarios como strings en Base64.\n        \"\"\"\n        try:\n            # Si el input es un string, asumimos que es Base64\n            if isinstance(encrypted_data, str):\n                try:\n                    encrypted_data = base64.b64decode(encrypted_data)\n                except Exception as e:\n                    raise ValueError(\n                        \"Error al decodificar Base64. \"\n                        \"Asegúrate de que el mensaje encriptado esté en formato Base64 válido.\"\n                    ) from e\n            # Verificación de longitud mínima\n            min_length = 16 + 12 + 16  # salt + nonce + tag mínimo\n            if len(encrypted_data) < min_length:\n                raise ValueError(\n                    f\"Los datos encriptados son demasiado cortos ({len(encrypted_data)} bytes). \"\n                    f\"Se requieren al menos {min_length} bytes para un mensaje válido.\"\n                )\n            # Extraer componentes\n            salt = encrypted_data[:16]\n            nonce = encrypted_data[16:28]\n            ciphertext = encrypted_data[28:]\n            # Derivar clave de manera segura\n            try:\n                key = self._derive_key(salt)\n            except Exception as e:\n                raise ValueError(\n                    \"Error al derivar la clave. \"\n                    \"Esto puede deberse a un problema con la contraseña o el salt.\"\n                ) from e\n            # Procesar datos (en paralelo si es posible)\n            try:\n                plaintext = self._parallel_process(ciphertext, key, nonce, False)\n            except Exception as e:\n                raise ValueError(\n                    \"Error al procesar los datos cifrados. \"\n                    \"La contraseña podría ser incorrecta o los datos podrían estar corruptos.\"\n                ) from e\n            # Verificar que tenemos suficientes datos para el checksum\n            if len(plaintext) < 16:\n                raise ValueError(\n                    \"Los datos desencriptados son demasiado cortos para contener un checksum válido.\"\n                )\n            # Extraer checksum y datos\n            stored_checksum = plaintext[:16]\n            actual_data = plaintext[16:]\n            # Calcular checksum actual\n            current_checksum = self._calculate_checksum(actual_data)\n            # Verificación de integridad constante en tiempo\n            if not bytes_eq(stored_checksum, current_checksum):\n                # Proporcionar más información de diagnóstico\n                raise ValueError(\n                    \"La verificación de integridad falló. \"\n                    f\"Checksum almacenado: {stored_checksum.hex()}, \"\n                    f\"Checksum calculado: {current_checksum.hex()}. \"\n                    \"Esto puede deberse a: \"\n                    \"1) Contraseña incorrecta \"\n                    \"2) Datos modificados o corruptos \"\n                    \"3) Mensaje encriptado con una versión diferente del algoritmo\"\n                )\n            return actual_data\n        except ValueError as ve:\n            # Re-lanzar los errores de validación con mensajes más descriptivos\n            raise ve\n        except Exception as e:\n            # Capturar cualquier otro error y proporcionar un mensaje más útil\n            raise ValueError(\n                f\"Error al desencriptar: {str(e)}. \"\n                \"Por favor, verifica que: \"\n                \"1) La contraseña es correcta \"\n                \"2) El mensaje fue encriptado con CAOS V4 \"\n                \"3) El mensaje no ha sido modificado\"\n            ) from e",
    "source": "algorithms.caos_v4.CaosEncryption.decrypt",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.decrypt_file: Desencripta archivo con verificación de integridad.\n\nCódigo:\n    def decrypt_file(self, input_path: str, output_path: str) -> None:\n        \"\"\"Desencripta archivo con verificación de integridad.\"\"\"\n        with open(input_path, \"rb\") as infile:\n            encrypted_data = infile.read()\n        decrypted_data = self.decrypt(encrypted_data)\n        with open(output_path, \"wb\") as outfile:\n            outfile.write(decrypted_data)",
    "source": "algorithms.caos_v4.CaosEncryption.decrypt_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.encrypt: Encripta datos con optimizaciones de rendimiento y seguridad.\n\nCódigo:\n    def encrypt(self, data: bytes) -> bytes:\n        \"\"\"\n        Encripta datos con optimizaciones de rendimiento y seguridad.\n        \"\"\"\n        # Generar sal y nonce\n        salt = os.urandom(16)\n        nonce = os.urandom(12)\n        # Derivar clave de manera segura\n        key = self._derive_key(salt)\n        # Calcular checksum antes de encriptar\n        checksum = self._calculate_checksum(data)\n        # Procesar datos (en paralelo si es posible)\n        ciphertext = self._parallel_process(checksum + data, key, nonce, True)\n        # Retornar con estructura optimizada\n        return salt + nonce + ciphertext",
    "source": "algorithms.caos_v4.CaosEncryption.encrypt",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.encrypt_file: Encripta archivo con procesamiento por chunks.\n\nCódigo:\n    def encrypt_file(self, input_path: str, output_path: str) -> None:\n        \"\"\"Encripta archivo con procesamiento por chunks.\"\"\"\n        with open(input_path, \"rb\") as infile:\n            data = infile.read()\n        encrypted_data = self.encrypt(data)\n        with open(output_path, \"wb\") as outfile:\n            outfile.write(encrypted_data)",
    "source": "algorithms.caos_v4.CaosEncryption.encrypt_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método PBKDF2HMAC.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes,\n        iterations: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n        if not ossl.pbkdf2_hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                \"{} is not supported for PBKDF2 by this backend.\".format(\n                    algorithm.name\n                ),\n                _Reasons.UNSUPPORTED_HASH,\n            )\n        self._used = False\n        self._algorithm = algorithm\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        self._salt = salt\n        self._iterations = iterations",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método PBKDF2HMAC.derive: Deterministically generates and returns a new key based on the existing\nkey material.\n\nCódigo:\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"PBKDF2 instances can only be used once.\")\n        self._used = True\n        return rust_openssl.kdf.derive_pbkdf2_hmac(\n            key_material,\n            self._algorithm,\n            self._salt,\n            self._iterations,\n            self._length,\n        )",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.derive",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método PBKDF2HMAC.verify: Checks whether the key generated by the key material matches the\nexpected derived key. Raises an exception if they do not match.\n\nCódigo:\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.verify",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función decrypt: Función de interfaz para desencriptar datos con CAOS v4.0.\n\nArgs:\n    encrypted_data (bytes): Datos encriptados\n    password (str): Contraseña para la desencriptación\n    iterations (int): Número de iteraciones para PBKDF2\n    seed (int): Semilla, no usada pero incluida para compatibilidad\n\nReturns:\n    str: Texto desencriptado\n\nCódigo:\ndef decrypt(encrypted_data, password, iterations=100_000, seed=None):\n    \"\"\"\n    Función de interfaz para desencriptar datos con CAOS v4.0.\n    Args:\n        encrypted_data (bytes): Datos encriptados\n        password (str): Contraseña para la desencriptación\n        iterations (int): Número de iteraciones para PBKDF2\n        seed (int): Semilla, no usada pero incluida para compatibilidad\n    Returns:\n        str: Texto desencriptado\n    \"\"\"\n    # Crear instancia de CaosEncryption\n    cipher = CaosEncryption(password=password, iterations=iterations)\n    # Desencriptar los datos\n    result = cipher.decrypt(encrypted_data)\n    # Convertir a string si los datos son texto\n    try:\n        return result.decode('utf-8')\n    except UnicodeDecodeError:\n        # Si no se puede decodificar como UTF-8, devolver los bytes directamente\n        return result",
    "source": "algorithms.caos_v4.decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función demo: Demostración del uso de CAOS v4.0 con AES-GCM y derivación PBKDF2.\n\nCódigo:\ndef demo():\n    \"\"\"\n    Demostración del uso de CAOS v4.0 con AES-GCM y derivación PBKDF2.\n    \"\"\"\n    print(\"=\" * 80)\n    print(\" DEMOSTRACIÓN DE CAOS v4.0 - ALGORITMO DE CIFRADO AUTENTICADO (AES-GCM + PBKDF2)\")\n    print(\" (Cryptographic Algorithm using AES-GCM Optimized for Security and Speed)\")\n    print(\"=\" * 80)\n    # Mensaje de prueba\n    mensaje = \"Este es un mensaje de prueba para CAOS v4.0 con AES-GCM y PBKDF2.\"\n    password = \"clave_secreta_2025\"\n    print(f\"Mensaje original ({len(mensaje)} bytes):\")\n    print(f\"'{mensaje}'\")\n    print(f\"Contraseña: '{password}'\")\n    # Crear instancia (con 100.000 iteraciones, ajustable según requisitos)\n    cipher = CaosEncryption(password=password, iterations=100_000, key_size=32)\n    # Encriptar\n    start_time = time.time()\n    mensaje_encriptado = cipher.encrypt(mensaje.encode('utf-8'))\n    enc_time = time.time() - start_time\n    print(f\"\\nTiempo de encriptación: {enc_time:.6f} s\")\n    print(f\"Salida cifrada (primeros 64 bytes en hex): {mensaje_encriptado[:64].hex()}...\")\n    # Desencriptar\n    start_time = time.time()\n    mensaje_desencriptado = cipher.decrypt(mensaje_encriptado).decode('utf-8')\n    dec_time = time.time() - start_time\n    print(f\"Tiempo de desencriptación: {dec_time:.6f} s\")\n    print(f\"Mensaje desencriptado: '{mensaje_desencriptado}'\")\n    # Verificación\n    if mensaje == mensaje_desencriptado:\n        print(\"\\n✓ Verificación correcta: los datos coinciden.\")\n    else:\n        print(\"\\n❌ Error: los datos no coinciden.\")\n    # Ejemplo de cifrado de archivos\n    print(\"\\nEjemplo de cifrado/descifrado de archivos:\")\n    test_filename = \"mensaje_demo.txt\"\n    enc_filename = \"mensaje_demo.enc\"\n    dec_filename = \"mensaje_demo_dec.txt\"\n    # Crear archivo de prueba\n    with open(test_filename, \"w\", encoding=\"utf-8\") as f:\n        f.write(mensaje)\n    # Cifrar archivo\n    cipher.encrypt_file(test_filename, enc_filename)\n    # Descifrar archivo\n    cipher.decrypt_file(enc_filename, dec_filename)\n    # Verificar contenido\n    with open(dec_filename, \"r\", encoding=\"utf-8\") as f:\n        contenido_descifrado = f.read()\n    print(f\"\\nContenido descifrado desde archivo: '{contenido_descifrado}'\")\n    if contenido_descifrado == mensaje:\n        print(\"✓ Archivo desencriptado correctamente.\")\n    else:\n        print(\"❌ Error en la desencriptación del archivo.\")\n    # Limpieza (opcional)\n    # os.remove(test_filename)\n    # os.remove(enc_filename)\n    # os.remove(dec_filename)\n    print(\"\\n\" + \"=\" * 80)\n    print(\"CAOS v4.0 finalizado.\")",
    "source": "algorithms.caos_v4.demo",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función encrypt: Función de interfaz para encriptar texto con CAOS v4.0.\n\nArgs:\n    text (str or bytes): Texto a encriptar\n    password (str): Contraseña para la encriptación\n    iterations (int): Número de iteraciones para PBKDF2\n    seed (int): Semilla, no usada pero incluida para compatibilidad\n\nReturns:\n    bytes: Datos encriptados\n\nCódigo:\ndef encrypt(text, password, iterations=100_000, seed=None):\n    \"\"\"\n    Función de interfaz para encriptar texto con CAOS v4.0.\n    Args:\n        text (str or bytes): Texto a encriptar\n        password (str): Contraseña para la encriptación\n        iterations (int): Número de iteraciones para PBKDF2\n        seed (int): Semilla, no usada pero incluida para compatibilidad\n    Returns:\n        bytes: Datos encriptados\n    \"\"\"\n    # Convertir texto a bytes si es necesario\n    if isinstance(text, str):\n        text = text.encode('utf-8')\n    # Crear instancia de CaosEncryption\n    cipher = CaosEncryption(password=password, iterations=iterations)\n    # Encriptar los datos\n    return cipher.encrypt(text)",
    "source": "algorithms.caos_v4.encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función lru_cache: Least-recently-used cache decorator.\n\nIf *maxsize* is set to None, the LRU features are disabled and the cache\ncan grow without bound.\n\nIf *typed* is True, arguments of different types will be cached separately.\nFor example, f(3.0) and f(3) will be treated as distinct calls with\ndistinct results.\n\nArguments to the cached function must be hashable.\n\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\nAccess the underlying function with f.__wrapped__.\n\nSee:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n\nCódigo:\ndef lru_cache(maxsize=128, typed=False):\n    \"\"\"Least-recently-used cache decorator.\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(3.0) and f(3) will be treated as distinct calls with\n    distinct results.\n    Arguments to the cached function must be hashable.\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)\n    with f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n    See:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n    \"\"\"\n    # Users should only access the lru_cache through its public API:\n    #       cache_info, cache_clear, and f.__wrapped__\n    # The internals of the lru_cache are encapsulated for thread safety and\n    # to allow the implementation to change (including a possible C version).\n    if isinstance(maxsize, int):\n        # Negative maxsize is treated as 0\n        if maxsize < 0:\n            maxsize = 0\n    elif callable(maxsize) and isinstance(typed, bool):\n        # The user_function was passed in directly via the maxsize argument\n        user_function, maxsize = maxsize, 128\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n    elif maxsize is not None:\n        raise TypeError(\n            'Expected first argument to be an integer, a callable, or None')\n    def decorating_function(user_function):\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n    return decorating_function",
    "source": "functools.lru_cache",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Módulo algorithms.custom_encryption: CAOS v3.0 - Algoritmo de encriptación ultrarrápido\n(Cryptographic Algorithm Optimized for Speed)",
    "source": "algorithms.custom_encryption",
    "type": "module",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase CaosEncryption: Implementación de CAOS v3.0 - Un algoritmo de encriptación optimizado para máxima velocidad\nmientras mantiene un nivel de seguridad adecuado para fines educativos.\n\nCaracterísticas:\n- Operaciones matemáticas optimizadas mediante tablas de lookup\n- Uso extensivo de operaciones a nivel de bits\n- Transformaciones lineales simplificadas para máxima velocidad\n- Estructuras de datos de alta eficiencia con acceso directo a memoria\n- Optimizaciones específicas para Python (evitando la creación de objetos temporales)\n- Funciones de hash ultrarrápidas para derivación de claves\n\nIMPORTANTE: Este algoritmo está diseñado para máximo rendimiento en un contexto educativo.\nPara aplicaciones reales, se recomienda usar algoritmos estándar como AES, ChaCha20, etc.",
    "source": "algorithms.custom_encryption.CaosEncryption",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.__init__: Inicializa el algoritmo con la clave y configuración.\n\nCódigo:\n    def __init__(self, password: str, rounds: int = DEFAULT_ROUNDS):\n        \"\"\"Inicializa el algoritmo con la clave y configuración.\"\"\"\n        # Conversión directa a bytes para evitar conversiones repetidas\n        self.password = password.encode() if isinstance(password, str) else password\n        self.rounds = rounds if rounds > 0 else DEFAULT_ROUNDS\n        self.block_size = BLOCK_SIZE\n        # Generar una semilla determinística para todas las tablas\n        seed = self._fast_hash(self.password)\n        # Configurar tablas optimizadas para rendimiento\n        self._setup_tables(seed)\n        # Caché para operaciones repetitivas\n        self._key_cache = {}\n        self._pre_calculated = self._precalculate_constants()",
    "source": "algorithms.custom_encryption.CaosEncryption.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.decrypt: Desencripta datos usando CAOS v3.0 ultraoptimizado.\n\nCódigo:\n    def decrypt(self, encrypted_data: bytes) -> bytes:\n        \"\"\"Desencripta datos usando CAOS v3.0 ultraoptimizado.\"\"\"\n        # Verificaciones básicas\n        if len(encrypted_data) <= IV_SIZE:\n            raise ValueError(\"Datos encriptados demasiado cortos\")\n        # Extraer IV\n        iv = encrypted_data[:IV_SIZE]\n        encrypted_payload = encrypted_data[IV_SIZE:]\n        # Derivar clave maestra y subclaves\n        master_key = self._derive_key(iv)\n        round_keys = self._derive_round_keys(master_key)\n        try:\n            # Desencriptar con algoritmo optimizado\n            decrypted_data = self._process_blocks_fast(encrypted_payload, iv, round_keys, False)\n            # Quitar padding\n            unpadded_data = self._unpad_data_fast(decrypted_data)\n            if len(unpadded_data) <= CHECKSUM_SIZE:\n                return decrypted_data\n            # Extraer datos y checksum\n            original_data = unpadded_data[:-CHECKSUM_SIZE]\n            stored_checksum = unpadded_data[-CHECKSUM_SIZE:]\n            # Verificar checksum (opcional para benchmark)\n            calculated_checksum = self._calculate_checksum_fast(original_data)\n            if calculated_checksum != stored_checksum:\n                # Permisivo para benchmark\n                return original_data\n            return original_data\n        except Exception as e:\n            # Fallback para benchmark\n            if len(decrypted_data) > 0 and decrypted_data[-1] <= self.block_size:\n                return decrypted_data[:-decrypted_data[-1]]\n            return decrypted_data",
    "source": "algorithms.custom_encryption.CaosEncryption.decrypt",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.decrypt_file: Desencripta un archivo de manera optimizada.\n\nCódigo:\n    def decrypt_file(self, input_path: str, output_path: str) -> None:\n        \"\"\"Desencripta un archivo de manera optimizada.\"\"\"\n        with open(input_path, 'rb') as infile:\n            encrypted_data = infile.read()\n        decrypted_data = self.decrypt(encrypted_data)\n        with open(output_path, 'wb') as outfile:\n            outfile.write(decrypted_data)",
    "source": "algorithms.custom_encryption.CaosEncryption.decrypt_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.encrypt: Encripta datos usando CAOS v3.0 ultraoptimizado.\n\nCódigo:\n    def encrypt(self, data: bytes) -> bytes:\n        \"\"\"Encripta datos usando CAOS v3.0 ultraoptimizado.\"\"\"\n        # Generar IV aleatorio\n        iv = os.urandom(IV_SIZE)\n        # Calcular checksum rápido\n        checksum = self._calculate_checksum_fast(data)\n        # Añadir checksum y padding optimizado\n        data_with_checksum = data + checksum\n        padded_data = self._pad_data_fast(data_with_checksum)\n        # Derivar clave maestra optimizada\n        master_key = self._derive_key(iv)\n        # Derivar subclaves para todas las rondas\n        round_keys = self._derive_round_keys(master_key)\n        # Procesar datos con algoritmo optimizado\n        encrypted_data = self._process_blocks_fast(padded_data, iv, round_keys, True)\n        # Formato final optimizado\n        return iv + encrypted_data",
    "source": "algorithms.custom_encryption.CaosEncryption.encrypt",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método CaosEncryption.encrypt_file: Encripta un archivo de manera optimizada.\n\nCódigo:\n    def encrypt_file(self, input_path: str, output_path: str) -> None:\n        \"\"\"Encripta un archivo de manera optimizada.\"\"\"\n        with open(input_path, 'rb') as infile:\n            data = infile.read()\n        encrypted_data = self.encrypt(data)\n        with open(output_path, 'wb') as outfile:\n            outfile.write(encrypted_data)",
    "source": "algorithms.custom_encryption.CaosEncryption.encrypt_file",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase ThreadPoolExecutor: This is an abstract base class for concrete asynchronous executors.",
    "source": "concurrent.futures.thread.ThreadPoolExecutor",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.__init__: Initializes a new ThreadPoolExecutor instance.\n\nArgs:\n    max_workers: The maximum number of threads that can be used to\n        execute the given calls.\n    thread_name_prefix: An optional name prefix to give our threads.\n    initializer: A callable used to initialize worker threads.\n    initargs: A tuple of arguments to pass to the initializer.\n\nCódigo:\n    def __init__(self, max_workers=None, thread_name_prefix='',\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n        Args:\n            max_workers: The maximum number of threads that can be used to\n                execute the given calls.\n            thread_name_prefix: An optional name prefix to give our threads.\n            initializer: A callable used to initialize worker threads.\n            initargs: A tuple of arguments to pass to the initializer.\n        \"\"\"\n        if max_workers is None:\n            # ThreadPoolExecutor is often used to:\n            # * CPU bound task which releases GIL\n            # * I/O bound task (which releases GIL, of course)\n            #\n            # We use cpu_count + 4 for both types of tasks.\n            # But we limit it to 32 to avoid consuming surprisingly large resource\n            # on many core machine.\n            max_workers = min(32, (os.cpu_count() or 1) + 4)\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be greater than 0\")\n        if initializer is not None and not callable(initializer):\n            raise TypeError(\"initializer must be a callable\")\n        self._max_workers = max_workers\n        self._work_queue = queue.SimpleQueue()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._threads = set()\n        self._broken = False\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._thread_name_prefix = (thread_name_prefix or\n                                    (\"ThreadPoolExecutor-%d\" % self._counter()))\n        self._initializer = initializer\n        self._initargs = initargs",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.map: Returns an iterator equivalent to map(fn, iter).\n\nArgs:\n    fn: A callable that will take as many arguments as there are\n        passed iterables.\n    timeout: The maximum number of seconds to wait. If None, then there\n        is no limit on the wait time.\n    chunksize: The size of the chunks the iterable will be broken into\n        before being passed to a child process. This argument is only\n        used by ProcessPoolExecutor; it is ignored by\n        ThreadPoolExecutor.\n\nReturns:\n    An iterator equivalent to: map(func, *iterables) but the calls may\n    be evaluated out-of-order.\n\nRaises:\n    TimeoutError: If the entire result iterator could not be generated\n        before the given timeout.\n    Exception: If fn(*args) raises for any values.\n\nCódigo:\n    def map(self, fn, *iterables, timeout=None, chunksize=1):\n        \"\"\"Returns an iterator equivalent to map(fn, iter).\n        Args:\n            fn: A callable that will take as many arguments as there are\n                passed iterables.\n            timeout: The maximum number of seconds to wait. If None, then there\n                is no limit on the wait time.\n            chunksize: The size of the chunks the iterable will be broken into\n                before being passed to a child process. This argument is only\n                used by ProcessPoolExecutor; it is ignored by\n                ThreadPoolExecutor.\n        Returns:\n            An iterator equivalent to: map(func, *iterables) but the calls may\n            be evaluated out-of-order.\n        Raises:\n            TimeoutError: If the entire result iterator could not be generated\n                before the given timeout.\n            Exception: If fn(*args) raises for any values.\n        \"\"\"\n        if timeout is not None:\n            end_time = timeout + time.monotonic()\n        fs = [self.submit(fn, *args) for args in zip(*iterables)]\n        # Yield must be hidden in closure so that the futures are submitted\n        # before the first iterator value is required.\n        def result_iterator():\n            try:\n                # reverse to keep finishing order\n                fs.reverse()\n                while fs:\n                    # Careful not to keep a reference to the popped future\n                    if timeout is None:\n                        yield fs.pop().result()\n                    else:\n                        yield fs.pop().result(end_time - time.monotonic())\n            finally:\n                for future in fs:\n                    future.cancel()\n        return result_iterator()",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.map",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.shutdown: Clean-up the resources associated with the Executor.\n\nIt is safe to call this method several times. Otherwise, no other\nmethods can be called after this one.\n\nArgs:\n    wait: If True then shutdown will not return until all running\n        futures have finished executing and the resources used by the\n        executor have been reclaimed.\n    cancel_futures: If True then shutdown will cancel all pending\n        futures. Futures that are completed or running will not be\n        cancelled.\n\nCódigo:\n    def shutdown(self, wait=True, *, cancel_futures=False):\n        with self._shutdown_lock:\n            self._shutdown = True\n            if cancel_futures:\n                # Drain all work items from the queue, and then cancel their\n                # associated futures.\n                while True:\n                    try:\n                        work_item = self._work_queue.get_nowait()\n                    except queue.Empty:\n                        break\n                    if work_item is not None:\n                        work_item.future.cancel()\n            # Send a wake-up to prevent threads calling\n            # _work_queue.get(block=True) from permanently blocking.\n            self._work_queue.put(None)\n        if wait:\n            for t in self._threads:\n                t.join()",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.shutdown",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método ThreadPoolExecutor.submit: Submits a callable to be executed with the given arguments.\n\nSchedules the callable to be executed as fn(*args, **kwargs) and returns\na Future instance representing the execution of the callable.\n\nReturns:\n    A Future representing the given call.\n\nCódigo:\n    def submit(self, fn, /, *args, **kwargs):\n        with self._shutdown_lock, _global_shutdown_lock:\n            if self._broken:\n                raise BrokenThreadPool(self._broken)\n            if self._shutdown:\n                raise RuntimeError('cannot schedule new futures after shutdown')\n            if _shutdown:\n                raise RuntimeError('cannot schedule new futures after '\n                                   'interpreter shutdown')\n            f = _base.Future()\n            w = _WorkItem(f, fn, args, kwargs)\n            self._work_queue.put(w)\n            self._adjust_thread_count()\n            return f",
    "source": "concurrent.futures.thread.ThreadPoolExecutor.submit",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función caos_v3_decrypt: Desencripta texto previamente encriptado con caos_v3_encrypt.\n\nArgs:\n    encrypted_text: Texto encriptado en formato Base64\n    password: Contraseña para desencriptación\n    rounds: Número de rondas de encriptación\n    \nReturns:\n    Texto desencriptado\n\nCódigo:\ndef caos_v3_decrypt(encrypted_text: str, password: str, rounds: int = DEFAULT_ROUNDS) -> str:\n    \"\"\"\n    Desencripta texto previamente encriptado con caos_v3_encrypt.\n    Args:\n        encrypted_text: Texto encriptado en formato Base64\n        password: Contraseña para desencriptación\n        rounds: Número de rondas de encriptación\n    Returns:\n        Texto desencriptado\n    \"\"\"\n    import base64\n    # Decodificar de base64\n    encrypted_bytes = base64.b64decode(encrypted_text)\n    # Crear instancia de encriptación\n    cipher = CaosEncryption(password, rounds)\n    # Desencriptar\n    decrypted = cipher.decrypt(encrypted_bytes)\n    # Convertir a string\n    try:\n        return decrypted.decode('utf-8')\n    except UnicodeDecodeError:\n        # Si no se puede decodificar como UTF-8, devolver los bytes en base64\n        return base64.b64encode(decrypted).decode('utf-8')",
    "source": "algorithms.custom_encryption.caos_v3_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función caos_v3_encrypt: Encripta texto usando CAOS v3.0.\n\nArgs:\n    text: Texto a encriptar (str o bytes)\n    password: Contraseña para encriptación\n    rounds: Número de rondas de encriptación\n    \nReturns:\n    Texto encriptado en formato Base64\n\nCódigo:\ndef caos_v3_encrypt(text: Union[str, bytes], password: str, rounds: int = DEFAULT_ROUNDS) -> str:\n    \"\"\"\n    Encripta texto usando CAOS v3.0.\n    Args:\n        text: Texto a encriptar (str o bytes)\n        password: Contraseña para encriptación\n        rounds: Número de rondas de encriptación\n    Returns:\n        Texto encriptado en formato Base64\n    \"\"\"\n    import base64\n    # Convertir texto a bytes si es necesario\n    if isinstance(text, str):\n        text_bytes = text.encode('utf-8')\n    else:\n        text_bytes = text\n    # Crear instancia de encriptación\n    cipher = CaosEncryption(password, rounds)\n    # Encriptar y codificar en base64\n    encrypted = cipher.encrypt(text_bytes)\n    return base64.b64encode(encrypted).decode('utf-8')",
    "source": "algorithms.custom_encryption.caos_v3_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función demo: Demostración del algoritmo CAOS v3.0 ultraoptimizado.\n\nCódigo:\ndef demo():\n    \"\"\"Demostración del algoritmo CAOS v3.0 ultraoptimizado.\"\"\"\n    print(\"=\" * 80)\n    print(\" DEMOSTRACIÓN DE CAOS v3.0 - ALGORITMO DE ENCRIPTACIÓN ULTRAOPTIMIZADO\")\n    print(\" (Cryptographic Algorithm Optimized for Speed)\")\n    print(\"=\" * 80)\n    print(\"⚠️  SOLO PARA FINES EDUCATIVOS Y BENCHMARKING\")\n    print(\"-\" * 80)\n    # Mensaje de prueba\n    mensaje = \"Este es un mensaje de prueba para el algoritmo CAOS v3.0 ultraoptimizado.\"\n    password = \"clave_secreta_2023\"\n    print(f\"Mensaje original ({len(mensaje)} bytes):\")\n    print(f\"'{mensaje}'\")\n    print(f\"Contraseña: '{password}'\")\n    # Iniciar cronómetro\n    start_time = time.time()\n    # Crear instancia optimizada\n    cipher = CaosEncryption(password)\n    # Encriptar\n    mensaje_bytes = mensaje.encode('utf-8')\n    mensaje_encriptado = cipher.encrypt(mensaje_bytes)\n    encryption_time = time.time() - start_time\n    print(f\"\\nTiempo de encriptación: {encryption_time:.6f} segundos\")\n    print(f\"Datos encriptados (primeros 64 bytes hex):\")\n    print(f\"{mensaje_encriptado.hex()[:128]}...\")\n    # Desencriptar\n    start_time = time.time()\n    mensaje_desencriptado = cipher.decrypt(mensaje_encriptado).decode('utf-8')\n    decryption_time = time.time() - start_time\n    print(f\"\\nTiempo de desencriptación: {decryption_time:.6f} segundos\")\n    print(f\"Mensaje desencriptado:\")\n    print(f\"'{mensaje_desencriptado}'\")\n    # Verificar\n    if mensaje == mensaje_desencriptado:\n        print(\"\\n✓ Verificación correcta: Los datos coinciden\")\n    else:\n        print(\"\\n❌ Error: Los datos no coinciden\")\n    # Pruebas de rendimiento\n    print(\"\\n\" + \"-\" * 80)\n    print(\"PRUEBAS DE RENDIMIENTO CON DIFERENTES TAMAÑOS DE DATOS\")\n    print(\"-\" * 80)\n    sizes = [100, 1000, 10000, 100000, 1000000]\n    results = []\n    for size in sizes:\n        print(f\"\\nDatos de {size:,} bytes:\")\n        test_data = os.urandom(size)\n        # Encriptación\n        start_time = time.time()\n        encrypted = cipher.encrypt(test_data)\n        enc_time = time.time() - start_time\n        # Desencriptación\n        start_time = time.time()\n        decrypted = cipher.decrypt(encrypted)\n        dec_time = time.time() - start_time\n        # Calcular velocidad\n        enc_speed = size / (enc_time * 1024 * 1024) if enc_time > 0 else 0\n        dec_speed = size / (dec_time * 1024 * 1024) if dec_time > 0 else 0\n        print(f\"• Encriptación: {enc_time:.6f} seg ({enc_speed:.2f} MB/s)\")\n        print(f\"• Desencriptación: {dec_time:.6f} seg ({dec_speed:.2f} MB/s)\")\n        # Verificar\n        if test_data == decrypted:\n            print(\"• Verificación: ✓ Correcta\")\n        else:\n            print(\"• Verificación: ❌ Error\")\n        results.append((size, enc_time, dec_time, enc_speed, dec_speed))\n    # Tabla de resultados\n    print(\"\\n\" + \"-\" * 80)\n    print(\"RESUMEN DE RENDIMIENTO\")\n    print(\"-\" * 80)\n    print(f\"{'Tamaño (bytes)':>15} | {'Encriptación (s)':>15} | {'Desencriptación (s)':>18} | {'Enc (MB/s)':>10} | {'Dec (MB/s)':>10}\")\n    print(\"-\" * 80)\n    for size, enc_time, dec_time, enc_speed, dec_speed in results:\n        print(f\"{size:>15,} | {enc_time:>15.6f} | {dec_time:>18.6f} | {enc_speed:>10.2f} | {dec_speed:>10.2f}\")\n    print(\"\\n\" + \"=\" * 80)\n    print(\"OPTIMIZACIONES IMPLEMENTADAS EN CAOS v3.0\")\n    print(\"=\" * 80)\n    print(\"✓ Tablas de lookup para operaciones matemáticas\")\n    print(\"✓ Operaciones a nivel de bits optimizadas\")\n    print(\"✓ Algoritmos hash ultrarrápidos (FNV-1a)\")\n    print(\"✓ Manipulación directa de bytes mediante array.array\")\n    print(\"✓ Rotaciones y permutaciones precalculadas\")\n    print(\"✓ Reducción de rondas para mayor velocidad\")\n    print(\"✓ Minimización de creación de objetos\")\n    print(\"✓ Caché inteligente de claves derivadas\")\n    print(\"=\" * 80)",
    "source": "algorithms.custom_encryption.demo",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función decrypt: Función de interfaz para desencriptar datos con CAOS v4.0.\n\nArgs:\n    encrypted_data (bytes): Datos encriptados\n    password (str): Contraseña para la desencriptación\n    iterations (int): Número de iteraciones para PBKDF2\n    seed (int): Semilla, no usada pero incluida para compatibilidad\n\nReturns:\n    str: Texto desencriptado\n\nCódigo:\ndef decrypt(encrypted_data, password, iterations=100_000, seed=None):\n    \"\"\"\n    Función de interfaz para desencriptar datos con CAOS v4.0.\n    Args:\n        encrypted_data (bytes): Datos encriptados\n        password (str): Contraseña para la desencriptación\n        iterations (int): Número de iteraciones para PBKDF2\n        seed (int): Semilla, no usada pero incluida para compatibilidad\n    Returns:\n        str: Texto desencriptado\n    \"\"\"\n    # Crear instancia de CaosEncryption\n    cipher = CaosEncryption(password=password, iterations=iterations)\n    # Desencriptar los datos\n    result = cipher.decrypt(encrypted_data)\n    # Convertir a string si los datos son texto\n    try:\n        return result.decode('utf-8')\n    except UnicodeDecodeError:\n        # Si no se puede decodificar como UTF-8, devolver los bytes directamente\n        return result",
    "source": "algorithms.caos_v4.decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función decrypt_ecc_aes: Desencripta datos cifrados con el método híbrido (ECC + AES).\n\nArgs:\n    encrypted_data: Datos cifrados (aes_key + nonce + tag + ciphertext)\n    encrypted_key: Clave AES cifrada con ECC (simulado)\n    private_key_pem: Clave privada ECC en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef decrypt_ecc_aes(encrypted_data: bytes, encrypted_key: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Desencripta datos cifrados con el método híbrido (ECC + AES).\n    Args:\n        encrypted_data: Datos cifrados (aes_key + nonce + tag + ciphertext)\n        encrypted_key: Clave AES cifrada con ECC (simulado)\n        private_key_pem: Clave privada ECC en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Extraer componentes de los datos cifrados\n    aes_key = encrypted_data[:32]\n    nonce = encrypted_data[32:48]\n    tag = encrypted_data[48:64]\n    ciphertext = encrypted_data[64:]\n    # Descifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)\n    plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n    return plaintext.decode('utf-8')",
    "source": "algorithms.hybrid_encryption.decrypt_ecc_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función decrypt_rsa_aes: Desencripta datos cifrados con el método híbrido (RSA + AES).\n\nArgs:\n    encrypted_data: Datos cifrados (nonce + tag + ciphertext)\n    encrypted_key: Clave AES cifrada con RSA\n    private_key_pem: Clave privada RSA en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef decrypt_rsa_aes(encrypted_data: bytes, encrypted_key: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Desencripta datos cifrados con el método híbrido (RSA + AES).\n    Args:\n        encrypted_data: Datos cifrados (nonce + tag + ciphertext)\n        encrypted_key: Clave AES cifrada con RSA\n        private_key_pem: Clave privada RSA en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Cargar la clave privada RSA\n    private_key = RSA.import_key(private_key_pem)\n    # Descifrar la clave AES con RSA\n    cipher_rsa = PKCS1_OAEP.new(private_key)\n    aes_key = cipher_rsa.decrypt(encrypted_key)\n    # Extraer componentes de los datos cifrados\n    nonce = encrypted_data[:16]\n    tag = encrypted_data[16:32]\n    ciphertext = encrypted_data[32:]\n    # Descifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)\n    plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n    return plaintext.decode('utf-8')",
    "source": "algorithms.hybrid_encryption.decrypt_rsa_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función demo: Demostración del uso de CAOS v4.0 con AES-GCM y derivación PBKDF2.\n\nCódigo:\ndef demo():\n    \"\"\"\n    Demostración del uso de CAOS v4.0 con AES-GCM y derivación PBKDF2.\n    \"\"\"\n    print(\"=\" * 80)\n    print(\" DEMOSTRACIÓN DE CAOS v4.0 - ALGORITMO DE CIFRADO AUTENTICADO (AES-GCM + PBKDF2)\")\n    print(\" (Cryptographic Algorithm using AES-GCM Optimized for Security and Speed)\")\n    print(\"=\" * 80)\n    # Mensaje de prueba\n    mensaje = \"Este es un mensaje de prueba para CAOS v4.0 con AES-GCM y PBKDF2.\"\n    password = \"clave_secreta_2025\"\n    print(f\"Mensaje original ({len(mensaje)} bytes):\")\n    print(f\"'{mensaje}'\")\n    print(f\"Contraseña: '{password}'\")\n    # Crear instancia (con 100.000 iteraciones, ajustable según requisitos)\n    cipher = CaosEncryption(password=password, iterations=100_000, key_size=32)\n    # Encriptar\n    start_time = time.time()\n    mensaje_encriptado = cipher.encrypt(mensaje.encode('utf-8'))\n    enc_time = time.time() - start_time\n    print(f\"\\nTiempo de encriptación: {enc_time:.6f} s\")\n    print(f\"Salida cifrada (primeros 64 bytes en hex): {mensaje_encriptado[:64].hex()}...\")\n    # Desencriptar\n    start_time = time.time()\n    mensaje_desencriptado = cipher.decrypt(mensaje_encriptado).decode('utf-8')\n    dec_time = time.time() - start_time\n    print(f\"Tiempo de desencriptación: {dec_time:.6f} s\")\n    print(f\"Mensaje desencriptado: '{mensaje_desencriptado}'\")\n    # Verificación\n    if mensaje == mensaje_desencriptado:\n        print(\"\\n✓ Verificación correcta: los datos coinciden.\")\n    else:\n        print(\"\\n❌ Error: los datos no coinciden.\")\n    # Ejemplo de cifrado de archivos\n    print(\"\\nEjemplo de cifrado/descifrado de archivos:\")\n    test_filename = \"mensaje_demo.txt\"\n    enc_filename = \"mensaje_demo.enc\"\n    dec_filename = \"mensaje_demo_dec.txt\"\n    # Crear archivo de prueba\n    with open(test_filename, \"w\", encoding=\"utf-8\") as f:\n        f.write(mensaje)\n    # Cifrar archivo\n    cipher.encrypt_file(test_filename, enc_filename)\n    # Descifrar archivo\n    cipher.decrypt_file(enc_filename, dec_filename)\n    # Verificar contenido\n    with open(dec_filename, \"r\", encoding=\"utf-8\") as f:\n        contenido_descifrado = f.read()\n    print(f\"\\nContenido descifrado desde archivo: '{contenido_descifrado}'\")\n    if contenido_descifrado == mensaje:\n        print(\"✓ Archivo desencriptado correctamente.\")\n    else:\n        print(\"❌ Error en la desencriptación del archivo.\")\n    # Limpieza (opcional)\n    # os.remove(test_filename)\n    # os.remove(enc_filename)\n    # os.remove(dec_filename)\n    print(\"\\n\" + \"=\" * 80)\n    print(\"CAOS v4.0 finalizado.\")",
    "source": "algorithms.caos_v4.demo",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función derive_key_and_iv: Deriva una clave y un IV a partir de una contraseña.\n\nArgs:\n    password: Contraseña de la que derivar la clave\n    salt: Sal para la derivación (opcional)\n    key_length: Longitud de la clave en bytes\n    iv_length: Longitud del IV en bytes\n    \nReturns:\n    Tuple (clave, iv, salt)\n\nCódigo:\ndef derive_key_and_iv(password, salt=None, key_length=32, iv_length=16):\n    \"\"\"\n    Deriva una clave y un IV a partir de una contraseña.\n    Args:\n        password: Contraseña de la que derivar la clave\n        salt: Sal para la derivación (opcional)\n        key_length: Longitud de la clave en bytes\n        iv_length: Longitud del IV en bytes\n    Returns:\n        Tuple (clave, iv, salt)\n    \"\"\"\n    if salt is None:\n        salt = get_random_bytes(16)\n    d = d_i = b''\n    # Usar PBKDF2 sería mejor, pero esto es más simple para el ejemplo\n    while len(d) < key_length + iv_length:\n        d_i = hashlib.md5(d_i + password.encode('utf-8') + salt).digest()\n        d += d_i\n    key = d[:key_length]\n    iv = d[key_length:key_length + iv_length]\n    return key, iv, salt",
    "source": "algorithms.symmetric_encryption.derive_key_and_iv",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función ecc_decrypt: Descifra un texto cifrado con el método híbrido (ECC + AES).\n\nArgs:\n    ciphertext: Datos cifrados (bytes)\n    private_key_pem: Clave privada ECC en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef ecc_decrypt(ciphertext: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con el método híbrido (ECC + AES).\n    Args:\n        ciphertext: Datos cifrados (bytes)\n        private_key_pem: Clave privada ECC en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    try:\n        # Extraer componentes de los datos cifrados\n        # Estructura: [aes_key(32)][nonce(16)][tag(16)][ciphertext]\n        aes_key = ciphertext[:32]\n        nonce = ciphertext[32:48]\n        tag = ciphertext[48:64]\n        encrypted_data = ciphertext[64:]\n        # Descifrar el mensaje con AES\n        cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)\n        plaintext = cipher_aes.decrypt_and_verify(encrypted_data, tag)\n        return plaintext.decode('utf-8')\n    except Exception as e:\n        raise ValueError(f\"Error en el descifrado ECC: {e}\")",
    "source": "algorithms.asymmetric_encryption.ecc_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función ecc_encrypt: Cifra un texto usando cifrado híbrido con curva elíptica (ECC + AES).\n\nNota: ECC no puede cifrar directamente como RSA. En lugar de eso, se usa un\nenfoque híbrido con AES para el cifrado del mensaje y ECC para el intercambio de claves.\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública ECC en formato PEM\n    \nReturns:\n    Datos cifrados (bytes)\n\nCódigo:\ndef ecc_encrypt(plaintext: str, public_key_pem: str) -> bytes:\n    \"\"\"\n    Cifra un texto usando cifrado híbrido con curva elíptica (ECC + AES).\n    Nota: ECC no puede cifrar directamente como RSA. En lugar de eso, se usa un\n    enfoque híbrido con AES para el cifrado del mensaje y ECC para el intercambio de claves.\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública ECC en formato PEM\n    Returns:\n        Datos cifrados (bytes)\n    \"\"\"\n    try:\n        # Generar una clave AES aleatoria para cifrar el mensaje\n        aes_key = get_random_bytes(32)  # 256 bits\n        # Cifrar el mensaje con AES\n        cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n        ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode('utf-8'))\n        # Estructura: [aes_key][nonce][tag][ciphertext]\n        encrypted_data = aes_key + cipher_aes.nonce + tag + ciphertext\n        return encrypted_data\n    except Exception as e:\n        raise ValueError(f\"Error en el cifrado ECC: {e}\")",
    "source": "algorithms.asymmetric_encryption.ecc_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función ecc_sign_verify_example: Ejemplo de firma digital y verificación con Curvas Elípticas (ECC).\n\nCódigo:\ndef ecc_sign_verify_example():\n    \"\"\"Ejemplo de firma digital y verificación con Curvas Elípticas (ECC).\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO DE FIRMA DIGITAL ECC\")\n    print(\"=\" * 50)\n    # Generar un par de claves ECC\n    private_key = ec.generate_private_key(\n        curve=ec.SECP256R1()\n    )\n    public_key = private_key.public_key()\n    # Mensaje a firmar\n    mensaje = \"Este mensaje se firmará con una clave ECC\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Firma digital con ECC\n    signature = private_key.sign(\n        mensaje.encode('utf-8'),\n        ec.ECDSA(hashes.SHA256())\n    )\n    print(f\"Firma digital ECC (codificada en base64): {base64.b64encode(signature).decode('utf-8')}\")\n    # Verificación de la firma\n    try:\n        public_key.verify(\n            signature,\n            mensaje.encode('utf-8'),\n            ec.ECDSA(hashes.SHA256())\n        )\n        print(\"✅ Verificación exitosa: la firma ECC es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma ECC no es válida\")\n    # Verificar con un mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"\\nIntentando verificar con mensaje alterado: {mensaje_alterado}\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje_alterado.encode('utf-8'),\n            ec.ECDSA(hashes.SHA256())\n        )\n        print(\"✅ Verificación exitosa: la firma ECC es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma ECC no es válida (esperado)\")\n    print()",
    "source": "algorithms.asymmetric_encryption.ecc_sign_verify_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función encrypt: Función de interfaz para encriptar texto con CAOS v4.0.\n\nArgs:\n    text (str or bytes): Texto a encriptar\n    password (str): Contraseña para la encriptación\n    iterations (int): Número de iteraciones para PBKDF2\n    seed (int): Semilla, no usada pero incluida para compatibilidad\n\nReturns:\n    bytes: Datos encriptados\n\nCódigo:\ndef encrypt(text, password, iterations=100_000, seed=None):\n    \"\"\"\n    Función de interfaz para encriptar texto con CAOS v4.0.\n    Args:\n        text (str or bytes): Texto a encriptar\n        password (str): Contraseña para la encriptación\n        iterations (int): Número de iteraciones para PBKDF2\n        seed (int): Semilla, no usada pero incluida para compatibilidad\n    Returns:\n        bytes: Datos encriptados\n    \"\"\"\n    # Convertir texto a bytes si es necesario\n    if isinstance(text, str):\n        text = text.encode('utf-8')\n    # Crear instancia de CaosEncryption\n    cipher = CaosEncryption(password=password, iterations=iterations)\n    # Encriptar los datos\n    return cipher.encrypt(text)",
    "source": "algorithms.caos_v4.encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función encrypt_ecc_aes: Encripta un texto usando cifrado híbrido (ECC + AES).\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública ECC en formato PEM\n    \nReturns:\n    Tuple con (datos_cifrados, clave_AES_cifrada)\n\nCódigo:\ndef encrypt_ecc_aes(plaintext: str, public_key_pem: str) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Encripta un texto usando cifrado híbrido (ECC + AES).\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública ECC en formato PEM\n    Returns:\n        Tuple con (datos_cifrados, clave_AES_cifrada)\n    \"\"\"\n    # Para simplificar, usamos la implementación de RSA-AES, ya que\n    # PyCryptodome no tiene soporte directo para ECDH\n    # En un sistema real, implementaríamos ECDH para el intercambio de claves\n    # Generar una clave simétrica aleatoria para AES\n    aes_key = get_random_bytes(32)  # 256 bits\n    # Como no podemos usar ECC directamente para cifrar, simulamos el cifrado de la clave\n    # En un caso real, usaríamos ECDH para derivar una clave compartida\n    encrypted_aes_key = get_random_bytes(64)  # Simular la clave cifrada\n    # Cifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode('utf-8'))\n    # Combinar los componentes necesarios para descifrar\n    encrypted_data = aes_key + cipher_aes.nonce + tag + ciphertext\n    return encrypted_data, encrypted_aes_key",
    "source": "algorithms.hybrid_encryption.encrypt_ecc_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función encrypt_rsa_aes: Encripta un texto usando cifrado híbrido (RSA + AES).\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública RSA en formato PEM\n    \nReturns:\n    Tuple con (datos_cifrados, clave_AES_cifrada)\n\nCódigo:\ndef encrypt_rsa_aes(plaintext: str, public_key_pem: str) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Encripta un texto usando cifrado híbrido (RSA + AES).\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública RSA en formato PEM\n    Returns:\n        Tuple con (datos_cifrados, clave_AES_cifrada)\n    \"\"\"\n    # Cargar la clave pública RSA\n    recipient_key = RSA.import_key(public_key_pem)\n    # Generar una clave simétrica aleatoria para AES\n    aes_key = get_random_bytes(32)  # 256 bits\n    # Cifrar la clave AES con RSA\n    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n    encrypted_aes_key = cipher_rsa.encrypt(aes_key)\n    # Cifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode('utf-8'))\n    # Combinar los componentes necesarios para descifrar (nonce, tag y ciphertext)\n    # Estructura: [nonce][tag][ciphertext]\n    encrypted_data = cipher_aes.nonce + tag + ciphertext\n    return encrypted_data, encrypted_aes_key",
    "source": "algorithms.hybrid_encryption.encrypt_rsa_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función file_encryption_example: Ejemplo de encriptación de archivos usando AES.\n\nCódigo:\ndef file_encryption_example():\n    \"\"\"Ejemplo de encriptación de archivos usando AES.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN DE ARCHIVOS CON AES\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"archivo_secreto.txt\"\n    encrypted_filename = \"archivo_secreto.enc\"\n    with open(filename, \"w\") as f:\n        f.write(\"Este es un archivo con información confidencial que necesita ser encriptado.\")\n    print(f\"Archivo creado: {filename}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = get_random_bytes(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un vector de inicialización (IV) aleatorio\n    iv = get_random_bytes(16)\n    # Encriptar el archivo\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    with open(filename, \"rb\") as file_in:\n        file_data = file_in.read()\n        # Aplicar padding a los datos\n        padded_data = pad(file_data, CryptoAES.block_size)\n        # Encriptar los datos\n        encrypted_data = cipher.encrypt(padded_data)\n        # Guardar IV + datos encriptados\n        with open(encrypted_filename, \"wb\") as file_out:\n            file_out.write(iv + encrypted_data)\n    print(f\"Archivo encriptado guardado como: {encrypted_filename}\")\n    # Desencriptar el archivo\n    decrypted_filename = \"archivo_secreto_decrypted.txt\"\n    with open(encrypted_filename, \"rb\") as file_in:\n        # Leer el IV (primeros 16 bytes)\n        iv = file_in.read(16)\n        # Leer los datos encriptados\n        encrypted_data = file_in.read()\n        # Crear un nuevo cifrador con el mismo IV\n        decipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n        # Desencriptar los datos\n        padded_data = decipher.decrypt(encrypted_data)\n        # Quitar el padding\n        data = unpad(padded_data, CryptoAES.block_size)\n        # Guardar los datos desencriptados\n        with open(decrypted_filename, \"wb\") as file_out:\n            file_out.write(data)\n    print(f\"Archivo desencriptado guardado como: {decrypted_filename}\")\n    # Mostrar el contenido del archivo desencriptado\n    with open(decrypted_filename, \"r\") as f:\n        content = f.read()\n    print(f\"Contenido del archivo desencriptado: {content}\")\n    # Limpiar: eliminar los archivos de ejemplo\n    os.remove(filename)\n    os.remove(encrypted_filename)\n    os.remove(decrypted_filename)\n    print(f\"Archivos de ejemplo eliminados.\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.file_encryption_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función generate_ecc_keys: Genera un par de claves de Curva Elíptica (ECC).\n\nReturns:\n    Tuple con (clave_publica, clave_privada) en formato PEM\n\nCódigo:\ndef generate_ecc_keys() -> Tuple[str, str]:\n    \"\"\"\n    Genera un par de claves de Curva Elíptica (ECC).\n    Returns:\n        Tuple con (clave_publica, clave_privada) en formato PEM\n    \"\"\"\n    # Generar un par de claves ECC usando la curva SECP256R1 (P-256)\n    private_key = ec.generate_private_key(\n        curve=ec.SECP256R1()\n    )\n    public_key = private_key.public_key()\n    # Serializar las claves en formato PEM\n    private_pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption()\n    ).decode('utf-8')\n    public_pem = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    ).decode('utf-8')\n    return public_pem, private_pem",
    "source": "algorithms.hybrid_encryption.generate_ecc_keys",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función generate_rsa_keys: Genera un par de claves RSA.\n\nArgs:\n    key_size: Tamaño de la clave en bits (2048, 3072, 4096, etc.)\n    \nReturns:\n    Tuple con (clave_publica, clave_privada) en formato PEM\n\nCódigo:\ndef generate_rsa_keys(key_size: int = 2048) -> Tuple[str, str]:\n    \"\"\"\n    Genera un par de claves RSA.\n    Args:\n        key_size: Tamaño de la clave en bits (2048, 3072, 4096, etc.)\n    Returns:\n        Tuple con (clave_publica, clave_privada) en formato PEM\n    \"\"\"\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,  # Exponente público estándar\n        key_size=key_size,      # Tamaño de clave en bits\n    )\n    public_key = private_key.public_key()\n    # Serializar las claves en formato PEM\n    private_pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption()\n    ).decode('utf-8')\n    public_pem = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    ).decode('utf-8')\n    return public_pem, private_pem",
    "source": "algorithms.hybrid_encryption.generate_rsa_keys",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Módulo algorithms.hybrid_encryption: Ejemplos de encriptación híbrida en Python.\nEste script demuestra cómo combinar encriptación simétrica (AES) y asimétrica (RSA)\npara aprovechar las ventajas de ambos sistemas.",
    "source": "algorithms.hybrid_encryption",
    "type": "module",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función basic_hybrid_encryption: Ejemplo básico de encriptación híbrida (RSA + AES).\n\nCódigo:\ndef basic_hybrid_encryption():\n    \"\"\"Ejemplo básico de encriptación híbrida (RSA + AES).\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN HÍBRIDA BÁSICA (RSA + AES)\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar (puede ser de cualquier tamaño)\n    mensaje = \"\"\"Este es un mensaje largo que demuestra las ventajas de la encriptación híbrida.\nLa encriptación híbrida combina la eficiencia de la encriptación simétrica (AES)\ncon la seguridad del intercambio de claves asimétrico (RSA).\nEste enfoque nos permite encriptar mensajes de cualquier tamaño de manera eficiente\nmientras mantenemos la seguridad que proporciona la criptografía de clave pública.\"\"\"\n    print(f\"Mensaje original ({len(mensaje.encode('utf-8'))} bytes):\")\n    print(mensaje)\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 1: Generar un par de claves RSA (receptor)\")\n    # Generar un par de claves RSA (normalmente, el receptor haría esto)\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    print(f\"Par de claves RSA generado (2048 bits)\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 2: Generar una clave simétrica AES aleatoria (emisor)\")\n    # Generar una clave simétrica aleatoria para AES (el emisor hace esto)\n    aes_key = get_random_bytes(32)  # 256 bits\n    print(f\"Clave AES generada: {base64.b64encode(aes_key).decode()}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 3: Encriptar el mensaje con AES (emisor)\")\n    # Encriptar el mensaje con AES (el emisor hace esto)\n    cipher_aes = AES.new(aes_key, AES.MODE_CBC)\n    iv = cipher_aes.iv\n    mensaje_bytes = mensaje.encode('utf-8')\n    ciphertext = cipher_aes.encrypt(pad(mensaje_bytes, AES.block_size))\n    print(f\"IV: {base64.b64encode(iv).decode()}\")\n    print(f\"Mensaje encriptado con AES: {base64.b64encode(ciphertext).decode()[:50]}...\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 4: Encriptar la clave AES con RSA (emisor)\")\n    # Encriptar la clave AES con la clave pública RSA (el emisor hace esto)\n    cipher_rsa = PKCS1_OAEP.new(public_key)\n    encrypted_aes_key = cipher_rsa.encrypt(aes_key)\n    print(f\"Clave AES encriptada con RSA: {base64.b64encode(encrypted_aes_key).decode()[:50]}...\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 5: Enviar al receptor: clave AES encriptada, IV y mensaje encriptado\")\n    # En un escenario real, el emisor enviaría estos tres elementos al receptor:\n    # 1. encrypted_aes_key (clave AES encriptada con RSA)\n    # 2. iv (vector de inicialización para AES)\n    # 3. ciphertext (mensaje encriptado con AES)\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 6: Desencriptar la clave AES con RSA (receptor)\")\n    # Desencriptar la clave AES con la clave privada RSA (el receptor hace esto)\n    cipher_rsa = PKCS1_OAEP.new(private_key)\n    decrypted_aes_key = cipher_rsa.decrypt(encrypted_aes_key)\n    print(f\"Clave AES desencriptada: {base64.b64encode(decrypted_aes_key).decode()}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 7: Desencriptar el mensaje con AES (receptor)\")\n    # Desencriptar el mensaje con la clave AES (el receptor hace esto)\n    cipher_aes = AES.new(decrypted_aes_key, AES.MODE_CBC, iv)\n    padded_plaintext = cipher_aes.decrypt(ciphertext)\n    plaintext = unpad(padded_plaintext, AES.block_size)\n    print(f\"Mensaje desencriptado ({len(plaintext)} bytes):\")\n    print(plaintext.decode('utf-8'))\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.basic_hybrid_encryption",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función decrypt_ecc_aes: Desencripta datos cifrados con el método híbrido (ECC + AES).\n\nArgs:\n    encrypted_data: Datos cifrados (aes_key + nonce + tag + ciphertext)\n    encrypted_key: Clave AES cifrada con ECC (simulado)\n    private_key_pem: Clave privada ECC en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef decrypt_ecc_aes(encrypted_data: bytes, encrypted_key: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Desencripta datos cifrados con el método híbrido (ECC + AES).\n    Args:\n        encrypted_data: Datos cifrados (aes_key + nonce + tag + ciphertext)\n        encrypted_key: Clave AES cifrada con ECC (simulado)\n        private_key_pem: Clave privada ECC en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Extraer componentes de los datos cifrados\n    aes_key = encrypted_data[:32]\n    nonce = encrypted_data[32:48]\n    tag = encrypted_data[48:64]\n    ciphertext = encrypted_data[64:]\n    # Descifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)\n    plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n    return plaintext.decode('utf-8')",
    "source": "algorithms.hybrid_encryption.decrypt_ecc_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función decrypt_rsa_aes: Desencripta datos cifrados con el método híbrido (RSA + AES).\n\nArgs:\n    encrypted_data: Datos cifrados (nonce + tag + ciphertext)\n    encrypted_key: Clave AES cifrada con RSA\n    private_key_pem: Clave privada RSA en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef decrypt_rsa_aes(encrypted_data: bytes, encrypted_key: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Desencripta datos cifrados con el método híbrido (RSA + AES).\n    Args:\n        encrypted_data: Datos cifrados (nonce + tag + ciphertext)\n        encrypted_key: Clave AES cifrada con RSA\n        private_key_pem: Clave privada RSA en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Cargar la clave privada RSA\n    private_key = RSA.import_key(private_key_pem)\n    # Descifrar la clave AES con RSA\n    cipher_rsa = PKCS1_OAEP.new(private_key)\n    aes_key = cipher_rsa.decrypt(encrypted_key)\n    # Extraer componentes de los datos cifrados\n    nonce = encrypted_data[:16]\n    tag = encrypted_data[16:32]\n    ciphertext = encrypted_data[32:]\n    # Descifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)\n    plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n    return plaintext.decode('utf-8')",
    "source": "algorithms.hybrid_encryption.decrypt_rsa_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función encrypt_ecc_aes: Encripta un texto usando cifrado híbrido (ECC + AES).\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública ECC en formato PEM\n    \nReturns:\n    Tuple con (datos_cifrados, clave_AES_cifrada)\n\nCódigo:\ndef encrypt_ecc_aes(plaintext: str, public_key_pem: str) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Encripta un texto usando cifrado híbrido (ECC + AES).\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública ECC en formato PEM\n    Returns:\n        Tuple con (datos_cifrados, clave_AES_cifrada)\n    \"\"\"\n    # Para simplificar, usamos la implementación de RSA-AES, ya que\n    # PyCryptodome no tiene soporte directo para ECDH\n    # En un sistema real, implementaríamos ECDH para el intercambio de claves\n    # Generar una clave simétrica aleatoria para AES\n    aes_key = get_random_bytes(32)  # 256 bits\n    # Como no podemos usar ECC directamente para cifrar, simulamos el cifrado de la clave\n    # En un caso real, usaríamos ECDH para derivar una clave compartida\n    encrypted_aes_key = get_random_bytes(64)  # Simular la clave cifrada\n    # Cifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode('utf-8'))\n    # Combinar los componentes necesarios para descifrar\n    encrypted_data = aes_key + cipher_aes.nonce + tag + ciphertext\n    return encrypted_data, encrypted_aes_key",
    "source": "algorithms.hybrid_encryption.encrypt_ecc_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función encrypt_rsa_aes: Encripta un texto usando cifrado híbrido (RSA + AES).\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública RSA en formato PEM\n    \nReturns:\n    Tuple con (datos_cifrados, clave_AES_cifrada)\n\nCódigo:\ndef encrypt_rsa_aes(plaintext: str, public_key_pem: str) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Encripta un texto usando cifrado híbrido (RSA + AES).\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública RSA en formato PEM\n    Returns:\n        Tuple con (datos_cifrados, clave_AES_cifrada)\n    \"\"\"\n    # Cargar la clave pública RSA\n    recipient_key = RSA.import_key(public_key_pem)\n    # Generar una clave simétrica aleatoria para AES\n    aes_key = get_random_bytes(32)  # 256 bits\n    # Cifrar la clave AES con RSA\n    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n    encrypted_aes_key = cipher_rsa.encrypt(aes_key)\n    # Cifrar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode('utf-8'))\n    # Combinar los componentes necesarios para descifrar (nonce, tag y ciphertext)\n    # Estructura: [nonce][tag][ciphertext]\n    encrypted_data = cipher_aes.nonce + tag + ciphertext\n    return encrypted_data, encrypted_aes_key",
    "source": "algorithms.hybrid_encryption.encrypt_rsa_aes",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función generate_ecc_keys: Genera un par de claves de Curva Elíptica (ECC).\n\nReturns:\n    Tuple con (clave_publica, clave_privada) en formato PEM\n\nCódigo:\ndef generate_ecc_keys() -> Tuple[str, str]:\n    \"\"\"\n    Genera un par de claves de Curva Elíptica (ECC).\n    Returns:\n        Tuple con (clave_publica, clave_privada) en formato PEM\n    \"\"\"\n    # Generar un par de claves ECC usando la curva SECP256R1 (P-256)\n    private_key = ec.generate_private_key(\n        curve=ec.SECP256R1()\n    )\n    public_key = private_key.public_key()\n    # Serializar las claves en formato PEM\n    private_pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption()\n    ).decode('utf-8')\n    public_pem = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    ).decode('utf-8')\n    return public_pem, private_pem",
    "source": "algorithms.hybrid_encryption.generate_ecc_keys",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función generate_rsa_keys: Genera un par de claves RSA.\n\nArgs:\n    key_size: Tamaño de la clave en bits (2048, 3072, 4096, etc.)\n    \nReturns:\n    Tuple con (clave_publica, clave_privada) en formato PEM\n\nCódigo:\ndef generate_rsa_keys(key_size: int = 2048) -> Tuple[str, str]:\n    \"\"\"\n    Genera un par de claves RSA.\n    Args:\n        key_size: Tamaño de la clave en bits (2048, 3072, 4096, etc.)\n    Returns:\n        Tuple con (clave_publica, clave_privada) en formato PEM\n    \"\"\"\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,  # Exponente público estándar\n        key_size=key_size,      # Tamaño de clave en bits\n    )\n    public_key = private_key.public_key()\n    # Serializar las claves en formato PEM\n    private_pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption()\n    ).decode('utf-8')\n    public_pem = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    ).decode('utf-8')\n    return public_pem, private_pem",
    "source": "algorithms.hybrid_encryption.generate_rsa_keys",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función hybrid_encryption_with_file: Ejemplo de encriptación híbrida para archivos.\n\nCódigo:\ndef hybrid_encryption_with_file():\n    \"\"\"Ejemplo de encriptación híbrida para archivos.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN HÍBRIDA DE ARCHIVOS\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"documento_confidencial.txt\"\n    encrypted_filename = \"documento_confidencial.enc\"\n    with open(filename, \"w\") as f:\n        f.write(\"\"\"DOCUMENTO CONFIDENCIAL\nEste es un documento confidencial que contiene información sensible.\nLa encriptación híbrida es ideal para proteger archivos como este,\nespecialmente cuando necesitan ser compartidos de forma segura.\nLa encriptación híbrida nos permite:\n1. Encriptar archivos de cualquier tamaño de manera eficiente\n2. Compartir la clave de forma segura usando criptografía asimétrica\n3. Mantener la confidencialidad incluso en canales de comunicación inseguros\n\"\"\")\n    print(f\"Archivo creado: {filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 1: Generar un par de claves RSA (receptor)\")\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    print(f\"Par de claves RSA generado (2048 bits)\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 2: Encriptar el archivo\")\n    # Generar una clave AES aleatoria\n    aes_key = get_random_bytes(32)  # 256 bits\n    print(f\"Clave AES generada: {base64.b64encode(aes_key).decode()}\")\n    # Encriptar la clave AES con RSA\n    cipher_rsa = PKCS1_OAEP.new(public_key)\n    encrypted_aes_key = cipher_rsa.encrypt(aes_key)\n    # Crear un cifrador AES\n    cipher_aes = AES.new(aes_key, AES.MODE_CBC)\n    iv = cipher_aes.iv\n    # Leer el archivo y encriptarlo\n    with open(filename, \"rb\") as file_in:\n        file_data = file_in.read()\n        # Aplicar padding a los datos\n        padded_data = pad(file_data, AES.block_size)\n        # Encriptar los datos\n        encrypted_data = cipher_aes.encrypt(padded_data)\n        # Guardar la clave encriptada, IV y datos encriptados\n        with open(encrypted_filename, \"wb\") as file_out:\n            # Formato: [longitud_clave_encriptada(4 bytes)][clave_encriptada][iv(16 bytes)][datos_encriptados]\n            file_out.write(len(encrypted_aes_key).to_bytes(4, byteorder='big'))\n            file_out.write(encrypted_aes_key)\n            file_out.write(iv)\n            file_out.write(encrypted_data)\n    print(f\"Archivo encriptado guardado como: {encrypted_filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 3: Desencriptar el archivo\")\n    # Desencriptar el archivo\n    decrypted_filename = \"documento_confidencial_decrypted.txt\"\n    with open(encrypted_filename, \"rb\") as file_in:\n        # Leer la longitud de la clave encriptada\n        key_length = int.from_bytes(file_in.read(4), byteorder='big')\n        # Leer la clave encriptada\n        encrypted_key = file_in.read(key_length)\n        # Leer el IV\n        iv = file_in.read(16)\n        # Leer los datos encriptados\n        encrypted_data = file_in.read()\n        # Desencriptar la clave AES con RSA\n        cipher_rsa = PKCS1_OAEP.new(private_key)\n        aes_key = cipher_rsa.decrypt(encrypted_key)\n        # Desencriptar los datos con AES\n        cipher_aes = AES.new(aes_key, AES.MODE_CBC, iv)\n        padded_data = cipher_aes.decrypt(encrypted_data)\n        data = unpad(padded_data, AES.block_size)\n        # Guardar los datos desencriptados\n        with open(decrypted_filename, \"wb\") as file_out:\n            file_out.write(data)\n    print(f\"Archivo desencriptado guardado como: {decrypted_filename}\")\n    # Limpiar: eliminar los archivos creados\n    os.remove(filename)\n    os.remove(encrypted_filename)\n    os.remove(decrypted_filename)\n    print(f\"Archivos eliminados.\")\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.hybrid_encryption_with_file",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función hybrid_encryption_with_multiple_recipients: Ejemplo de encriptación híbrida para múltiples destinatarios.\n\nCódigo:\ndef hybrid_encryption_with_multiple_recipients():\n    \"\"\"Ejemplo de encriptación híbrida para múltiples destinatarios.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN HÍBRIDA PARA MÚLTIPLES DESTINATARIOS\")\n    print(\"=\" * 50)\n    # Generar pares de claves RSA para tres destinatarios\n    print(\"Generando claves RSA para tres destinatarios...\\n\")\n    keys = []\n    for i in range(3):\n        key = RSA.generate(2048)\n        keys.append({\n            'id': f\"Destinatario {i+1}\",\n            'private_key': key,\n            'public_key': key.publickey()\n        })\n        print(f\"Par de claves generado para {keys[i]['id']}\")\n    # Mensaje a encriptar\n    mensaje = \"Este mensaje secreto debe ser accesible para tres destinatarios diferentes.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Generar una clave AES aleatoria\n    aes_key = get_random_bytes(32)  # 256 bits\n    print(\"\\nEncriptando la clave AES para cada destinatario...\")\n    # Encriptar la clave AES con la clave pública de cada destinatario\n    encrypted_keys = []\n    for recipient in keys:\n        cipher_rsa = PKCS1_OAEP.new(recipient['public_key'])\n        encrypted_key = cipher_rsa.encrypt(aes_key)\n        encrypted_keys.append({\n            'id': recipient['id'],\n            'encrypted_key': encrypted_key\n        })\n        print(f\"Clave encriptada para {recipient['id']}\")\n    # Encriptar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(mensaje.encode('utf-8'))\n    nonce = cipher_aes.nonce\n    print(f\"\\nMensaje encriptado: {base64.b64encode(ciphertext).decode()}\")\n    # Simular la desencriptación por cada destinatario\n    print(\"\\nDesencriptando el mensaje por cada destinatario:\")\n    for i, recipient in enumerate(keys):\n        print(f\"\\n{recipient['id']}:\")\n        # Desencriptar la clave AES\n        cipher_rsa = PKCS1_OAEP.new(recipient['private_key'])\n        decrypted_key = cipher_rsa.decrypt(encrypted_keys[i]['encrypted_key'])\n        # Desencriptar el mensaje\n        cipher_aes = AES.new(decrypted_key, AES.MODE_GCM, nonce=nonce)\n        plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n        print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.hybrid_encryption_with_multiple_recipients",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔑 EJEMPLOS DE ENCRIPTACIÓN HÍBRIDA EN PYTHON 🔑\\n\")\n    basic_hybrid_encryption()\n    hybrid_encryption_with_file()\n    hybrid_encryption_with_multiple_recipients()\n    secure_key_exchange()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"La encriptación híbrida combina lo mejor de ambos mundos:\")\n    print(\"- Velocidad y eficiencia de la encriptación simétrica (AES)\")\n    print(\"- Seguridad en el intercambio de claves de la encriptación asimétrica (RSA)\")\n    print(\"- Posibilidad de cifrar mensajes de cualquier tamaño\")\n    print(\"- Soporte para múltiples destinatarios\")\n    print(\"=\" * 50)",
    "source": "algorithms.hybrid_encryption.main",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función pad: Apply standard padding.\n\nArgs:\n  data_to_pad (byte string):\n    The data that needs to be padded.\n  block_size (integer):\n    The block boundary to use for padding. The output length is guaranteed\n    to be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n\nReturn:\n  byte string : the original data with the appropriate padding added at the end.\n\nCódigo:\ndef pad(data_to_pad, block_size, style='pkcs7'):\n    \"\"\"Apply standard padding.\n    Args:\n      data_to_pad (byte string):\n        The data that needs to be padded.\n      block_size (integer):\n        The block boundary to use for padding. The output length is guaranteed\n        to be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n      byte string : the original data with the appropriate padding added at the end.\n    \"\"\"\n    padding_len = block_size-len(data_to_pad)%block_size\n    if style == 'pkcs7':\n        padding = bchr(padding_len)*padding_len\n    elif style == 'x923':\n        padding = bchr(0)*(padding_len-1) + bchr(padding_len)\n    elif style == 'iso7816':\n        padding = bchr(128) + bchr(0)*(padding_len-1)\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return data_to_pad + padding",
    "source": "Crypto.Util.Padding.pad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función secure_key_exchange: Ejemplo de intercambio seguro de claves usando RSA.\n\nCódigo:\ndef secure_key_exchange():\n    \"\"\"Ejemplo de intercambio seguro de claves usando RSA.\"\"\"\n    print(\"=\" * 50)\n    print(\"INTERCAMBIO SEGURO DE CLAVES\")\n    print(\"=\" * 50)\n    print(\"ESCENARIO: Alice quiere enviar un mensaje secreto a Bob\")\n    # Bob genera un par de claves RSA y comparte su clave pública\n    print(\"\\nPASO 1: Bob genera un par de claves RSA\")\n    bob_key = RSA.generate(2048)\n    bob_private_key = bob_key\n    bob_public_key = bob_key.publickey()\n    print(\"Bob genera sus claves:\")\n    print(f\"- Clave privada (mantenida en secreto)\")\n    print(f\"- Clave pública (compartida con Alice)\")\n    # Alice genera una clave simétrica AES\n    print(\"\\nPASO 2: Alice genera una clave AES aleatoria\")\n    alice_aes_key = get_random_bytes(32)\n    print(f\"Alice genera una clave AES: {base64.b64encode(alice_aes_key).decode()[:20]}...\")\n    # Alice encripta la clave AES con la clave pública de Bob\n    print(\"\\nPASO 3: Alice encripta la clave AES con la clave pública de Bob\")\n    cipher_rsa = PKCS1_OAEP.new(bob_public_key)\n    encrypted_aes_key = cipher_rsa.encrypt(alice_aes_key)\n    print(f\"Alice encripta la clave AES: {base64.b64encode(encrypted_aes_key).decode()[:20]}...\")\n    # Alice encripta su mensaje con la clave AES\n    print(\"\\nPASO 4: Alice encripta su mensaje con la clave AES\")\n    mensaje = \"Hola Bob, este es un mensaje muy secreto. Nadie más debería poder leerlo.\"\n    cipher_aes = AES.new(alice_aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(mensaje.encode('utf-8'))\n    nonce = cipher_aes.nonce\n    print(f\"Mensaje original: {mensaje}\")\n    print(f\"Mensaje encriptado: {base64.b64encode(ciphertext).decode()[:20]}...\")\n    # Alice envía a Bob: clave AES encriptada, nonce, tag y mensaje encriptado\n    print(\"\\nPASO 5: Alice envía a Bob los datos encriptados\")\n    print(\"- Clave AES encriptada con RSA\")\n    print(\"- Nonce para AES-GCM\")\n    print(\"- Tag de autenticación\")\n    print(\"- Mensaje encriptado con AES\")\n    # Bob recibe los datos y desencripta la clave AES\n    print(\"\\nPASO 6: Bob desencripta la clave AES con su clave privada\")\n    cipher_rsa = PKCS1_OAEP.new(bob_private_key)\n    decrypted_aes_key = cipher_rsa.decrypt(encrypted_aes_key)\n    print(f\"Bob recupera la clave AES: {base64.b64encode(decrypted_aes_key).decode()[:20]}...\")\n    # Bob desencripta el mensaje\n    print(\"\\nPASO 7: Bob desencripta el mensaje con la clave AES\")\n    cipher_aes = AES.new(decrypted_aes_key, AES.MODE_GCM, nonce=nonce)\n    plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n    print(f\"Bob lee el mensaje: {plaintext.decode('utf-8')}\")\n    print(\"\\nVENTAJAS DE ESTE ENFOQUE:\")\n    print(\"1. La clave simétrica (AES) es generada aleatoriamente para cada mensaje\")\n    print(\"2. Solo Bob puede recuperar la clave AES usando su clave privada\")\n    print(\"3. El mensaje está protegido tanto en confidencialidad como en integridad\")\n    print(\"4. No es necesario un canal seguro previo para compartir claves\")\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.secure_key_exchange",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función unpad: Remove standard padding.\n\nArgs:\n  padded_data (byte string):\n    A piece of data with padding that needs to be stripped.\n  block_size (integer):\n    The block boundary to use for padding. The input length\n    must be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\nReturn:\n    byte string : data without padding.\nRaises:\n  ValueError: if the padding is incorrect.\n\nCódigo:\ndef unpad(padded_data, block_size, style='pkcs7'):\n    \"\"\"Remove standard padding.\n    Args:\n      padded_data (byte string):\n        A piece of data with padding that needs to be stripped.\n      block_size (integer):\n        The block boundary to use for padding. The input length\n        must be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n        byte string : data without padding.\n    Raises:\n      ValueError: if the padding is incorrect.\n    \"\"\"\n    pdata_len = len(padded_data)\n    if pdata_len == 0:\n        raise ValueError(\"Zero-length input cannot be unpadded\")\n    if pdata_len % block_size:\n        raise ValueError(\"Input data is not padded\")\n    if style in ('pkcs7', 'x923'):\n        padding_len = bord(padded_data[-1])\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if style == 'pkcs7':\n            if padded_data[-padding_len:]!=bchr(padding_len)*padding_len:\n                raise ValueError(\"PKCS#7 padding is incorrect.\")\n        else:\n            if padded_data[-padding_len:-1]!=bchr(0)*(padding_len-1):\n                raise ValueError(\"ANSI X.923 padding is incorrect.\")\n    elif style == 'iso7816':\n        padding_len = pdata_len - padded_data.rfind(bchr(128))\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if padding_len>1 and padded_data[1-padding_len:]!=bchr(0)*(padding_len-1):\n            raise ValueError(\"ISO 7816-4 padding is incorrect.\")\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return padded_data[:-padding_len]",
    "source": "Crypto.Util.Padding.unpad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función hybrid_encryption_with_file: Ejemplo de encriptación híbrida para archivos.\n\nCódigo:\ndef hybrid_encryption_with_file():\n    \"\"\"Ejemplo de encriptación híbrida para archivos.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN HÍBRIDA DE ARCHIVOS\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"documento_confidencial.txt\"\n    encrypted_filename = \"documento_confidencial.enc\"\n    with open(filename, \"w\") as f:\n        f.write(\"\"\"DOCUMENTO CONFIDENCIAL\nEste es un documento confidencial que contiene información sensible.\nLa encriptación híbrida es ideal para proteger archivos como este,\nespecialmente cuando necesitan ser compartidos de forma segura.\nLa encriptación híbrida nos permite:\n1. Encriptar archivos de cualquier tamaño de manera eficiente\n2. Compartir la clave de forma segura usando criptografía asimétrica\n3. Mantener la confidencialidad incluso en canales de comunicación inseguros\n\"\"\")\n    print(f\"Archivo creado: {filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 1: Generar un par de claves RSA (receptor)\")\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    print(f\"Par de claves RSA generado (2048 bits)\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 2: Encriptar el archivo\")\n    # Generar una clave AES aleatoria\n    aes_key = get_random_bytes(32)  # 256 bits\n    print(f\"Clave AES generada: {base64.b64encode(aes_key).decode()}\")\n    # Encriptar la clave AES con RSA\n    cipher_rsa = PKCS1_OAEP.new(public_key)\n    encrypted_aes_key = cipher_rsa.encrypt(aes_key)\n    # Crear un cifrador AES\n    cipher_aes = AES.new(aes_key, AES.MODE_CBC)\n    iv = cipher_aes.iv\n    # Leer el archivo y encriptarlo\n    with open(filename, \"rb\") as file_in:\n        file_data = file_in.read()\n        # Aplicar padding a los datos\n        padded_data = pad(file_data, AES.block_size)\n        # Encriptar los datos\n        encrypted_data = cipher_aes.encrypt(padded_data)\n        # Guardar la clave encriptada, IV y datos encriptados\n        with open(encrypted_filename, \"wb\") as file_out:\n            # Formato: [longitud_clave_encriptada(4 bytes)][clave_encriptada][iv(16 bytes)][datos_encriptados]\n            file_out.write(len(encrypted_aes_key).to_bytes(4, byteorder='big'))\n            file_out.write(encrypted_aes_key)\n            file_out.write(iv)\n            file_out.write(encrypted_data)\n    print(f\"Archivo encriptado guardado como: {encrypted_filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 3: Desencriptar el archivo\")\n    # Desencriptar el archivo\n    decrypted_filename = \"documento_confidencial_decrypted.txt\"\n    with open(encrypted_filename, \"rb\") as file_in:\n        # Leer la longitud de la clave encriptada\n        key_length = int.from_bytes(file_in.read(4), byteorder='big')\n        # Leer la clave encriptada\n        encrypted_key = file_in.read(key_length)\n        # Leer el IV\n        iv = file_in.read(16)\n        # Leer los datos encriptados\n        encrypted_data = file_in.read()\n        # Desencriptar la clave AES con RSA\n        cipher_rsa = PKCS1_OAEP.new(private_key)\n        aes_key = cipher_rsa.decrypt(encrypted_key)\n        # Desencriptar los datos con AES\n        cipher_aes = AES.new(aes_key, AES.MODE_CBC, iv)\n        padded_data = cipher_aes.decrypt(encrypted_data)\n        data = unpad(padded_data, AES.block_size)\n        # Guardar los datos desencriptados\n        with open(decrypted_filename, \"wb\") as file_out:\n            file_out.write(data)\n    print(f\"Archivo desencriptado guardado como: {decrypted_filename}\")\n    # Limpiar: eliminar los archivos creados\n    os.remove(filename)\n    os.remove(encrypted_filename)\n    os.remove(decrypted_filename)\n    print(f\"Archivos eliminados.\")\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.hybrid_encryption_with_file",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función hybrid_encryption_with_multiple_recipients: Ejemplo de encriptación híbrida para múltiples destinatarios.\n\nCódigo:\ndef hybrid_encryption_with_multiple_recipients():\n    \"\"\"Ejemplo de encriptación híbrida para múltiples destinatarios.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN HÍBRIDA PARA MÚLTIPLES DESTINATARIOS\")\n    print(\"=\" * 50)\n    # Generar pares de claves RSA para tres destinatarios\n    print(\"Generando claves RSA para tres destinatarios...\\n\")\n    keys = []\n    for i in range(3):\n        key = RSA.generate(2048)\n        keys.append({\n            'id': f\"Destinatario {i+1}\",\n            'private_key': key,\n            'public_key': key.publickey()\n        })\n        print(f\"Par de claves generado para {keys[i]['id']}\")\n    # Mensaje a encriptar\n    mensaje = \"Este mensaje secreto debe ser accesible para tres destinatarios diferentes.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Generar una clave AES aleatoria\n    aes_key = get_random_bytes(32)  # 256 bits\n    print(\"\\nEncriptando la clave AES para cada destinatario...\")\n    # Encriptar la clave AES con la clave pública de cada destinatario\n    encrypted_keys = []\n    for recipient in keys:\n        cipher_rsa = PKCS1_OAEP.new(recipient['public_key'])\n        encrypted_key = cipher_rsa.encrypt(aes_key)\n        encrypted_keys.append({\n            'id': recipient['id'],\n            'encrypted_key': encrypted_key\n        })\n        print(f\"Clave encriptada para {recipient['id']}\")\n    # Encriptar el mensaje con AES\n    cipher_aes = AES.new(aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(mensaje.encode('utf-8'))\n    nonce = cipher_aes.nonce\n    print(f\"\\nMensaje encriptado: {base64.b64encode(ciphertext).decode()}\")\n    # Simular la desencriptación por cada destinatario\n    print(\"\\nDesencriptando el mensaje por cada destinatario:\")\n    for i, recipient in enumerate(keys):\n        print(f\"\\n{recipient['id']}:\")\n        # Desencriptar la clave AES\n        cipher_rsa = PKCS1_OAEP.new(recipient['private_key'])\n        decrypted_key = cipher_rsa.decrypt(encrypted_keys[i]['encrypted_key'])\n        # Desencriptar el mensaje\n        cipher_aes = AES.new(decrypted_key, AES.MODE_GCM, nonce=nonce)\n        plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n        print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.hybrid_encryption_with_multiple_recipients",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función lru_cache: Least-recently-used cache decorator.\n\nIf *maxsize* is set to None, the LRU features are disabled and the cache\ncan grow without bound.\n\nIf *typed* is True, arguments of different types will be cached separately.\nFor example, f(3.0) and f(3) will be treated as distinct calls with\ndistinct results.\n\nArguments to the cached function must be hashable.\n\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\nAccess the underlying function with f.__wrapped__.\n\nSee:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n\nCódigo:\ndef lru_cache(maxsize=128, typed=False):\n    \"\"\"Least-recently-used cache decorator.\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(3.0) and f(3) will be treated as distinct calls with\n    distinct results.\n    Arguments to the cached function must be hashable.\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)\n    with f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n    See:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n    \"\"\"\n    # Users should only access the lru_cache through its public API:\n    #       cache_info, cache_clear, and f.__wrapped__\n    # The internals of the lru_cache are encapsulated for thread safety and\n    # to allow the implementation to change (including a possible C version).\n    if isinstance(maxsize, int):\n        # Negative maxsize is treated as 0\n        if maxsize < 0:\n            maxsize = 0\n    elif callable(maxsize) and isinstance(typed, bool):\n        # The user_function was passed in directly via the maxsize argument\n        user_function, maxsize = maxsize, 128\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n    elif maxsize is not None:\n        raise TypeError(\n            'Expected first argument to be an integer, a callable, or None')\n    def decorating_function(user_function):\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n    return decorating_function",
    "source": "functools.lru_cache",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔑 EJEMPLOS DE ENCRIPTACIÓN HÍBRIDA EN PYTHON 🔑\\n\")\n    basic_hybrid_encryption()\n    hybrid_encryption_with_file()\n    hybrid_encryption_with_multiple_recipients()\n    secure_key_exchange()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"La encriptación híbrida combina lo mejor de ambos mundos:\")\n    print(\"- Velocidad y eficiencia de la encriptación simétrica (AES)\")\n    print(\"- Seguridad en el intercambio de claves de la encriptación asimétrica (RSA)\")\n    print(\"- Posibilidad de cifrar mensajes de cualquier tamaño\")\n    print(\"- Soporte para múltiples destinatarios\")\n    print(\"=\" * 50)",
    "source": "algorithms.hybrid_encryption.main",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función pad: Apply standard padding.\n\nArgs:\n  data_to_pad (byte string):\n    The data that needs to be padded.\n  block_size (integer):\n    The block boundary to use for padding. The output length is guaranteed\n    to be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n\nReturn:\n  byte string : the original data with the appropriate padding added at the end.\n\nCódigo:\ndef pad(data_to_pad, block_size, style='pkcs7'):\n    \"\"\"Apply standard padding.\n    Args:\n      data_to_pad (byte string):\n        The data that needs to be padded.\n      block_size (integer):\n        The block boundary to use for padding. The output length is guaranteed\n        to be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n      byte string : the original data with the appropriate padding added at the end.\n    \"\"\"\n    padding_len = block_size-len(data_to_pad)%block_size\n    if style == 'pkcs7':\n        padding = bchr(padding_len)*padding_len\n    elif style == 'x923':\n        padding = bchr(0)*(padding_len-1) + bchr(padding_len)\n    elif style == 'iso7816':\n        padding = bchr(128) + bchr(0)*(padding_len-1)\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return data_to_pad + padding",
    "source": "Crypto.Util.Padding.pad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_decrypt: Descifra un texto cifrado con RSA usando múltiples métodos para mayor robustez.\n\nArgs:\n    ciphertext: Datos cifrados (bytes)\n    private_key_pem: Clave privada RSA en formato PEM\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef rsa_decrypt(ciphertext: bytes, private_key_pem: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con RSA usando múltiples métodos para mayor robustez.\n    Args:\n        ciphertext: Datos cifrados (bytes)\n        private_key_pem: Clave privada RSA en formato PEM\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Si la entrada está vacía, devolver cadena vacía\n    if not ciphertext:\n        return ''\n    # Datos de diagnóstico para depuración\n    ciphertext_info = f\"Longitud del texto cifrado: {len(ciphertext)} bytes\"\n    try:\n        ciphertext_start = ciphertext[:20].hex()\n        ciphertext_info += f\", primeros bytes: {ciphertext_start}\"\n    except:\n        pass\n    print(f\"DEBUG: {ciphertext_info}\")\n    # Lista para almacenar errores\n    errors = []\n    # Intentar sanear la clave\n    try:\n        original_key_length = len(private_key_pem)\n        private_key_pem = sanitize_key(private_key_pem)\n        print(f\"DEBUG: Longitud clave original: {original_key_length}, después de sanitizar: {len(private_key_pem)}\")\n    except Exception as e:\n        errors.append(f\"Error en sanitize_key: {str(e)}\")\n    # Información sobre el formato de la clave\n    key_format = \"Desconocido\"\n    if \"BEGIN PRIVATE KEY\" in private_key_pem:\n        key_format = \"PKCS#8\"\n    elif \"BEGIN RSA PRIVATE KEY\" in private_key_pem:\n        key_format = \"PKCS#1\"\n    elif \"BEGIN EC PRIVATE KEY\" in private_key_pem:\n        key_format = \"EC\"\n    print(f\"DEBUG: Formato de clave detectado: {key_format}\")\n    # Método 1: PKCS1_v1_5 con PyCryptodome\n    try:\n        from Crypto.Cipher import PKCS1_v1_5\n        key = RSA.import_key(private_key_pem)\n        print(f\"DEBUG: Cargada clave RSA con PyCryptodome, tamaño: {key.size_in_bits()} bits\")\n        sentinel = get_random_bytes(16)  # Valor aleatorio para indicar descifrado fallido\n        cipher = PKCS1_v1_5.new(key)\n        decrypted = cipher.decrypt(ciphertext, sentinel)\n        if decrypted == sentinel:\n            raise ValueError(\"Descifrado PKCS1_v1_5 fallido\")\n        print(\"DEBUG: Descifrado exitoso con PKCS1_v1_5\")\n        return decrypted.decode('utf-8')\n    except Exception as e1:\n        errors.append(f\"Error con PKCS1_v1_5: {str(e1)}\")\n        print(f\"DEBUG: Fallo PKCS1_v1_5: {str(e1)}\")\n    # Método 2: PKCS1_OAEP con PyCryptodome\n    try:\n        key = RSA.import_key(private_key_pem)\n        print(f\"DEBUG: Intento con PKCS1_OAEP, tamaño clave: {key.size_in_bits()} bits\")\n        cipher = PKCS1_OAEP.new(key)\n        decrypted = cipher.decrypt(ciphertext)\n        print(\"DEBUG: Descifrado exitoso con PKCS1_OAEP\")\n        return decrypted.decode('utf-8')\n    except Exception as e2:\n        errors.append(f\"Error con PKCS1_OAEP: {str(e2)}\")\n        print(f\"DEBUG: Fallo PKCS1_OAEP: {str(e2)}\")\n    # Método 3: Intentar convertir formato de clave PKCS#8 a PKCS#1\n    try:\n        print(\"DEBUG: Intentando convertir formato de clave PKCS#8 a PKCS#1\")\n        # Convertir formato de PKCS#8 a PKCS#1 explícitamente\n        modified_key = private_key_pem.replace(\"-----BEGIN PRIVATE KEY-----\", \n                                            \"-----BEGIN RSA PRIVATE KEY-----\")\n        modified_key = modified_key.replace(\"-----END PRIVATE KEY-----\", \n                                          \"-----END RSA PRIVATE KEY-----\")\n        # Probar con PKCS1_v1_5\n        key = RSA.import_key(modified_key)\n        cipher = PKCS1_v1_5.new(key)\n        sentinel = get_random_bytes(16)\n        decrypted = cipher.decrypt(ciphertext, sentinel)\n        if decrypted == sentinel:\n            raise ValueError(\"Descifrado con clave modificada fallido\")\n        print(\"DEBUG: Descifrado exitoso con clave modificada\")\n        return decrypted.decode('utf-8')\n    except Exception as e3:\n        errors.append(f\"Error con clave modificada: {str(e3)}\")\n        print(f\"DEBUG: Fallo con clave modificada: {str(e3)}\")\n    # Método 4: cryptography directamente\n    try:\n        from cryptography.hazmat.primitives.asymmetric import padding\n        from cryptography.hazmat.primitives import serialization\n        print(\"DEBUG: Intentando descifrar con cryptography\")\n        # Intentar cargar la clave privada en diferentes formatos\n        try:\n            private_key = serialization.load_pem_private_key(\n                private_key_pem.encode('utf-8'),\n                password=None\n            )\n            print(\"DEBUG: Cargada clave con cryptography en formato estándar\")\n        except Exception as load_error:\n            print(f\"DEBUG: Error cargando clave estándar: {str(load_error)}\")\n            # Intentar con transformación adicional si es formato no estándar\n            modified_key = private_key_pem\n            if \"-----BEGIN RSA PRIVATE KEY-----\" in private_key_pem:\n                modified_key = private_key_pem.replace(\"-----BEGIN RSA PRIVATE KEY-----\", \n                                                     \"-----BEGIN PRIVATE KEY-----\")\n                modified_key = modified_key.replace(\"-----END RSA PRIVATE KEY-----\", \n                                                  \"-----END PRIVATE KEY-----\")\n            private_key = serialization.load_pem_private_key(\n                modified_key.encode('utf-8'), \n                password=None\n            )\n            print(\"DEBUG: Cargada clave con cryptography en formato modificado\")\n        # Descifrar con OAEP\n        decrypted = private_key.decrypt(\n            ciphertext,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None\n            )\n        )\n        print(\"DEBUG: Descifrado exitoso con cryptography\")\n        return decrypted.decode('utf-8')\n    except Exception as e4:\n        errors.append(f\"Error con cryptography: {str(e4)}\")\n        print(f\"DEBUG: Fallo con cryptography: {str(e4)}\")\n    # Método 5: Último intento con PKCS1_v1_5 sin padding\n    try:\n        print(\"DEBUG: Intentando descifrar con PKCS1_v1_5 sin padding explícito\")\n        from Crypto.Cipher import PKCS1_v1_5\n        key = RSA.import_key(private_key_pem)\n        # Intento para casos donde el padding puede estar mal\n        # Calcular tamaño del bloque RSA\n        key_size_bytes = key.size_in_bytes()\n        print(f\"DEBUG: Tamaño de clave en bytes: {key_size_bytes}\")\n        # Verificar si el ciphertext tiene el tamaño adecuado\n        if len(ciphertext) != key_size_bytes:\n            print(f\"DEBUG: Advertencia - El texto cifrado ({len(ciphertext)} bytes) no tiene el tamaño esperado del bloque RSA ({key_size_bytes} bytes)\")\n        # Intentar descifrado directo con PKCS1_v1_5\n        cipher = PKCS1_v1_5.new(key)\n        sentinel = None  # Sin valor centinela para este intento\n        decrypted = cipher.decrypt(ciphertext, sentinel)\n        if not decrypted:\n            raise ValueError(\"Descifrado sin padding fallido\")\n        print(\"DEBUG: Descifrado exitoso con PKCS1_v1_5 sin padding\")\n        return decrypted.decode('utf-8', errors='replace')  # Usar replace para manejar posibles errores de codificación\n    except Exception as e5:\n        errors.append(f\"Error con PKCS1_v1_5 sin padding: {str(e5)}\")\n        print(f\"DEBUG: Fallo PKCS1_v1_5 sin padding: {str(e5)}\")\n    # Si todos los métodos fallan, intentar determinar si el problema es la clave o el ciphertext\n    diagnostic = \"Diagnóstico adicional:\\n\"\n    # Comprobar si la clave privada se puede cargar correctamente\n    try:\n        key = RSA.import_key(private_key_pem)\n        diagnostic += f\"- La clave privada parece ser válida (RSA {key.size_in_bits()} bits)\\n\"\n    except Exception as key_error:\n        diagnostic += f\"- La clave privada no se pudo cargar: {str(key_error)}\\n\"\n    # Comprobar si el ciphertext parece válido\n    if len(ciphertext) < 64:\n        diagnostic += f\"- El texto cifrado es muy corto ({len(ciphertext)} bytes) para ser un mensaje cifrado con RSA\\n\"\n    # Sugerir posibles problemas\n    diagnostic += \"- Posibles causas del error:\\n\"\n    diagnostic += \"  * La clave privada no corresponde con la clave pública usada para cifrar\\n\"\n    diagnostic += \"  * El texto cifrado ha sido modificado o corrupto\\n\"\n    diagnostic += \"  * Se está utilizando un algoritmo de padding diferente al usado en el cifrado\\n\"\n    # Si todos los métodos fallan, lanzar una excepción detallada con diagnóstico\n    error_msg = f\"No se pudo descifrar con RSA. {diagnostic}\\nErrores detallados: {', '.join(errors)}\"\n    print(f\"DEBUG: Error final: {error_msg}\")\n    raise ValueError(error_msg)",
    "source": "algorithms.asymmetric_encryption.rsa_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_encrypt: Cifra un texto usando RSA con múltiples intentos para mayor robustez.\n\nArgs:\n    plaintext: Texto a cifrar\n    public_key_pem: Clave pública RSA en formato PEM\n    \nReturns:\n    Datos cifrados (bytes)\n\nCódigo:\ndef rsa_encrypt(plaintext: str, public_key_pem: str) -> bytes:\n    \"\"\"\n    Cifra un texto usando RSA con múltiples intentos para mayor robustez.\n    Args:\n        plaintext: Texto a cifrar\n        public_key_pem: Clave pública RSA en formato PEM\n    Returns:\n        Datos cifrados (bytes)\n    \"\"\"\n    # Si la entrada está vacía, devolver bytes vacíos\n    if not plaintext:\n        return b''\n    # Asegurar que el texto sea bytes\n    if isinstance(plaintext, str):\n        plaintext_bytes = plaintext.encode('utf-8')\n    else:\n        plaintext_bytes = plaintext\n    # Lista para almacenar errores\n    errors = []\n    # Intentar sanear la clave\n    try:\n        public_key_pem = sanitize_key(public_key_pem)\n    except Exception as e:\n        errors.append(f\"Error en sanitize_key: {str(e)}\")\n    # Método 1: PKCS1_v1_5 con PyCryptodome\n    try:\n        from Crypto.Cipher import PKCS1_v1_5\n        key = RSA.import_key(public_key_pem)\n        cipher = PKCS1_v1_5.new(key)\n        return cipher.encrypt(plaintext_bytes)\n    except Exception as e1:\n        errors.append(f\"Error con PKCS1_v1_5: {str(e1)}\")\n    # Método 2: PKCS1_OAEP con PyCryptodome\n    try:\n        key = RSA.import_key(public_key_pem)\n        cipher = PKCS1_OAEP.new(key)\n        return cipher.encrypt(plaintext_bytes)\n    except Exception as e2:\n        errors.append(f\"Error con PKCS1_OAEP: {str(e2)}\")\n    # Método 3: cryptography directamente\n    try:\n        from cryptography.hazmat.primitives.asymmetric import padding\n        from cryptography.hazmat.primitives import serialization\n        # Intentar cargar la clave en diferentes formatos\n        try:\n            public_key = serialization.load_pem_public_key(public_key_pem.encode('utf-8'))\n        except Exception:\n            # Intentar con una transformación adicional por si es un formato no estándar\n            modified_pem = public_key_pem.replace(\"-----BEGIN RSA PUBLIC KEY-----\", \n                                                \"-----BEGIN PUBLIC KEY-----\")\n            modified_pem = modified_pem.replace(\"-----END RSA PUBLIC KEY-----\", \n                                              \"-----END PUBLIC KEY-----\")\n            public_key = serialization.load_pem_public_key(modified_pem.encode('utf-8'))\n        encrypted = public_key.encrypt(\n            plaintext_bytes,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None\n            )\n        )\n        return encrypted\n    except Exception as e3:\n        errors.append(f\"Error con cryptography: {str(e3)}\")\n    # Si todos los métodos fallan, lanzar una excepción detallada\n    raise ValueError(f\"No se pudo cifrar con RSA. Errores: {', '.join(errors)}\")",
    "source": "algorithms.asymmetric_encryption.rsa_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_example_with_cryptography: Ejemplo de encriptación RSA utilizando la biblioteca cryptography.\n\nCódigo:\ndef rsa_example_with_cryptography():\n    \"\"\"Ejemplo de encriptación RSA utilizando la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO RSA CON CRYPTOGRAPHY\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048\n    )\n    public_key = private_key.public_key()\n    # Mensaje a encriptar\n    mensaje = \"Este es un mensaje secreto encriptado con RSA\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Encriptar el mensaje con la clave pública\n    ciphertext = public_key.encrypt(\n        mensaje.encode('utf-8'),\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    print(f\"Mensaje encriptado (codificado en base64): {base64.b64encode(ciphertext).decode('utf-8')}\")\n    # Desencriptar el mensaje con la clave privada\n    plaintext = private_key.decrypt(\n        ciphertext,\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print()",
    "source": "algorithms.asymmetric_encryption.rsa_example_with_cryptography",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_example_with_pycryptodome: Ejemplo de encriptación RSA utilizando la biblioteca PyCryptodome.\n\nCódigo:\ndef rsa_example_with_pycryptodome():\n    \"\"\"Ejemplo de encriptación RSA utilizando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO RSA CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    # Mensaje a encriptar\n    mensaje = \"Este es un mensaje secreto encriptado con RSA (PyCryptodome)\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Crear un objeto de cifrado PKCS#1 OAEP\n    cipher_rsa = PKCS1_OAEP.new(public_key)\n    # Encriptar el mensaje\n    ciphertext = cipher_rsa.encrypt(mensaje.encode('utf-8'))\n    print(f\"Mensaje encriptado (codificado en base64): {base64.b64encode(ciphertext).decode('utf-8')}\")\n    # Desencriptar el mensaje\n    cipher_rsa = PKCS1_OAEP.new(private_key)\n    plaintext = cipher_rsa.decrypt(ciphertext)\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print()",
    "source": "algorithms.asymmetric_encryption.rsa_example_with_pycryptodome",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función rsa_sign_verify_example: Ejemplo de firma digital y verificación con RSA.\n\nCódigo:\ndef rsa_sign_verify_example():\n    \"\"\"Ejemplo de firma digital y verificación con RSA.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO DE FIRMA DIGITAL RSA\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048\n    )\n    public_key = private_key.public_key()\n    # Mensaje a firmar\n    mensaje = \"Este mensaje necesita ser autenticado con una firma digital\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Firma digital: se firma el hash del mensaje con la clave privada\n    signature = private_key.sign(\n        mensaje.encode('utf-8'),\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    print(f\"Firma digital (codificada en base64): {base64.b64encode(signature).decode('utf-8')}\")\n    # Verificación: se verifica la firma con la clave pública\n    try:\n        public_key.verify(\n            signature,\n            mensaje.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✅ Verificación exitosa: la firma es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma no es válida\")\n    # Verificar con un mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"\\nIntentando verificar con mensaje alterado: {mensaje_alterado}\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje_alterado.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✅ Verificación exitosa: la firma es válida\")\n    except InvalidSignature:\n        print(\"❌ Verificación fallida: la firma no es válida (esperado, ya que el mensaje fue alterado)\")\n    print()",
    "source": "algorithms.asymmetric_encryption.rsa_sign_verify_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función sanitize_key: Sanitiza una clave para asegurar que esté en formato PEM adecuado.\nManeja múltiples formatos de entrada y corrige problemas comunes.\n\nArgs:\n    key (str): La clave en formato PEM o similar\n\nReturns:\n    str: La clave sanitizada en formato PEM\n\nCódigo:\ndef sanitize_key(key):\n    \"\"\"\n    Sanitiza una clave para asegurar que esté en formato PEM adecuado.\n    Maneja múltiples formatos de entrada y corrige problemas comunes.\n    Args:\n        key (str): La clave en formato PEM o similar\n    Returns:\n        str: La clave sanitizada en formato PEM\n    \"\"\"\n    if not key:\n        return key\n    # Eliminar espacios, tabulaciones y saltos de línea extra\n    key = key.strip()\n    # Si la clave no tiene BEGIN/END, puede que sea solo el cuerpo de la clave\n    if \"BEGIN\" not in key and \"END\" not in key:\n        # Intenta determinar el tipo de clave basado en el contenido\n        is_private = False\n        # Eliminar caracteres no válidos en Base64\n        key = re.sub(r'[^A-Za-z0-9+/=]', '', key)\n        # Intenta decodificar para ver si es una clave privada RSA\n        try:\n            key_bytes = base64.b64decode(key)\n            # Esto es específico para RSA - verificando si parece una clave privada\n            if b'\\x02\\x01\\x00' in key_bytes:\n                is_private = True\n        except:\n            pass  # Ignoramos errores en este intento de detección\n        # Envolver en etiquetas PEM adecuadas\n        if is_private:\n            key = f\"-----BEGIN RSA PRIVATE KEY-----\\n{key}\\n-----END RSA PRIVATE KEY-----\"\n        else:\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{key}\\n-----END PUBLIC KEY-----\"\n    # Normalizar los saltos de línea\n    key = key.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    # Asegurar que las etiquetas BEGIN/END están en líneas separadas\n    key = re.sub(r'(-----BEGIN [^-]+-----)([^\\n])', r'\\1\\n\\2', key)\n    key = re.sub(r'([^\\n])(-----END [^-]+-----)', r'\\1\\n\\2', key)\n    # Formatear correctamente el cuerpo de la clave en bloques de 64 caracteres\n    lines = key.split('\\n')\n    header = None\n    footer = None\n    body_lines = []\n    for i, line in enumerate(lines):\n        if \"BEGIN\" in line:\n            header = line\n        elif \"END\" in line:\n            footer = line\n        elif line.strip():  # Si no es una línea vacía y no es header/footer\n            body_lines.append(line)\n    if header and footer:\n        # Unir todas las líneas del cuerpo y eliminar espacios/caracteres no Base64\n        body = ''.join(body_lines)\n        body = re.sub(r'[^A-Za-z0-9+/=]', '', body)\n        # Reformatear en líneas de 64 caracteres\n        formatted_body = '\\n'.join([body[i:i+64] for i in range(0, len(body), 64)])\n        key = f\"{header}\\n{formatted_body}\\n{footer}\"\n    # Correcciones específicas para problemas conocidos\n    # Problema: Claves PKCS#8 etiquetadas incorrectamente como RSA PRIVATE KEY\n    if \"BEGIN RSA PRIVATE KEY\" in key and \"PRIVATE KEY\" in key:\n        try:\n            # Intentar cargar como PKCS#1\n            key_obj = RSA.import_key(key)\n            # Si llegamos aquí, la clave ya está en formato PKCS#1, no hacemos nada\n        except:\n            # Puede que sea una clave PKCS#8 con etiqueta incorrecta\n            try:\n                # Convertir etiquetas a PKCS#8\n                key = key.replace(\"BEGIN RSA PRIVATE KEY\", \"BEGIN PRIVATE KEY\")\n                key = key.replace(\"END RSA PRIVATE KEY\", \"END PRIVATE KEY\")\n                # Intentar cargar para verificar\n                from cryptography.hazmat.primitives.serialization import load_pem_private_key\n                load_pem_private_key(key.encode(), password=None)\n            except:\n                # Revertir si no funciona\n                key = key.replace(\"BEGIN PRIVATE KEY\", \"BEGIN RSA PRIVATE KEY\")\n                key = key.replace(\"END PRIVATE KEY\", \"END RSA PRIVATE KEY\")\n    return key",
    "source": "algorithms.asymmetric_encryption.sanitize_key",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función save_keys_to_file: Ejemplo de cómo guardar y cargar claves RSA y ECC en archivos.\n\nCódigo:\ndef save_keys_to_file():\n    \"\"\"Ejemplo de cómo guardar y cargar claves RSA y ECC en archivos.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLO DE GUARDAR Y CARGAR CLAVES\")\n    print(\"=\" * 50)\n    # Crear directorio para claves si no existe\n    key_dir = Path(\"keys\")\n    key_dir.mkdir(exist_ok=True)\n    # RSA: Generar y guardar claves\n    print(\"Generando y guardando claves RSA...\")\n    private_key_rsa = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048\n    )\n    public_key_rsa = private_key_rsa.public_key()\n    # Serializar y guardar clave privada RSA\n    with open(key_dir / \"rsa_private.pem\", \"wb\") as f:\n        f.write(private_key_rsa.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption()\n        ))\n    # Serializar y guardar clave pública RSA\n    with open(key_dir / \"rsa_public.pem\", \"wb\") as f:\n        f.write(public_key_rsa.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        ))\n    # ECC: Generar y guardar claves\n    print(\"Generando y guardando claves ECC...\")\n    private_key_ecc = ec.generate_private_key(\n        curve=ec.SECP256R1()\n    )\n    public_key_ecc = private_key_ecc.public_key()\n    # Serializar y guardar clave privada ECC\n    with open(key_dir / \"ecc_private.pem\", \"wb\") as f:\n        f.write(private_key_ecc.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption()\n        ))\n    # Serializar y guardar clave pública ECC\n    with open(key_dir / \"ecc_public.pem\", \"wb\") as f:\n        f.write(public_key_ecc.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        ))\n    print(\"Claves guardadas en el directorio 'keys'\")\n    # Cargar claves y probar encriptación\n    print(\"\\nCargando claves y probando encriptación...\")\n    # Cargar clave privada RSA\n    with open(key_dir / \"rsa_private.pem\", \"rb\") as f:\n        loaded_private_key_rsa = serialization.load_pem_private_key(\n            f.read(),\n            password=None\n        )\n    # Cargar clave pública RSA\n    with open(key_dir / \"rsa_public.pem\", \"rb\") as f:\n        loaded_public_key_rsa = serialization.load_pem_public_key(\n            f.read()\n        )\n    # Probar encriptación y desencriptación con las claves cargadas\n    mensaje = \"Prueba de encriptación con claves cargadas desde archivos\"\n    ciphertext = loaded_public_key_rsa.encrypt(\n        mensaje.encode('utf-8'),\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    plaintext = loaded_private_key_rsa.decrypt(\n        ciphertext,\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n    print(f\"RSA - Mensaje original: {mensaje}\")\n    print(f\"RSA - Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    # Limpiar: eliminar los archivos de claves creados\n    for key_file in key_dir.glob(\"*.pem\"):\n        key_file.unlink()\n    key_dir.rmdir()\n    print(\"\\nArchivos de claves eliminados\")\n    print()",
    "source": "algorithms.asymmetric_encryption.save_keys_to_file",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función secure_key_exchange: Ejemplo de intercambio seguro de claves usando RSA.\n\nCódigo:\ndef secure_key_exchange():\n    \"\"\"Ejemplo de intercambio seguro de claves usando RSA.\"\"\"\n    print(\"=\" * 50)\n    print(\"INTERCAMBIO SEGURO DE CLAVES\")\n    print(\"=\" * 50)\n    print(\"ESCENARIO: Alice quiere enviar un mensaje secreto a Bob\")\n    # Bob genera un par de claves RSA y comparte su clave pública\n    print(\"\\nPASO 1: Bob genera un par de claves RSA\")\n    bob_key = RSA.generate(2048)\n    bob_private_key = bob_key\n    bob_public_key = bob_key.publickey()\n    print(\"Bob genera sus claves:\")\n    print(f\"- Clave privada (mantenida en secreto)\")\n    print(f\"- Clave pública (compartida con Alice)\")\n    # Alice genera una clave simétrica AES\n    print(\"\\nPASO 2: Alice genera una clave AES aleatoria\")\n    alice_aes_key = get_random_bytes(32)\n    print(f\"Alice genera una clave AES: {base64.b64encode(alice_aes_key).decode()[:20]}...\")\n    # Alice encripta la clave AES con la clave pública de Bob\n    print(\"\\nPASO 3: Alice encripta la clave AES con la clave pública de Bob\")\n    cipher_rsa = PKCS1_OAEP.new(bob_public_key)\n    encrypted_aes_key = cipher_rsa.encrypt(alice_aes_key)\n    print(f\"Alice encripta la clave AES: {base64.b64encode(encrypted_aes_key).decode()[:20]}...\")\n    # Alice encripta su mensaje con la clave AES\n    print(\"\\nPASO 4: Alice encripta su mensaje con la clave AES\")\n    mensaje = \"Hola Bob, este es un mensaje muy secreto. Nadie más debería poder leerlo.\"\n    cipher_aes = AES.new(alice_aes_key, AES.MODE_GCM)\n    ciphertext, tag = cipher_aes.encrypt_and_digest(mensaje.encode('utf-8'))\n    nonce = cipher_aes.nonce\n    print(f\"Mensaje original: {mensaje}\")\n    print(f\"Mensaje encriptado: {base64.b64encode(ciphertext).decode()[:20]}...\")\n    # Alice envía a Bob: clave AES encriptada, nonce, tag y mensaje encriptado\n    print(\"\\nPASO 5: Alice envía a Bob los datos encriptados\")\n    print(\"- Clave AES encriptada con RSA\")\n    print(\"- Nonce para AES-GCM\")\n    print(\"- Tag de autenticación\")\n    print(\"- Mensaje encriptado con AES\")\n    # Bob recibe los datos y desencripta la clave AES\n    print(\"\\nPASO 6: Bob desencripta la clave AES con su clave privada\")\n    cipher_rsa = PKCS1_OAEP.new(bob_private_key)\n    decrypted_aes_key = cipher_rsa.decrypt(encrypted_aes_key)\n    print(f\"Bob recupera la clave AES: {base64.b64encode(decrypted_aes_key).decode()[:20]}...\")\n    # Bob desencripta el mensaje\n    print(\"\\nPASO 7: Bob desencripta el mensaje con la clave AES\")\n    cipher_aes = AES.new(decrypted_aes_key, AES.MODE_GCM, nonce=nonce)\n    plaintext = cipher_aes.decrypt_and_verify(ciphertext, tag)\n    print(f\"Bob lee el mensaje: {plaintext.decode('utf-8')}\")\n    print(\"\\nVENTAJAS DE ESTE ENFOQUE:\")\n    print(\"1. La clave simétrica (AES) es generada aleatoriamente para cada mensaje\")\n    print(\"2. Solo Bob puede recuperar la clave AES usando su clave privada\")\n    print(\"3. El mensaje está protegido tanto en confidencialidad como en integridad\")\n    print(\"4. No es necesario un canal seguro previo para compartir claves\")\n    print(\"\\n\")",
    "source": "algorithms.hybrid_encryption.secure_key_exchange",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Módulo algorithms.symmetric_encryption: Ejemplos de encriptación simétrica en Python.\nEste script demuestra el uso de algoritmos de encriptación simétrica como AES.",
    "source": "algorithms.symmetric_encryption",
    "type": "module",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Clase Cipher: Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
    "source": "cryptography.hazmat.primitives.ciphers.base.Cipher",
    "type": "class",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Método Cipher.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(\n        self,\n        algorithm: CipherAlgorithm,\n        mode: Mode,\n        backend: typing.Any = None,\n    ) -> None:\n        if not isinstance(algorithm, CipherAlgorithm):\n            raise TypeError(\"Expected interface of CipherAlgorithm.\")\n        if mode is not None:\n            # mypy needs this assert to narrow the type from our generic\n            # type. Maybe it won't some time in the future.\n            assert isinstance(mode, modes.Mode)\n            mode.validate_for_algorithm(algorithm)\n        self.algorithm = algorithm\n        self.mode = mode",
    "source": "cryptography.hazmat.primitives.ciphers.base.Cipher.__init__",
    "type": "method",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_decrypt_cbc: Descifra un texto cifrado con AES en modo CBC.\n\nArgs:\n    ciphertext_b64: Texto cifrado en base64\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef aes_decrypt_cbc(ciphertext_b64, password):\n    \"\"\"\n    Descifra un texto cifrado con AES en modo CBC.\n    Args:\n        ciphertext_b64: Texto cifrado en base64\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Decodificar de base64\n    ciphertext = base64.b64decode(ciphertext_b64)\n    # Extraer salt, iv y texto cifrado\n    salt = ciphertext[:16]\n    iv = ciphertext[16:32]\n    actual_ciphertext = ciphertext[32:]\n    # Derivar clave\n    key, _, _ = derive_key_and_iv(password, salt)\n    # Descifrar\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    padded_text = cipher.decrypt(actual_ciphertext)\n    text = unpad(padded_text, CryptoAES.block_size)\n    return text.decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_decrypt_cbc",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_decrypt_gcm: Descifra un texto cifrado con AES en modo GCM.\n\nArgs:\n    ciphertext_b64: Texto cifrado en base64\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef aes_decrypt_gcm(ciphertext_b64, password):\n    \"\"\"\n    Descifra un texto cifrado con AES en modo GCM.\n    Args:\n        ciphertext_b64: Texto cifrado en base64\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Decodificar de base64\n    ciphertext = base64.b64decode(ciphertext_b64)\n    # Extraer salt, nonce, tag y texto cifrado\n    salt = ciphertext[:16]\n    nonce = ciphertext[16:28]\n    tag = ciphertext[28:44]\n    actual_ciphertext = ciphertext[44:]\n    # Derivar clave\n    key, _, _ = derive_key_and_iv(password, salt, key_length=32, iv_length=12)\n    # Descifrar\n    cipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    text = cipher.decrypt_and_verify(actual_ciphertext, tag)\n    return text.decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_decrypt_gcm",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_encrypt_cbc: Cifra un texto usando AES en modo CBC.\n\nArgs:\n    text: Texto a cifrar\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto cifrado en base64\n\nCódigo:\ndef aes_encrypt_cbc(text, password):\n    \"\"\"\n    Cifra un texto usando AES en modo CBC.\n    Args:\n        text: Texto a cifrar\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto cifrado en base64\n    \"\"\"\n    # Derivar clave e IV\n    key, iv, salt = derive_key_and_iv(password)\n    # Crear cifrador AES en modo CBC\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    # Cifrar el texto\n    text_bytes = text.encode('utf-8')\n    padded_data = pad(text_bytes, CryptoAES.block_size)\n    ciphertext = cipher.encrypt(padded_data)\n    # Combinar salt + iv + ciphertext y convertir a base64\n    result = salt + iv + ciphertext\n    return base64.b64encode(result).decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_encrypt_cbc",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_encrypt_gcm: Cifra un texto usando AES en modo GCM.\n\nArgs:\n    text: Texto a cifrar\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto cifrado en base64\n\nCódigo:\ndef aes_encrypt_gcm(text, password):\n    \"\"\"\n    Cifra un texto usando AES en modo GCM.\n    Args:\n        text: Texto a cifrar\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto cifrado en base64\n    \"\"\"\n    # Derivar clave y nonce\n    key, nonce, salt = derive_key_and_iv(password, key_length=32, iv_length=12)\n    # Crear cifrador AES en modo GCM\n    cipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    # Cifrar el texto\n    text_bytes = text.encode('utf-8')\n    ciphertext, tag = cipher.encrypt_and_digest(text_bytes)\n    # Combinar salt + nonce + tag + ciphertext y convertir a base64\n    result = salt + nonce + tag + ciphertext\n    return base64.b64encode(result).decode('utf-8')",
    "source": "algorithms.symmetric_encryption.aes_encrypt_gcm",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_example_with_cryptography: Ejemplo de encriptación AES usando la biblioteca cryptography.\n\nCódigo:\ndef aes_example_with_cryptography():\n    \"\"\"Ejemplo de encriptación AES usando la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN AES CON CRYPTOGRAPHY\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar\n    mensaje = \"Este es un mensaje secreto que será encriptado con AES.\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = os.urandom(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un vector de inicialización (IV) aleatorio\n    iv = os.urandom(16)  # AES block size = 16 bytes\n    print(f\"IV (en base64): {base64.b64encode(iv).decode()}\")\n    # Convertir el mensaje a bytes y aplicar padding\n    padder = padding.PKCS7(algorithms.AES.block_size).padder()\n    mensaje_bytes = mensaje.encode('utf-8')\n    padded_data = padder.update(mensaje_bytes) + padder.finalize()\n    # Crear un cifrador AES en modo CBC\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\n    encryptor = cipher.encryptor()\n    # Encriptar el mensaje\n    ciphertext = encryptor.update(padded_data) + encryptor.finalize()\n    print(f\"Mensaje encriptado (en base64): {base64.b64encode(ciphertext).decode()}\")\n    # Desencriptar el mensaje\n    decryptor = cipher.decryptor()\n    padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n    # Quitar el padding\n    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()\n    plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.aes_example_with_cryptography",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_example_with_pycryptodome: Ejemplo de encriptación AES usando la biblioteca PyCryptodome.\n\nCódigo:\ndef aes_example_with_pycryptodome():\n    \"\"\"Ejemplo de encriptación AES usando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN AES CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar\n    mensaje = \"Este es otro mensaje secreto para encriptar con AES usando PyCryptodome.\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = get_random_bytes(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un vector de inicialización (IV) aleatorio\n    iv = get_random_bytes(16)  # AES block size = 16 bytes\n    print(f\"IV (en base64): {base64.b64encode(iv).decode()}\")\n    # Crear un cifrador AES en modo CBC\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    # Encriptar el mensaje (con padding)\n    mensaje_bytes = mensaje.encode('utf-8')\n    padded_data = pad(mensaje_bytes, CryptoAES.block_size)\n    ciphertext = cipher.encrypt(padded_data)\n    print(f\"Mensaje encriptado (en base64): {base64.b64encode(ciphertext).decode()}\")\n    # Desencriptar el mensaje\n    decipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    padded_plaintext = decipher.decrypt(ciphertext)\n    plaintext = unpad(padded_plaintext, CryptoAES.block_size)\n    print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.aes_example_with_pycryptodome",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función aes_gcm_example: Ejemplo de encriptación AES en modo GCM (Galois/Counter Mode) que proporciona autenticación.\n\nCódigo:\ndef aes_gcm_example():\n    \"\"\"Ejemplo de encriptación AES en modo GCM (Galois/Counter Mode) que proporciona autenticación.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN AES-GCM (CON AUTENTICACIÓN)\")\n    print(\"=\" * 50)\n    # Mensaje a encriptar\n    mensaje = \"Mensaje secreto con autenticación usando AES-GCM.\"\n    print(f\"Mensaje original: {mensaje}\")\n    # Datos adicionales autenticados (no encriptados pero autenticados)\n    aad = b\"Datos adicionales autenticados\"\n    print(f\"Datos adicionales: {aad.decode()}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = get_random_bytes(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un nonce aleatorio (similar a un IV pero para GCM)\n    nonce = get_random_bytes(12)  # 12 bytes es el tamaño recomendado para GCM\n    print(f\"Nonce (en base64): {base64.b64encode(nonce).decode()}\")\n    # Crear un cifrador AES en modo GCM\n    cipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    # Añadir los datos adicionales autenticados\n    cipher.update(aad)\n    # Encriptar el mensaje (GCM no requiere padding)\n    mensaje_bytes = mensaje.encode('utf-8')\n    ciphertext, tag = cipher.encrypt_and_digest(mensaje_bytes)\n    print(f\"Mensaje encriptado (en base64): {base64.b64encode(ciphertext).decode()}\")\n    print(f\"Tag de autenticación (en base64): {base64.b64encode(tag).decode()}\")\n    # Desencriptar y verificar el mensaje\n    decipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    decipher.update(aad)\n    try:\n        plaintext = decipher.decrypt_and_verify(ciphertext, tag)\n        print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n        print(\"✓ Autenticación exitosa: El mensaje no ha sido alterado.\")\n    except ValueError:\n        print(\"✗ Error de autenticación: El mensaje o el tag han sido alterados.\")\n    # Demostrar qué sucede si el mensaje es alterado\n    print(\"\\nSimulación de alteración del mensaje:\")\n    # Alterar un byte del mensaje encriptado\n    altered_ciphertext = bytearray(ciphertext)\n    altered_ciphertext[0] = (altered_ciphertext[0] + 1) % 256\n    altered_ciphertext = bytes(altered_ciphertext)\n    # Intentar desencriptar el mensaje alterado\n    decipher = CryptoAES.new(key, CryptoAES.MODE_GCM, nonce=nonce)\n    decipher.update(aad)\n    try:\n        plaintext = decipher.decrypt_and_verify(altered_ciphertext, tag)\n        print(f\"Mensaje desencriptado: {plaintext.decode('utf-8')}\")\n        print(\"✓ Autenticación exitosa: El mensaje no ha sido alterado.\")\n    except ValueError:\n        print(\"✗ Error de autenticación: El mensaje o el tag han sido alterados.\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.aes_gcm_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función derive_key_and_iv: Deriva una clave y un IV a partir de una contraseña.\n\nArgs:\n    password: Contraseña de la que derivar la clave\n    salt: Sal para la derivación (opcional)\n    key_length: Longitud de la clave en bytes\n    iv_length: Longitud del IV en bytes\n    \nReturns:\n    Tuple (clave, iv, salt)\n\nCódigo:\ndef derive_key_and_iv(password, salt=None, key_length=32, iv_length=16):\n    \"\"\"\n    Deriva una clave y un IV a partir de una contraseña.\n    Args:\n        password: Contraseña de la que derivar la clave\n        salt: Sal para la derivación (opcional)\n        key_length: Longitud de la clave en bytes\n        iv_length: Longitud del IV en bytes\n    Returns:\n        Tuple (clave, iv, salt)\n    \"\"\"\n    if salt is None:\n        salt = get_random_bytes(16)\n    d = d_i = b''\n    # Usar PBKDF2 sería mejor, pero esto es más simple para el ejemplo\n    while len(d) < key_length + iv_length:\n        d_i = hashlib.md5(d_i + password.encode('utf-8') + salt).digest()\n        d += d_i\n    key = d[:key_length]\n    iv = d[key_length:key_length + iv_length]\n    return key, iv, salt",
    "source": "algorithms.symmetric_encryption.derive_key_and_iv",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función file_encryption_example: Ejemplo de encriptación de archivos usando AES.\n\nCódigo:\ndef file_encryption_example():\n    \"\"\"Ejemplo de encriptación de archivos usando AES.\"\"\"\n    print(\"=\" * 50)\n    print(\"ENCRIPTACIÓN DE ARCHIVOS CON AES\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"archivo_secreto.txt\"\n    encrypted_filename = \"archivo_secreto.enc\"\n    with open(filename, \"w\") as f:\n        f.write(\"Este es un archivo con información confidencial que necesita ser encriptado.\")\n    print(f\"Archivo creado: {filename}\")\n    # Generar una clave aleatoria de 256 bits (32 bytes)\n    key = get_random_bytes(32)\n    print(f\"Clave (en base64): {base64.b64encode(key).decode()}\")\n    # Generar un vector de inicialización (IV) aleatorio\n    iv = get_random_bytes(16)\n    # Encriptar el archivo\n    cipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n    with open(filename, \"rb\") as file_in:\n        file_data = file_in.read()\n        # Aplicar padding a los datos\n        padded_data = pad(file_data, CryptoAES.block_size)\n        # Encriptar los datos\n        encrypted_data = cipher.encrypt(padded_data)\n        # Guardar IV + datos encriptados\n        with open(encrypted_filename, \"wb\") as file_out:\n            file_out.write(iv + encrypted_data)\n    print(f\"Archivo encriptado guardado como: {encrypted_filename}\")\n    # Desencriptar el archivo\n    decrypted_filename = \"archivo_secreto_decrypted.txt\"\n    with open(encrypted_filename, \"rb\") as file_in:\n        # Leer el IV (primeros 16 bytes)\n        iv = file_in.read(16)\n        # Leer los datos encriptados\n        encrypted_data = file_in.read()\n        # Crear un nuevo cifrador con el mismo IV\n        decipher = CryptoAES.new(key, CryptoAES.MODE_CBC, iv)\n        # Desencriptar los datos\n        padded_data = decipher.decrypt(encrypted_data)\n        # Quitar el padding\n        data = unpad(padded_data, CryptoAES.block_size)\n        # Guardar los datos desencriptados\n        with open(decrypted_filename, \"wb\") as file_out:\n            file_out.write(data)\n    print(f\"Archivo desencriptado guardado como: {decrypted_filename}\")\n    # Mostrar el contenido del archivo desencriptado\n    with open(decrypted_filename, \"r\") as f:\n        content = f.read()\n    print(f\"Contenido del archivo desencriptado: {content}\")\n    # Limpiar: eliminar los archivos de ejemplo\n    os.remove(filename)\n    os.remove(encrypted_filename)\n    os.remove(decrypted_filename)\n    print(f\"Archivos de ejemplo eliminados.\")\n    print(\"\\n\")",
    "source": "algorithms.symmetric_encryption.file_encryption_example",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔒 EJEMPLOS DE ENCRIPTACIÓN SIMÉTRICA EN PYTHON 🔒\\n\")\n    aes_example_with_cryptography()\n    aes_example_with_pycryptodome()\n    aes_gcm_example()\n    file_encryption_example()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"La encriptación simétrica es fundamental para proteger la confidencialidad de los datos.\")\n    print(\"Recuerda:\")\n    print(\"- AES es actualmente el estándar más utilizado y seguro para encriptación simétrica.\")\n    print(\"- El modo GCM proporciona autenticación además de confidencialidad.\")\n    print(\"- La gestión segura de claves es crucial - nunca almacenes claves en texto plano.\")\n    print(\"- El vector de inicialización (IV) debe ser único para cada mensaje con la misma clave.\")\n    print(\"=\" * 50)",
    "source": "algorithms.symmetric_encryption.main",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función pad: Apply standard padding.\n\nArgs:\n  data_to_pad (byte string):\n    The data that needs to be padded.\n  block_size (integer):\n    The block boundary to use for padding. The output length is guaranteed\n    to be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n\nReturn:\n  byte string : the original data with the appropriate padding added at the end.\n\nCódigo:\ndef pad(data_to_pad, block_size, style='pkcs7'):\n    \"\"\"Apply standard padding.\n    Args:\n      data_to_pad (byte string):\n        The data that needs to be padded.\n      block_size (integer):\n        The block boundary to use for padding. The output length is guaranteed\n        to be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n      byte string : the original data with the appropriate padding added at the end.\n    \"\"\"\n    padding_len = block_size-len(data_to_pad)%block_size\n    if style == 'pkcs7':\n        padding = bchr(padding_len)*padding_len\n    elif style == 'x923':\n        padding = bchr(0)*(padding_len-1) + bchr(padding_len)\n    elif style == 'iso7816':\n        padding = bchr(128) + bchr(0)*(padding_len-1)\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return data_to_pad + padding",
    "source": "Crypto.Util.Padding.pad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función triple_des_decrypt: Descifra un texto cifrado con 3DES.\n\nArgs:\n    ciphertext_b64: Texto cifrado en base64\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef triple_des_decrypt(ciphertext_b64, password):\n    \"\"\"\n    Descifra un texto cifrado con 3DES.\n    Args:\n        ciphertext_b64: Texto cifrado en base64\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Decodificar de base64\n    ciphertext = base64.b64decode(ciphertext_b64)\n    # Extraer salt, iv y texto cifrado\n    salt = ciphertext[:16]\n    iv = ciphertext[16:24]\n    actual_ciphertext = ciphertext[24:]\n    # Derivar clave\n    key, _, _ = derive_key_and_iv(password, salt, key_length=24, iv_length=8)\n    # Descifrar\n    cipher = DES3.new(key, DES3.MODE_CBC, iv)\n    padded_text = cipher.decrypt(actual_ciphertext)\n    text = unpad(padded_text, DES3.block_size)\n    return text.decode('utf-8')",
    "source": "algorithms.symmetric_encryption.triple_des_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función triple_des_encrypt: Cifra un texto usando 3DES.\n\nArgs:\n    text: Texto a cifrar\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto cifrado en base64\n\nCódigo:\ndef triple_des_encrypt(text, password):\n    \"\"\"\n    Cifra un texto usando 3DES.\n    Args:\n        text: Texto a cifrar\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto cifrado en base64\n    \"\"\"\n    # Derivar clave e IV (3DES necesita 24 bytes para clave y 8 bytes para IV)\n    key, iv, salt = derive_key_and_iv(password, key_length=24, iv_length=8)\n    # Crear cifrador 3DES en modo CBC\n    cipher = DES3.new(key, DES3.MODE_CBC, iv)\n    # Cifrar el texto\n    text_bytes = text.encode('utf-8')\n    padded_data = pad(text_bytes, DES3.block_size)\n    ciphertext = cipher.encrypt(padded_data)\n    # Combinar salt + iv + ciphertext y convertir a base64\n    result = salt + iv + ciphertext\n    return base64.b64encode(result).decode('utf-8')",
    "source": "algorithms.symmetric_encryption.triple_des_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función unpad: Remove standard padding.\n\nArgs:\n  padded_data (byte string):\n    A piece of data with padding that needs to be stripped.\n  block_size (integer):\n    The block boundary to use for padding. The input length\n    must be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\nReturn:\n    byte string : data without padding.\nRaises:\n  ValueError: if the padding is incorrect.\n\nCódigo:\ndef unpad(padded_data, block_size, style='pkcs7'):\n    \"\"\"Remove standard padding.\n    Args:\n      padded_data (byte string):\n        A piece of data with padding that needs to be stripped.\n      block_size (integer):\n        The block boundary to use for padding. The input length\n        must be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n        byte string : data without padding.\n    Raises:\n      ValueError: if the padding is incorrect.\n    \"\"\"\n    pdata_len = len(padded_data)\n    if pdata_len == 0:\n        raise ValueError(\"Zero-length input cannot be unpadded\")\n    if pdata_len % block_size:\n        raise ValueError(\"Input data is not padded\")\n    if style in ('pkcs7', 'x923'):\n        padding_len = bord(padded_data[-1])\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if style == 'pkcs7':\n            if padded_data[-padding_len:]!=bchr(padding_len)*padding_len:\n                raise ValueError(\"PKCS#7 padding is incorrect.\")\n        else:\n            if padded_data[-padding_len:-1]!=bchr(0)*(padding_len-1):\n                raise ValueError(\"ANSI X.923 padding is incorrect.\")\n    elif style == 'iso7816':\n        padding_len = pdata_len - padded_data.rfind(bchr(128))\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if padding_len>1 and padded_data[1-padding_len:]!=bchr(0)*(padding_len-1):\n            raise ValueError(\"ISO 7816-4 padding is incorrect.\")\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return padded_data[:-padding_len]",
    "source": "Crypto.Util.Padding.unpad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función triple_des_decrypt: Descifra un texto cifrado con 3DES.\n\nArgs:\n    ciphertext_b64: Texto cifrado en base64\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto descifrado\n\nCódigo:\ndef triple_des_decrypt(ciphertext_b64, password):\n    \"\"\"\n    Descifra un texto cifrado con 3DES.\n    Args:\n        ciphertext_b64: Texto cifrado en base64\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto descifrado\n    \"\"\"\n    # Decodificar de base64\n    ciphertext = base64.b64decode(ciphertext_b64)\n    # Extraer salt, iv y texto cifrado\n    salt = ciphertext[:16]\n    iv = ciphertext[16:24]\n    actual_ciphertext = ciphertext[24:]\n    # Derivar clave\n    key, _, _ = derive_key_and_iv(password, salt, key_length=24, iv_length=8)\n    # Descifrar\n    cipher = DES3.new(key, DES3.MODE_CBC, iv)\n    padded_text = cipher.decrypt(actual_ciphertext)\n    text = unpad(padded_text, DES3.block_size)\n    return text.decode('utf-8')",
    "source": "algorithms.symmetric_encryption.triple_des_decrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función triple_des_encrypt: Cifra un texto usando 3DES.\n\nArgs:\n    text: Texto a cifrar\n    password: Contraseña para derivar la clave\n    \nReturns:\n    Texto cifrado en base64\n\nCódigo:\ndef triple_des_encrypt(text, password):\n    \"\"\"\n    Cifra un texto usando 3DES.\n    Args:\n        text: Texto a cifrar\n        password: Contraseña para derivar la clave\n    Returns:\n        Texto cifrado en base64\n    \"\"\"\n    # Derivar clave e IV (3DES necesita 24 bytes para clave y 8 bytes para IV)\n    key, iv, salt = derive_key_and_iv(password, key_length=24, iv_length=8)\n    # Crear cifrador 3DES en modo CBC\n    cipher = DES3.new(key, DES3.MODE_CBC, iv)\n    # Cifrar el texto\n    text_bytes = text.encode('utf-8')\n    padded_data = pad(text_bytes, DES3.block_size)\n    ciphertext = cipher.encrypt(padded_data)\n    # Combinar salt + iv + ciphertext y convertir a base64\n    result = salt + iv + ciphertext\n    return base64.b64encode(result).decode('utf-8')",
    "source": "algorithms.symmetric_encryption.triple_des_encrypt",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Función unpad: Remove standard padding.\n\nArgs:\n  padded_data (byte string):\n    A piece of data with padding that needs to be stripped.\n  block_size (integer):\n    The block boundary to use for padding. The input length\n    must be a multiple of :data:`block_size`.\n  style (string):\n    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\nReturn:\n    byte string : data without padding.\nRaises:\n  ValueError: if the padding is incorrect.\n\nCódigo:\ndef unpad(padded_data, block_size, style='pkcs7'):\n    \"\"\"Remove standard padding.\n    Args:\n      padded_data (byte string):\n        A piece of data with padding that needs to be stripped.\n      block_size (integer):\n        The block boundary to use for padding. The input length\n        must be a multiple of :data:`block_size`.\n      style (string):\n        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n    Return:\n        byte string : data without padding.\n    Raises:\n      ValueError: if the padding is incorrect.\n    \"\"\"\n    pdata_len = len(padded_data)\n    if pdata_len == 0:\n        raise ValueError(\"Zero-length input cannot be unpadded\")\n    if pdata_len % block_size:\n        raise ValueError(\"Input data is not padded\")\n    if style in ('pkcs7', 'x923'):\n        padding_len = bord(padded_data[-1])\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if style == 'pkcs7':\n            if padded_data[-padding_len:]!=bchr(padding_len)*padding_len:\n                raise ValueError(\"PKCS#7 padding is incorrect.\")\n        else:\n            if padded_data[-padding_len:-1]!=bchr(0)*(padding_len-1):\n                raise ValueError(\"ANSI X.923 padding is incorrect.\")\n    elif style == 'iso7816':\n        padding_len = pdata_len - padded_data.rfind(bchr(128))\n        if padding_len<1 or padding_len>min(block_size, pdata_len):\n            raise ValueError(\"Padding is incorrect.\")\n        if padding_len>1 and padded_data[1-padding_len:]!=bchr(0)*(padding_len-1):\n            raise ValueError(\"ISO 7816-4 padding is incorrect.\")\n    else:\n        raise ValueError(\"Unknown padding style\")\n    return padded_data[:-padding_len]",
    "source": "Crypto.Util.Padding.unpad",
    "type": "function",
    "category": "Algoritmos de Criptografía"
  },
  {
    "content": "Módulo hash_and_signatures: Módulo que contiene las funciones de hash y firmas digitales.",
    "source": "hash_and_signatures",
    "type": "module",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Clase InvalidSignature: Common base class for all non-exit exceptions.",
    "source": "cryptography.exceptions.InvalidSignature",
    "type": "class",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Método PBKDF2HMAC.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes,\n        iterations: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n        if not ossl.pbkdf2_hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                \"{} is not supported for PBKDF2 by this backend.\".format(\n                    algorithm.name\n                ),\n                _Reasons.UNSUPPORTED_HASH,\n            )\n        self._used = False\n        self._algorithm = algorithm\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        self._salt = salt\n        self._iterations = iterations",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.__init__",
    "type": "method",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Método PBKDF2HMAC.derive: Deterministically generates and returns a new key based on the existing\nkey material.\n\nCódigo:\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"PBKDF2 instances can only be used once.\")\n        self._used = True\n        return rust_openssl.kdf.derive_pbkdf2_hmac(\n            key_material,\n            self._algorithm,\n            self._salt,\n            self._iterations,\n            self._length,\n        )",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.derive",
    "type": "method",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Método PBKDF2HMAC.verify: Checks whether the key generated by the key material matches the\nexpected derived key. Raises an exception if they do not match.\n\nCódigo:\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.verify",
    "type": "method",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función basic_hash_example: Ejemplo básico de hashing con diferentes algoritmos.\n\nCódigo:\ndef basic_hash_example():\n    \"\"\"Ejemplo básico de hashing con diferentes algoritmos.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLOS BÁSICOS DE FUNCIONES HASH\")\n    print(\"=\" * 50)\n    # Texto de ejemplo\n    texto = \"Hola, este es un ejemplo de texto para hashear.\"\n    print(f\"Texto original: {texto}\")\n    print(\"-\" * 50)\n    # MD5 (No recomendado para uso criptográfico)\n    md5_hash = hashlib.md5(texto.encode()).hexdigest()\n    print(f\"MD5: {md5_hash}\")\n    # SHA-1 (No recomendado para uso criptográfico)\n    sha1_hash = hashlib.sha1(texto.encode()).hexdigest()\n    print(f\"SHA-1: {sha1_hash}\")\n    # SHA-256\n    sha256_hash = hashlib.sha256(texto.encode()).hexdigest()\n    print(f\"SHA-256: {sha256_hash}\")\n    # SHA-512\n    sha512_hash = hashlib.sha512(texto.encode()).hexdigest()\n    print(f\"SHA-512: {sha512_hash}\")\n    # BLAKE2\n    blake2_hash = hashlib.blake2b(texto.encode()).hexdigest()\n    print(f\"BLAKE2b: {blake2_hash}\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.basic_hash_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función basic_salted_hash: Ejemplo básico de hash con salt usando hashlib.\n\nCódigo:\ndef basic_salted_hash():\n    \"\"\"Ejemplo básico de hash con salt usando hashlib.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH CON SALT BÁSICO (HASHLIB)\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un salt aleatorio\n    salt = os.urandom(32)  # 32 bytes = 256 bits\n    print(f\"Salt (en hexadecimal): {binascii.hexlify(salt).decode()}\")\n    # Método 1: Concatenación simple + SHA-256:\n    print(\"\\n1. Concatenación simple + SHA-256:\")\n    salted_password = password.encode() + salt\n    hash_obj = hashlib.sha256(salted_password)\n    password_hash = hash_obj.hexdigest()\n    print(f\"Hash con salt: {password_hash}\")\n    # Método 2: Usar PBKDF2 (Password-Based Key Derivation Function 2)\n    print(\"\\n2. PBKDF2 con HMAC-SHA256:\")\n    # 100,000 iteraciones es un buen punto de partida en 2023\n    iterations = 100000\n    dk = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)\n    password_hash = binascii.hexlify(dk).decode()\n    print(f\"PBKDF2 hash: {password_hash}\")\n    print(f\"Iteraciones: {iterations}\")\n    # Simulación de verificación\n    print(\"\\nVerificación de contraseña:\")\n    # Contraseña correcta\n    test_password = \"mi_contraseña_123\"\n    dk_verify = hashlib.pbkdf2_hmac('sha256', test_password.encode(), salt, iterations)\n    test_hash = binascii.hexlify(dk_verify).decode()\n    if test_hash == password_hash:\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    dk_verify = hashlib.pbkdf2_hmac('sha256', wrong_password.encode(), salt, iterations)\n    wrong_hash = binascii.hexlify(dk_verify).decode()\n    if wrong_hash == password_hash:\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.basic_salted_hash",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función bcrypt_example: Ejemplo de hash de contraseñas usando bcrypt.\n\nCódigo:\ndef bcrypt_example():\n    \"\"\"Ejemplo de hash de contraseñas usando bcrypt.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH DE CONTRASEÑAS CON BCRYPT\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un hash bcrypt\n    # El parámetro rounds determina la complejidad (12 es un buen valor por defecto)\n    rounds = 12\n    start_time = time.time()\n    hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=rounds))\n    end_time = time.time()\n    print(f\"\\nHash bcrypt: {hashed.decode()}\")\n    print(f\"Tiempo de cálculo: {(end_time - start_time):.4f} segundos\")\n    print(f\"Factor de trabajo (rounds): {rounds}\")\n    # Explicar la estructura del hash bcrypt\n    print(\"\\nEstructura del hash bcrypt:\")\n    print(\"- $2b$: Identificador de versión de bcrypt\")\n    print(f\"- $12$: Factor de trabajo (2^{rounds} iteraciones)\")\n    print(\"- 22 caracteres siguientes: Salt codificado en base64\")\n    print(\"- 31 caracteres restantes: Hash codificado en base64\")\n    # Simulación de verificación\n    print(\"\\nVerificación de contraseña:\")\n    # Contraseña correcta\n    test_password = \"mi_contraseña_123\"\n    if bcrypt.checkpw(test_password.encode(), hashed):\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    if bcrypt.checkpw(wrong_password.encode(), hashed):\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    # Demostrar cómo bcrypt ajusta automáticamente la dificultad\n    print(\"\\nAjuste de dificultad en bcrypt:\")\n    for r in [10, 12, 14]:\n        start_time = time.time()\n        bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=r))\n        end_time = time.time()\n        print(f\"rounds={r}: {(end_time - start_time):.4f} segundos\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.bcrypt_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función calculate_hash: Calcula el hash de un texto con el algoritmo especificado.\n\nArgs:\n    text: Texto a hashear\n    algorithm: Algoritmo de hash a utilizar (md5, sha1, sha256, sha384, sha512, blake2b)\n    \nReturns:\n    String con el hash en formato hexadecimal\n\nCódigo:\ndef calculate_hash(text, algorithm='sha256'):\n    \"\"\"\n    Calcula el hash de un texto con el algoritmo especificado.\n    Args:\n        text: Texto a hashear\n        algorithm: Algoritmo de hash a utilizar (md5, sha1, sha256, sha384, sha512, blake2b)\n    Returns:\n        String con el hash en formato hexadecimal\n    \"\"\"\n    if not text:\n        return \"\"\n    text_bytes = text.encode('utf-8')\n    if algorithm == 'md5':\n        hash_obj = hashlib.md5(text_bytes)\n    elif algorithm == 'sha1':\n        hash_obj = hashlib.sha1(text_bytes)\n    elif algorithm == 'sha256':\n        hash_obj = hashlib.sha256(text_bytes)\n    elif algorithm == 'sha384':\n        hash_obj = hashlib.sha384(text_bytes)\n    elif algorithm == 'sha512':\n        hash_obj = hashlib.sha512(text_bytes)\n    elif algorithm == 'blake2b' or algorithm == 'blake2':\n        hash_obj = hashlib.blake2b(text_bytes)\n    else:\n        raise ValueError(f\"Algoritmo de hash no soportado: {algorithm}\")\n    return hash_obj.hexdigest()",
    "source": "hash_and_signatures.hash_functions.calculate_hash",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función compare_signature_algorithms: Comparación de diferentes algoritmos de firma digital.\n\nCódigo:\ndef compare_signature_algorithms():\n    \"\"\"Comparación de diferentes algoritmos de firma digital.\"\"\"\n    print(\"=\" * 50)\n    print(\"COMPARACIÓN DE ALGORITMOS DE FIRMA DIGITAL\")\n    print(\"=\" * 50)\n    # Mensaje a firmar\n    mensaje = \"Este mensaje será firmado con diferentes algoritmos para comparar su rendimiento y tamaño de firma.\"\n    print(f\"Mensaje original ({len(mensaje.encode('utf-8'))} bytes): {mensaje}\")\n    print(\"\\n\" + \"-\" * 40 + \"\\n\")\n    # Generar claves para cada algoritmo\n    rsa_key_2048 = RSA.generate(2048)\n    rsa_key_4096 = RSA.generate(4096)\n    ec_key_p256 = ECC.generate(curve='P-256')\n    ec_key_p384 = ECC.generate(curve='P-384')\n    ec_key_p521 = ECC.generate(curve='P-521')\n    # Calcular hashes con diferentes algoritmos\n    hash_sha256 = SHA256.new(mensaje.encode('utf-8'))\n    hash_sha384 = SHA384.new(mensaje.encode('utf-8'))\n    hash_sha512 = SHA512.new(mensaje.encode('utf-8'))\n    # Tabla de resultados\n    print(\"| Algoritmo          | Tamaño de clave | Tamaño de firma | Tiempo de firma | Tiempo de verificación |\")\n    print(\"|--------------------|-----------------|-----------------|-----------------|-----------------------|\")\n    # RSA-2048 con SHA-256\n    start_time = time.time()\n    signature = pkcs1_15.new(rsa_key_2048).sign(hash_sha256)\n    sign_time = time.time() - start_time\n    start_time = time.time()\n    try:\n        pkcs1_15.new(rsa_key_2048.publickey()).verify(hash_sha256, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| RSA-2048 + SHA-256 | 2048 bits       | {len(signature)} bytes      | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # RSA-4096 con SHA-256\n    start_time = time.time()\n    signature = pkcs1_15.new(rsa_key_4096).sign(hash_sha256)\n    sign_time = time.time() - start_time\n    start_time = time.time()\n    try:\n        pkcs1_15.new(rsa_key_4096.publickey()).verify(hash_sha256, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| RSA-4096 + SHA-256 | 4096 bits       | {len(signature)} bytes      | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # ECDSA P-256 con SHA-256\n    signer = DSS.new(ec_key_p256, 'fips-186-3')\n    start_time = time.time()\n    signature = signer.sign(hash_sha256)\n    sign_time = time.time() - start_time\n    verifier = DSS.new(ec_key_p256.public_key(), 'fips-186-3')\n    start_time = time.time()\n    try:\n        verifier.verify(hash_sha256, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| ECDSA P-256 + SHA-256 | 256 bits      | {len(signature)} bytes       | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # ECDSA P-384 con SHA-384\n    signer = DSS.new(ec_key_p384, 'fips-186-3')\n    start_time = time.time()\n    signature = signer.sign(hash_sha384)\n    sign_time = time.time() - start_time\n    verifier = DSS.new(ec_key_p384.public_key(), 'fips-186-3')\n    start_time = time.time()\n    try:\n        verifier.verify(hash_sha384, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| ECDSA P-384 + SHA-384 | 384 bits      | {len(signature)} bytes       | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # ECDSA P-521 con SHA-512\n    signer = DSS.new(ec_key_p521, 'fips-186-3')\n    start_time = time.time()\n    signature = signer.sign(hash_sha512)\n    sign_time = time.time() - start_time\n    verifier = DSS.new(ec_key_p521.public_key(), 'fips-186-3')\n    start_time = time.time()\n    try:\n        verifier.verify(hash_sha512, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| ECDSA P-521 + SHA-512 | 521 bits      | {len(signature)} bytes       | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    print(\"\\nObservaciones:\")\n    print(\"- RSA produce firmas más grandes que ECDSA\")\n    print(\"- ECDSA es generalmente más rápido que RSA para el mismo nivel de seguridad\")\n    print(\"- El tamaño de la firma ECDSA es aproximadamente el doble del tamaño de la clave\")\n    print(\"- RSA-2048 es aproximadamente equivalente en seguridad a ECDSA P-256\")\n    print(\"- RSA-4096 es aproximadamente equivalente en seguridad a ECDSA P-384/P-521\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.compare_signature_algorithms",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Módulo hash_and_signatures.digital_signatures: Ejemplos de firmas digitales en Python.\nEste script demuestra el uso de diferentes algoritmos para crear y verificar firmas digitales.",
    "source": "hash_and_signatures.digital_signatures",
    "type": "module",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Clase InvalidSignature: Common base class for all non-exit exceptions.",
    "source": "cryptography.exceptions.InvalidSignature",
    "type": "class",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función compare_signature_algorithms: Comparación de diferentes algoritmos de firma digital.\n\nCódigo:\ndef compare_signature_algorithms():\n    \"\"\"Comparación de diferentes algoritmos de firma digital.\"\"\"\n    print(\"=\" * 50)\n    print(\"COMPARACIÓN DE ALGORITMOS DE FIRMA DIGITAL\")\n    print(\"=\" * 50)\n    # Mensaje a firmar\n    mensaje = \"Este mensaje será firmado con diferentes algoritmos para comparar su rendimiento y tamaño de firma.\"\n    print(f\"Mensaje original ({len(mensaje.encode('utf-8'))} bytes): {mensaje}\")\n    print(\"\\n\" + \"-\" * 40 + \"\\n\")\n    # Generar claves para cada algoritmo\n    rsa_key_2048 = RSA.generate(2048)\n    rsa_key_4096 = RSA.generate(4096)\n    ec_key_p256 = ECC.generate(curve='P-256')\n    ec_key_p384 = ECC.generate(curve='P-384')\n    ec_key_p521 = ECC.generate(curve='P-521')\n    # Calcular hashes con diferentes algoritmos\n    hash_sha256 = SHA256.new(mensaje.encode('utf-8'))\n    hash_sha384 = SHA384.new(mensaje.encode('utf-8'))\n    hash_sha512 = SHA512.new(mensaje.encode('utf-8'))\n    # Tabla de resultados\n    print(\"| Algoritmo          | Tamaño de clave | Tamaño de firma | Tiempo de firma | Tiempo de verificación |\")\n    print(\"|--------------------|-----------------|-----------------|-----------------|-----------------------|\")\n    # RSA-2048 con SHA-256\n    start_time = time.time()\n    signature = pkcs1_15.new(rsa_key_2048).sign(hash_sha256)\n    sign_time = time.time() - start_time\n    start_time = time.time()\n    try:\n        pkcs1_15.new(rsa_key_2048.publickey()).verify(hash_sha256, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| RSA-2048 + SHA-256 | 2048 bits       | {len(signature)} bytes      | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # RSA-4096 con SHA-256\n    start_time = time.time()\n    signature = pkcs1_15.new(rsa_key_4096).sign(hash_sha256)\n    sign_time = time.time() - start_time\n    start_time = time.time()\n    try:\n        pkcs1_15.new(rsa_key_4096.publickey()).verify(hash_sha256, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| RSA-4096 + SHA-256 | 4096 bits       | {len(signature)} bytes      | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # ECDSA P-256 con SHA-256\n    signer = DSS.new(ec_key_p256, 'fips-186-3')\n    start_time = time.time()\n    signature = signer.sign(hash_sha256)\n    sign_time = time.time() - start_time\n    verifier = DSS.new(ec_key_p256.public_key(), 'fips-186-3')\n    start_time = time.time()\n    try:\n        verifier.verify(hash_sha256, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| ECDSA P-256 + SHA-256 | 256 bits      | {len(signature)} bytes       | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # ECDSA P-384 con SHA-384\n    signer = DSS.new(ec_key_p384, 'fips-186-3')\n    start_time = time.time()\n    signature = signer.sign(hash_sha384)\n    sign_time = time.time() - start_time\n    verifier = DSS.new(ec_key_p384.public_key(), 'fips-186-3')\n    start_time = time.time()\n    try:\n        verifier.verify(hash_sha384, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| ECDSA P-384 + SHA-384 | 384 bits      | {len(signature)} bytes       | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    # ECDSA P-521 con SHA-512\n    signer = DSS.new(ec_key_p521, 'fips-186-3')\n    start_time = time.time()\n    signature = signer.sign(hash_sha512)\n    sign_time = time.time() - start_time\n    verifier = DSS.new(ec_key_p521.public_key(), 'fips-186-3')\n    start_time = time.time()\n    try:\n        verifier.verify(hash_sha512, signature)\n        verify_result = \"✓\"\n    except:\n        verify_result = \"✗\"\n    verify_time = time.time() - start_time\n    print(f\"| ECDSA P-521 + SHA-512 | 521 bits      | {len(signature)} bytes       | {sign_time:.6f} s     | {verify_time:.6f} s {verify_result}         |\")\n    print(\"\\nObservaciones:\")\n    print(\"- RSA produce firmas más grandes que ECDSA\")\n    print(\"- ECDSA es generalmente más rápido que RSA para el mismo nivel de seguridad\")\n    print(\"- El tamaño de la firma ECDSA es aproximadamente el doble del tamaño de la clave\")\n    print(\"- RSA-2048 es aproximadamente equivalente en seguridad a ECDSA P-256\")\n    print(\"- RSA-4096 es aproximadamente equivalente en seguridad a ECDSA P-384/P-521\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.compare_signature_algorithms",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función ecdsa_signature: Ejemplo de firma digital ECDSA (Elliptic Curve Digital Signature Algorithm).\n\nCódigo:\ndef ecdsa_signature():\n    \"\"\"Ejemplo de firma digital ECDSA (Elliptic Curve Digital Signature Algorithm).\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL ECDSA\")\n    print(\"=\" * 50)\n    # Generar un par de claves ECC (Elliptic Curve Cryptography)\n    key = ECC.generate(curve='P-256')\n    print(\"Par de claves ECC generado:\")\n    print(f\"- Curva: NIST P-256\")\n    print(f\"- Tamaño de clave: 256 bits\")\n    # Mensaje a firmar\n    mensaje = \"Este mensaje será firmado con ECDSA, que es más eficiente que RSA.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Calcular el hash del mensaje\n    h = SHA256.new(mensaje.encode('utf-8'))\n    # Crear un objeto de firma\n    signer = DSS.new(key, 'fips-186-3')\n    # Medir el tiempo de firma\n    start_time = time.time()\n    signature = signer.sign(h)\n    end_time = time.time()\n    print(f\"Firma digital (en base64): {base64.b64encode(signature).decode()[:50]}...\")\n    print(f\"Tiempo de firma: {(end_time - start_time):.6f} segundos\")\n    # Verificar la firma con la clave pública\n    public_key = key.public_key()\n    print(\"\\nVerificación de la firma:\")\n    # Medir el tiempo de verificación\n    start_time = time.time()\n    try:\n        # Calcular el hash del mensaje recibido\n        h = SHA256.new(mensaje.encode('utf-8'))\n        # Crear un objeto de verificación\n        verifier = DSS.new(public_key, 'fips-186-3')\n        # Verificar la firma\n        verifier.verify(h, signature)\n        end_time = time.time()\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n        print(f\"Tiempo de verificación: {(end_time - start_time):.6f} segundos\")\n    except (ValueError, TypeError):\n        end_time = time.time()\n        print(\"✗ Firma inválida: El mensaje puede haber sido alterado.\")\n        print(f\"Tiempo de verificación: {(end_time - start_time):.6f} segundos\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.ecdsa_signature",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función file_signature_example: Ejemplo de firma digital para archivos.\n\nCódigo:\ndef file_signature_example():\n    \"\"\"Ejemplo de firma digital para archivos.\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL DE ARCHIVOS\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"documento_importante.txt\"\n    signature_filename = \"documento_importante.sig\"\n    with open(filename, \"w\") as f:\n        f.write(\"\"\"DOCUMENTO IMPORTANTE\nEste es un documento importante cuya autenticidad e integridad\nnecesita ser verificada. La firma digital nos permite asegurar\nque el documento no ha sido alterado y que fue firmado por el\nemisor legítimo.\nLas firmas digitales son ampliamente utilizadas en documentos\nlegales, actualizaciones de software, certificados digitales,\ny muchas otras aplicaciones donde la autenticidad es crucial.\n\"\"\")\n    print(f\"Archivo creado: {filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 1: Generar un par de claves RSA\")\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    print(f\"Par de claves RSA generado (2048 bits)\")\n    # Guardar la clave pública para verificación posterior\n    public_key_filename = \"public_key.pem\"\n    with open(public_key_filename, \"wb\") as f:\n        f.write(public_key.export_key('PEM'))\n    print(f\"Clave pública guardada en: {public_key_filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 2: Calcular el hash del archivo\")\n    # Calcular el hash SHA-256 del archivo\n    with open(filename, \"rb\") as f:\n        file_data = f.read()\n        file_hash = SHA256.new(file_data)\n    print(f\"Hash SHA-256 del archivo: {file_hash.hexdigest()}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 3: Firmar el hash con la clave privada\")\n    # Firmar el hash con la clave privada\n    signature = pkcs1_15.new(private_key).sign(file_hash)\n    # Guardar la firma en un archivo\n    with open(signature_filename, \"wb\") as f:\n        f.write(signature)\n    print(f\"Firma digital guardada en: {signature_filename}\")\n    print(f\"Tamaño de la firma: {len(signature)} bytes\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 4: Verificar la firma\")\n    # Cargar la clave pública\n    with open(public_key_filename, \"rb\") as f:\n        public_key_data = f.read()\n        loaded_public_key = RSA.import_key(public_key_data)\n    # Cargar la firma\n    with open(signature_filename, \"rb\") as f:\n        loaded_signature = f.read()\n    # Calcular el hash del archivo a verificar\n    with open(filename, \"rb\") as f:\n        file_data = f.read()\n        file_hash = SHA256.new(file_data)\n    # Verificar la firma\n    try:\n        pkcs1_15.new(loaded_public_key).verify(file_hash, loaded_signature)\n        print(\"✓ Firma válida: El archivo es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El archivo puede haber sido alterado.\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 5: Simular alteración del archivo\")\n    # Crear una versión alterada del archivo\n    altered_filename = \"documento_importante_alterado.txt\"\n    with open(filename, \"r\") as f:\n        content = f.read()\n    # Modificar el contenido\n    altered_content = content.replace(\"importante\", \"modificado\")\n    with open(altered_filename, \"w\") as f:\n        f.write(altered_content)\n    print(f\"Archivo alterado creado: {altered_filename}\")\n    # Calcular el hash del archivo alterado\n    with open(altered_filename, \"rb\") as f:\n        altered_file_data = f.read()\n        altered_file_hash = SHA256.new(altered_file_data)\n    print(f\"Hash SHA-256 del archivo alterado: {altered_file_hash.hexdigest()}\")\n    # Verificar la firma con el archivo alterado\n    try:\n        pkcs1_15.new(loaded_public_key).verify(altered_file_hash, loaded_signature)\n        print(\"✓ Firma válida: El archivo es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El archivo ha sido alterado.\")\n    # Limpiar: eliminar los archivos de ejemplo\n    os.remove(filename)\n    os.remove(signature_filename)\n    os.remove(public_key_filename)\n    os.remove(altered_filename)\n    print(f\"Archivos de ejemplo eliminados.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.file_signature_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔏 EJEMPLOS DE FIRMAS DIGITALES EN PYTHON 🔏\\n\")\n    rsa_signature_with_cryptography()\n    rsa_signature_with_pycryptodome()\n    ecdsa_signature()\n    compare_signature_algorithms()\n    file_signature_example()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"Las firmas digitales son fundamentales para garantizar la autenticidad e integridad de los datos.\")\n    print(\"Recuerda:\")\n    print(\"- La firma digital se crea con la clave privada del emisor\")\n    print(\"- La verificación se realiza con la clave pública del emisor\")\n    print(\"- RSA y ECDSA son los algoritmos de firma más utilizados\")\n    print(\"- ECDSA ofrece firmas más pequeñas y mayor eficiencia que RSA\")\n    print(\"- Las firmas digitales son la base de los certificados digitales, blockchain y más\")\n    print(\"=\" * 50)",
    "source": "hash_and_signatures.digital_signatures.main",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función rsa_signature_with_cryptography: Ejemplo de firma digital RSA usando la biblioteca cryptography.\n\nCódigo:\ndef rsa_signature_with_cryptography():\n    \"\"\"Ejemplo de firma digital RSA usando la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL RSA CON CRYPTOGRAPHY\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n    )\n    public_key = private_key.public_key()\n    print(\"Par de claves RSA generado:\")\n    print(f\"- Tamaño de clave: 2048 bits\")\n    print(f\"- Exponente público: 65537\")\n    # Mensaje a firmar\n    mensaje = \"Este mensaje será firmado digitalmente para verificar su autenticidad e integridad.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Firmar el mensaje\n    signature = private_key.sign(\n        mensaje.encode('utf-8'),\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    print(f\"Firma digital (en base64): {base64.b64encode(signature).decode()[:50]}...\")\n    # Verificar la firma\n    print(\"\\nVerificación de la firma:\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except InvalidSignature:\n        print(\"✗ Firma inválida: El mensaje puede haber sido alterado.\")\n    # Demostrar qué sucede si el mensaje es alterado\n    print(\"\\nSimulación de alteración del mensaje:\")\n    # Mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"Mensaje alterado: {mensaje_alterado}\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje_alterado.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except InvalidSignature:\n        print(\"✗ Firma inválida: El mensaje ha sido alterado.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.rsa_signature_with_cryptography",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función rsa_signature_with_pycryptodome: Ejemplo de firma digital RSA usando la biblioteca PyCryptodome.\n\nCódigo:\ndef rsa_signature_with_pycryptodome():\n    \"\"\"Ejemplo de firma digital RSA usando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL RSA CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    print(\"Par de claves RSA generado:\")\n    print(f\"- Tamaño de clave: {key.size_in_bits()} bits\")\n    print(f\"- Exponente público: {key.e}\")\n    # Mensaje a firmar\n    mensaje = \"Este es otro mensaje para firmar con RSA usando PyCryptodome.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Calcular el hash del mensaje\n    h = SHA256.new(mensaje.encode('utf-8'))\n    # Firmar el hash con la clave privada\n    signature = pkcs1_15.new(key).sign(h)\n    print(f\"Firma digital (en base64): {base64.b64encode(signature).decode()[:50]}...\")\n    # Verificar la firma con la clave pública\n    public_key = key.publickey()\n    print(\"\\nVerificación de la firma:\")\n    try:\n        # Calcular el hash del mensaje recibido\n        h = SHA256.new(mensaje.encode('utf-8'))\n        # Verificar la firma\n        pkcs1_15.new(public_key).verify(h, signature)\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El mensaje puede haber sido alterado.\")\n    # Demostrar qué sucede si el mensaje es alterado\n    print(\"\\nSimulación de alteración del mensaje:\")\n    # Mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"Mensaje alterado: {mensaje_alterado}\")\n    try:\n        # Calcular el hash del mensaje alterado\n        h = SHA256.new(mensaje_alterado.encode('utf-8'))\n        # Verificar la firma con el mensaje alterado\n        pkcs1_15.new(public_key).verify(h, signature)\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El mensaje ha sido alterado.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.rsa_signature_with_pycryptodome",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función sign_verify_message: Firma o verifica un mensaje usando RSA con SHA-256.\n\nArgs:\n    message: Mensaje a firmar o verificar\n    key: Clave privada (para firmar) o pública (para verificar)\n    action: 'sign', 'verify' o 'generate_keys'\n    signature: Firma a verificar (solo para action='verify')\n    \nReturns:\n    Depende de la acción:\n    - 'generate_keys': (public_key, private_key)\n    - 'sign': firma en formato base64\n    - 'verify': True si la firma es válida, False en caso contrario\n\nCódigo:\ndef sign_verify_message(message, key, action='sign', signature=None):\n    \"\"\"\n    Firma o verifica un mensaje usando RSA con SHA-256.\n    Args:\n        message: Mensaje a firmar o verificar\n        key: Clave privada (para firmar) o pública (para verificar)\n        action: 'sign', 'verify' o 'generate_keys'\n        signature: Firma a verificar (solo para action='verify')\n    Returns:\n        Depende de la acción:\n        - 'generate_keys': (public_key, private_key)\n        - 'sign': firma en formato base64\n        - 'verify': True si la firma es válida, False en caso contrario\n    \"\"\"\n    if action == 'generate_keys':\n        # Generar par de claves RSA\n        key_obj = RSA.generate(2048)\n        private_key = key_obj.export_key().decode('utf-8')\n        public_key = key_obj.publickey().export_key().decode('utf-8')\n        return public_key, private_key\n    elif action == 'sign':\n        # Importar clave privada\n        if isinstance(key, str):\n            key_obj = RSA.import_key(key)\n        else:\n            key_obj = key\n        # Calcular el hash del mensaje\n        h = SHA256.new(message.encode('utf-8'))\n        # Firmar el hash con la clave privada\n        signature = pkcs1_15.new(key_obj).sign(h)\n        # Convertir a base64 para transmisión web\n        return base64.b64encode(signature).decode('utf-8')\n    elif action == 'verify':\n        # Importar clave pública\n        if isinstance(key, str):\n            key_obj = RSA.import_key(key)\n        else:\n            key_obj = key\n        # Calcular el hash del mensaje\n        h = SHA256.new(message.encode('utf-8'))\n        try:\n            # Decodificar la firma de base64\n            signature_bytes = base64.b64decode(signature)\n            # Verificar la firma\n            pkcs1_15.new(key_obj).verify(h, signature_bytes)\n            return True\n        except:\n            return False\n    else:\n        raise ValueError(f\"Acción no reconocida: {action}\")",
    "source": "hash_and_signatures.digital_signatures.sign_verify_message",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función ecdsa_signature: Ejemplo de firma digital ECDSA (Elliptic Curve Digital Signature Algorithm).\n\nCódigo:\ndef ecdsa_signature():\n    \"\"\"Ejemplo de firma digital ECDSA (Elliptic Curve Digital Signature Algorithm).\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL ECDSA\")\n    print(\"=\" * 50)\n    # Generar un par de claves ECC (Elliptic Curve Cryptography)\n    key = ECC.generate(curve='P-256')\n    print(\"Par de claves ECC generado:\")\n    print(f\"- Curva: NIST P-256\")\n    print(f\"- Tamaño de clave: 256 bits\")\n    # Mensaje a firmar\n    mensaje = \"Este mensaje será firmado con ECDSA, que es más eficiente que RSA.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Calcular el hash del mensaje\n    h = SHA256.new(mensaje.encode('utf-8'))\n    # Crear un objeto de firma\n    signer = DSS.new(key, 'fips-186-3')\n    # Medir el tiempo de firma\n    start_time = time.time()\n    signature = signer.sign(h)\n    end_time = time.time()\n    print(f\"Firma digital (en base64): {base64.b64encode(signature).decode()[:50]}...\")\n    print(f\"Tiempo de firma: {(end_time - start_time):.6f} segundos\")\n    # Verificar la firma con la clave pública\n    public_key = key.public_key()\n    print(\"\\nVerificación de la firma:\")\n    # Medir el tiempo de verificación\n    start_time = time.time()\n    try:\n        # Calcular el hash del mensaje recibido\n        h = SHA256.new(mensaje.encode('utf-8'))\n        # Crear un objeto de verificación\n        verifier = DSS.new(public_key, 'fips-186-3')\n        # Verificar la firma\n        verifier.verify(h, signature)\n        end_time = time.time()\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n        print(f\"Tiempo de verificación: {(end_time - start_time):.6f} segundos\")\n    except (ValueError, TypeError):\n        end_time = time.time()\n        print(\"✗ Firma inválida: El mensaje puede haber sido alterado.\")\n        print(f\"Tiempo de verificación: {(end_time - start_time):.6f} segundos\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.ecdsa_signature",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función file_signature_example: Ejemplo de firma digital para archivos.\n\nCódigo:\ndef file_signature_example():\n    \"\"\"Ejemplo de firma digital para archivos.\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL DE ARCHIVOS\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"documento_importante.txt\"\n    signature_filename = \"documento_importante.sig\"\n    with open(filename, \"w\") as f:\n        f.write(\"\"\"DOCUMENTO IMPORTANTE\nEste es un documento importante cuya autenticidad e integridad\nnecesita ser verificada. La firma digital nos permite asegurar\nque el documento no ha sido alterado y que fue firmado por el\nemisor legítimo.\nLas firmas digitales son ampliamente utilizadas en documentos\nlegales, actualizaciones de software, certificados digitales,\ny muchas otras aplicaciones donde la autenticidad es crucial.\n\"\"\")\n    print(f\"Archivo creado: {filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 1: Generar un par de claves RSA\")\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    private_key = key\n    public_key = key.publickey()\n    print(f\"Par de claves RSA generado (2048 bits)\")\n    # Guardar la clave pública para verificación posterior\n    public_key_filename = \"public_key.pem\"\n    with open(public_key_filename, \"wb\") as f:\n        f.write(public_key.export_key('PEM'))\n    print(f\"Clave pública guardada en: {public_key_filename}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 2: Calcular el hash del archivo\")\n    # Calcular el hash SHA-256 del archivo\n    with open(filename, \"rb\") as f:\n        file_data = f.read()\n        file_hash = SHA256.new(file_data)\n    print(f\"Hash SHA-256 del archivo: {file_hash.hexdigest()}\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 3: Firmar el hash con la clave privada\")\n    # Firmar el hash con la clave privada\n    signature = pkcs1_15.new(private_key).sign(file_hash)\n    # Guardar la firma en un archivo\n    with open(signature_filename, \"wb\") as f:\n        f.write(signature)\n    print(f\"Firma digital guardada en: {signature_filename}\")\n    print(f\"Tamaño de la firma: {len(signature)} bytes\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 4: Verificar la firma\")\n    # Cargar la clave pública\n    with open(public_key_filename, \"rb\") as f:\n        public_key_data = f.read()\n        loaded_public_key = RSA.import_key(public_key_data)\n    # Cargar la firma\n    with open(signature_filename, \"rb\") as f:\n        loaded_signature = f.read()\n    # Calcular el hash del archivo a verificar\n    with open(filename, \"rb\") as f:\n        file_data = f.read()\n        file_hash = SHA256.new(file_data)\n    # Verificar la firma\n    try:\n        pkcs1_15.new(loaded_public_key).verify(file_hash, loaded_signature)\n        print(\"✓ Firma válida: El archivo es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El archivo puede haber sido alterado.\")\n    print(\"\\n\" + \"-\" * 50 + \"\\n\")\n    print(\"PASO 5: Simular alteración del archivo\")\n    # Crear una versión alterada del archivo\n    altered_filename = \"documento_importante_alterado.txt\"\n    with open(filename, \"r\") as f:\n        content = f.read()\n    # Modificar el contenido\n    altered_content = content.replace(\"importante\", \"modificado\")\n    with open(altered_filename, \"w\") as f:\n        f.write(altered_content)\n    print(f\"Archivo alterado creado: {altered_filename}\")\n    # Calcular el hash del archivo alterado\n    with open(altered_filename, \"rb\") as f:\n        altered_file_data = f.read()\n        altered_file_hash = SHA256.new(altered_file_data)\n    print(f\"Hash SHA-256 del archivo alterado: {altered_file_hash.hexdigest()}\")\n    # Verificar la firma con el archivo alterado\n    try:\n        pkcs1_15.new(loaded_public_key).verify(altered_file_hash, loaded_signature)\n        print(\"✓ Firma válida: El archivo es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El archivo ha sido alterado.\")\n    # Limpiar: eliminar los archivos de ejemplo\n    os.remove(filename)\n    os.remove(signature_filename)\n    os.remove(public_key_filename)\n    os.remove(altered_filename)\n    print(f\"Archivos de ejemplo eliminados.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.file_signature_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función hash_collision_demo: Demostración del efecto avalancha (pequeños cambios causan grandes diferencias en el hash).\n\nCódigo:\ndef hash_collision_demo():\n    \"\"\"Demostración del efecto avalancha (pequeños cambios causan grandes diferencias en el hash).\"\"\"\n    print(\"=\" * 50)\n    print(\"DEMOSTRACIÓN DEL EFECTO AVALANCHA\")\n    print(\"=\" * 50)\n    texto1 = \"Este es un texto de ejemplo.\"\n    texto2 = \"Este es un texto de ejempla.\"  # Solo cambia la última letra\n    print(f\"Texto 1: {texto1}\")\n    print(f\"Texto 2: {texto2}\")\n    print(\"-\" * 50)\n    # Calcular hashes SHA-256\n    hash1 = hashlib.sha256(texto1.encode()).hexdigest()\n    hash2 = hashlib.sha256(texto2.encode()).hexdigest()\n    print(f\"Hash SHA-256 del Texto 1: {hash1}\")\n    print(f\"Hash SHA-256 del Texto 2: {hash2}\")\n    # Contar cuántos caracteres son diferentes\n    diff_count = sum(1 for a, b in zip(hash1, hash2) if a != b)\n    diff_percentage = (diff_count / len(hash1)) * 100\n    print(f\"\\nDiferencia: {diff_count} de {len(hash1)} caracteres ({diff_percentage:.2f}%)\")\n    print(\"Esto demuestra cómo un pequeño cambio en la entrada produce un hash completamente diferente.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.hash_collision_demo",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función hash_file_example: Ejemplo de cómo calcular el hash de un archivo.\n\nCódigo:\ndef hash_file_example():\n    \"\"\"Ejemplo de cómo calcular el hash de un archivo.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH DE ARCHIVOS\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"archivo_ejemplo.txt\"\n    with open(filename, \"w\") as f:\n        f.write(\"Este es un archivo de ejemplo para demostrar el hash de archivos.\")\n    print(f\"Archivo creado: {filename}\")\n    # Calcular hash SHA-256 del archivo\n    sha256_hash = hashlib.sha256()\n    with open(filename, \"rb\") as f:\n        # Leer el archivo en bloques de 4K\n        for byte_block in iter(lambda: f.read(4096), b\"\"):\n            sha256_hash.update(byte_block)\n    print(f\"SHA-256 del archivo: {sha256_hash.hexdigest()}\")\n    # Limpiar: eliminar el archivo de ejemplo\n    os.remove(filename)\n    print(f\"Archivo {filename} eliminado.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.hash_file_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Módulo hash_and_signatures.hash_functions: Ejemplos de funciones hash en Python.\nEste script demuestra el uso de diferentes algoritmos hash disponibles en Python.",
    "source": "hash_and_signatures.hash_functions",
    "type": "module",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función basic_hash_example: Ejemplo básico de hashing con diferentes algoritmos.\n\nCódigo:\ndef basic_hash_example():\n    \"\"\"Ejemplo básico de hashing con diferentes algoritmos.\"\"\"\n    print(\"=\" * 50)\n    print(\"EJEMPLOS BÁSICOS DE FUNCIONES HASH\")\n    print(\"=\" * 50)\n    # Texto de ejemplo\n    texto = \"Hola, este es un ejemplo de texto para hashear.\"\n    print(f\"Texto original: {texto}\")\n    print(\"-\" * 50)\n    # MD5 (No recomendado para uso criptográfico)\n    md5_hash = hashlib.md5(texto.encode()).hexdigest()\n    print(f\"MD5: {md5_hash}\")\n    # SHA-1 (No recomendado para uso criptográfico)\n    sha1_hash = hashlib.sha1(texto.encode()).hexdigest()\n    print(f\"SHA-1: {sha1_hash}\")\n    # SHA-256\n    sha256_hash = hashlib.sha256(texto.encode()).hexdigest()\n    print(f\"SHA-256: {sha256_hash}\")\n    # SHA-512\n    sha512_hash = hashlib.sha512(texto.encode()).hexdigest()\n    print(f\"SHA-512: {sha512_hash}\")\n    # BLAKE2\n    blake2_hash = hashlib.blake2b(texto.encode()).hexdigest()\n    print(f\"BLAKE2b: {blake2_hash}\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.basic_hash_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función calculate_hash: Calcula el hash de un texto con el algoritmo especificado.\n\nArgs:\n    text: Texto a hashear\n    algorithm: Algoritmo de hash a utilizar (md5, sha1, sha256, sha384, sha512, blake2b)\n    \nReturns:\n    String con el hash en formato hexadecimal\n\nCódigo:\ndef calculate_hash(text, algorithm='sha256'):\n    \"\"\"\n    Calcula el hash de un texto con el algoritmo especificado.\n    Args:\n        text: Texto a hashear\n        algorithm: Algoritmo de hash a utilizar (md5, sha1, sha256, sha384, sha512, blake2b)\n    Returns:\n        String con el hash en formato hexadecimal\n    \"\"\"\n    if not text:\n        return \"\"\n    text_bytes = text.encode('utf-8')\n    if algorithm == 'md5':\n        hash_obj = hashlib.md5(text_bytes)\n    elif algorithm == 'sha1':\n        hash_obj = hashlib.sha1(text_bytes)\n    elif algorithm == 'sha256':\n        hash_obj = hashlib.sha256(text_bytes)\n    elif algorithm == 'sha384':\n        hash_obj = hashlib.sha384(text_bytes)\n    elif algorithm == 'sha512':\n        hash_obj = hashlib.sha512(text_bytes)\n    elif algorithm == 'blake2b' or algorithm == 'blake2':\n        hash_obj = hashlib.blake2b(text_bytes)\n    else:\n        raise ValueError(f\"Algoritmo de hash no soportado: {algorithm}\")\n    return hash_obj.hexdigest()",
    "source": "hash_and_signatures.hash_functions.calculate_hash",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función hash_collision_demo: Demostración del efecto avalancha (pequeños cambios causan grandes diferencias en el hash).\n\nCódigo:\ndef hash_collision_demo():\n    \"\"\"Demostración del efecto avalancha (pequeños cambios causan grandes diferencias en el hash).\"\"\"\n    print(\"=\" * 50)\n    print(\"DEMOSTRACIÓN DEL EFECTO AVALANCHA\")\n    print(\"=\" * 50)\n    texto1 = \"Este es un texto de ejemplo.\"\n    texto2 = \"Este es un texto de ejempla.\"  # Solo cambia la última letra\n    print(f\"Texto 1: {texto1}\")\n    print(f\"Texto 2: {texto2}\")\n    print(\"-\" * 50)\n    # Calcular hashes SHA-256\n    hash1 = hashlib.sha256(texto1.encode()).hexdigest()\n    hash2 = hashlib.sha256(texto2.encode()).hexdigest()\n    print(f\"Hash SHA-256 del Texto 1: {hash1}\")\n    print(f\"Hash SHA-256 del Texto 2: {hash2}\")\n    # Contar cuántos caracteres son diferentes\n    diff_count = sum(1 for a, b in zip(hash1, hash2) if a != b)\n    diff_percentage = (diff_count / len(hash1)) * 100\n    print(f\"\\nDiferencia: {diff_count} de {len(hash1)} caracteres ({diff_percentage:.2f}%)\")\n    print(\"Esto demuestra cómo un pequeño cambio en la entrada produce un hash completamente diferente.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.hash_collision_demo",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función hash_file_example: Ejemplo de cómo calcular el hash de un archivo.\n\nCódigo:\ndef hash_file_example():\n    \"\"\"Ejemplo de cómo calcular el hash de un archivo.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH DE ARCHIVOS\")\n    print(\"=\" * 50)\n    # Crear un archivo de ejemplo\n    filename = \"archivo_ejemplo.txt\"\n    with open(filename, \"w\") as f:\n        f.write(\"Este es un archivo de ejemplo para demostrar el hash de archivos.\")\n    print(f\"Archivo creado: {filename}\")\n    # Calcular hash SHA-256 del archivo\n    sha256_hash = hashlib.sha256()\n    with open(filename, \"rb\") as f:\n        # Leer el archivo en bloques de 4K\n        for byte_block in iter(lambda: f.read(4096), b\"\"):\n            sha256_hash.update(byte_block)\n    print(f\"SHA-256 del archivo: {sha256_hash.hexdigest()}\")\n    # Limpiar: eliminar el archivo de ejemplo\n    os.remove(filename)\n    print(f\"Archivo {filename} eliminado.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.hash_file_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función hash_with_salt_example: Ejemplo de hash con salt para mayor seguridad.\n\nCódigo:\ndef hash_with_salt_example():\n    \"\"\"Ejemplo de hash con salt para mayor seguridad.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH CON SALT\")\n    print(\"=\" * 50)\n    password = \"mi_contraseña_secreta\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un salt aleatorio\n    salt = os.urandom(16)  # 16 bytes = 128 bits\n    print(f\"Salt (en hexadecimal): {binascii.hexlify(salt).decode()}\")\n    # Combinar password y salt, luego hashear\n    salted_password = password.encode() + salt\n    hash_obj = hashlib.sha256(salted_password)\n    password_hash = hash_obj.hexdigest()\n    print(f\"Hash con salt: {password_hash}\")\n    # Simulación de verificación\n    print(\"\\nVerificación de contraseña:\")\n    # Contraseña correcta\n    test_password = \"mi_contraseña_secreta\"\n    test_salted = test_password.encode() + salt\n    test_hash = hashlib.sha256(test_salted).hexdigest()\n    if test_hash == password_hash:\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    wrong_salted = wrong_password.encode() + salt\n    wrong_hash = hashlib.sha256(wrong_salted).hexdigest()\n    if wrong_hash == password_hash:\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.hash_with_salt_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔐 EJEMPLOS DE FUNCIONES HASH EN PYTHON 🔐\\n\")\n    basic_hash_example()\n    hash_file_example()\n    hash_with_salt_example()\n    hash_collision_demo()\n    pycrypto_hash_example()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"Las funciones hash son fundamentales en la seguridad informática.\")\n    print(\"Recuerda:\")\n    print(\"- MD5 y SHA-1 ya no se consideran seguros para aplicaciones criptográficas.\")\n    print(\"- Siempre usa salt al hashear contraseñas.\")\n    print(\"- Para contraseñas, considera usar funciones especializadas como bcrypt, Argon2 o PBKDF2.\")\n    print(\"- El efecto avalancha es una propiedad deseable en las funciones hash.\")\n    print(\"=\" * 50)",
    "source": "hash_and_signatures.hash_functions.main",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función pycrypto_hash_example: Ejemplo usando la biblioteca PyCryptodome.\n\nCódigo:\ndef pycrypto_hash_example():\n    \"\"\"Ejemplo usando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    mensaje = \"Ejemplo de mensaje para hashear con PyCryptodome.\"\n    print(f\"Mensaje original: {mensaje}\")\n    print(\"-\" * 50)\n    # SHA-256 con PyCryptodome\n    h = SHA256.new()\n    h.update(mensaje.encode())\n    print(f\"SHA-256 (PyCryptodome): {h.hexdigest()}\")\n    # BLAKE2b con PyCryptodome\n    h = BLAKE2b.new(digest_bits=256)\n    h.update(mensaje.encode())\n    print(f\"BLAKE2b-256 (PyCryptodome): {h.hexdigest()}\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.pycrypto_hash_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función hash_with_salt_example: Ejemplo de hash con salt para mayor seguridad.\n\nCódigo:\ndef hash_with_salt_example():\n    \"\"\"Ejemplo de hash con salt para mayor seguridad.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH CON SALT\")\n    print(\"=\" * 50)\n    password = \"mi_contraseña_secreta\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un salt aleatorio\n    salt = os.urandom(16)  # 16 bytes = 128 bits\n    print(f\"Salt (en hexadecimal): {binascii.hexlify(salt).decode()}\")\n    # Combinar password y salt, luego hashear\n    salted_password = password.encode() + salt\n    hash_obj = hashlib.sha256(salted_password)\n    password_hash = hash_obj.hexdigest()\n    print(f\"Hash con salt: {password_hash}\")\n    # Simulación de verificación\n    print(\"\\nVerificación de contraseña:\")\n    # Contraseña correcta\n    test_password = \"mi_contraseña_secreta\"\n    test_salted = test_password.encode() + salt\n    test_hash = hashlib.sha256(test_salted).hexdigest()\n    if test_hash == password_hash:\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    wrong_salted = wrong_password.encode() + salt\n    wrong_hash = hashlib.sha256(wrong_salted).hexdigest()\n    if wrong_hash == password_hash:\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.hash_with_salt_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función insecure_password_storage: Ejemplo de almacenamiento inseguro de contraseñas (NO USAR EN PRODUCCIÓN).\n\nCódigo:\ndef insecure_password_storage():\n    \"\"\"Ejemplo de almacenamiento inseguro de contraseñas (NO USAR EN PRODUCCIÓN).\"\"\"\n    print(\"=\" * 50)\n    print(\"❌ ALMACENAMIENTO INSEGURO DE CONTRASEÑAS (NO USAR) ❌\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Método 1: Almacenamiento en texto plano (extremadamente inseguro)\n    print(\"\\n1. Almacenamiento en texto plano:\")\n    print(f\"Contraseña almacenada: {password}\")\n    print(\"⚠️ NUNCA almacenes contraseñas en texto plano.\")\n    # Método 2: Hash simple sin salt (inseguro)\n    print(\"\\n2. Hash simple sin salt (MD5):\")\n    md5_hash = hashlib.md5(password.encode()).hexdigest()\n    print(f\"Hash MD5: {md5_hash}\")\n    print(\"⚠️ MD5 es vulnerable a ataques de fuerza bruta y tablas rainbow.\")\n    # Método 3: Hash SHA-256 sin salt (inseguro)\n    print(\"\\n3. Hash SHA-256 sin salt:\")\n    sha256_hash = hashlib.sha256(password.encode()).hexdigest()\n    print(f\"Hash SHA-256: {sha256_hash}\")\n    print(\"⚠️ Aunque SHA-256 es criptográficamente más fuerte que MD5,\")\n    print(\"   sin salt sigue siendo vulnerable a ataques de diccionario y tablas rainbow.\")\n    print(\"\\nProblemas con estos métodos:\")\n    print(\"- Sin salt, contraseñas idénticas producen hashes idénticos\")\n    print(\"- Vulnerables a ataques de diccionario y tablas rainbow\")\n    print(\"- Los hashes simples son demasiado rápidos de calcular para los atacantes\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.insecure_password_storage",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔐 TÉCNICAS SEGURAS PARA EL ALMACENAMIENTO DE CONTRASEÑAS 🔐\\n\")\n    insecure_password_storage()\n    basic_salted_hash()\n    bcrypt_example()\n    pbkdf2_example()\n    password_storage_format()\n    password_upgrade_example()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"El almacenamiento seguro de contraseñas es crucial para proteger a los usuarios.\")\n    print(\"Recuerda:\")\n    print(\"- NUNCA almacenes contraseñas en texto plano o con hashes simples\")\n    print(\"- Usa algoritmos especializados como bcrypt, Argon2 o PBKDF2\")\n    print(\"- Asegúrate de usar un salt único para cada contraseña\")\n    print(\"- Ajusta los parámetros de costo para que el hash tome tiempo (100ms-500ms)\")\n    print(\"- Actualiza tus algoritmos de hash cuando surjan nuevas recomendaciones\")\n    print(\"=\" * 50)",
    "source": "hash_and_signatures.password_hashing.main",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Módulo hash_and_signatures.password_hashing: Ejemplos de técnicas seguras para el almacenamiento de contraseñas en Python.\nEste script demuestra el uso de algoritmos especializados para el hash de contraseñas.",
    "source": "hash_and_signatures.password_hashing",
    "type": "module",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Método PBKDF2HMAC.__init__: Initialize self.  See help(type(self)) for accurate signature.\n\nCódigo:\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes,\n        iterations: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n        if not ossl.pbkdf2_hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                \"{} is not supported for PBKDF2 by this backend.\".format(\n                    algorithm.name\n                ),\n                _Reasons.UNSUPPORTED_HASH,\n            )\n        self._used = False\n        self._algorithm = algorithm\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        self._salt = salt\n        self._iterations = iterations",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.__init__",
    "type": "method",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Método PBKDF2HMAC.derive: Deterministically generates and returns a new key based on the existing\nkey material.\n\nCódigo:\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"PBKDF2 instances can only be used once.\")\n        self._used = True\n        return rust_openssl.kdf.derive_pbkdf2_hmac(\n            key_material,\n            self._algorithm,\n            self._salt,\n            self._iterations,\n            self._length,\n        )",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.derive",
    "type": "method",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Método PBKDF2HMAC.verify: Checks whether the key generated by the key material matches the\nexpected derived key. Raises an exception if they do not match.\n\nCódigo:\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")",
    "source": "cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC.verify",
    "type": "method",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función basic_salted_hash: Ejemplo básico de hash con salt usando hashlib.\n\nCódigo:\ndef basic_salted_hash():\n    \"\"\"Ejemplo básico de hash con salt usando hashlib.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH CON SALT BÁSICO (HASHLIB)\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un salt aleatorio\n    salt = os.urandom(32)  # 32 bytes = 256 bits\n    print(f\"Salt (en hexadecimal): {binascii.hexlify(salt).decode()}\")\n    # Método 1: Concatenación simple + SHA-256:\n    print(\"\\n1. Concatenación simple + SHA-256:\")\n    salted_password = password.encode() + salt\n    hash_obj = hashlib.sha256(salted_password)\n    password_hash = hash_obj.hexdigest()\n    print(f\"Hash con salt: {password_hash}\")\n    # Método 2: Usar PBKDF2 (Password-Based Key Derivation Function 2)\n    print(\"\\n2. PBKDF2 con HMAC-SHA256:\")\n    # 100,000 iteraciones es un buen punto de partida en 2023\n    iterations = 100000\n    dk = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)\n    password_hash = binascii.hexlify(dk).decode()\n    print(f\"PBKDF2 hash: {password_hash}\")\n    print(f\"Iteraciones: {iterations}\")\n    # Simulación de verificación\n    print(\"\\nVerificación de contraseña:\")\n    # Contraseña correcta\n    test_password = \"mi_contraseña_123\"\n    dk_verify = hashlib.pbkdf2_hmac('sha256', test_password.encode(), salt, iterations)\n    test_hash = binascii.hexlify(dk_verify).decode()\n    if test_hash == password_hash:\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    dk_verify = hashlib.pbkdf2_hmac('sha256', wrong_password.encode(), salt, iterations)\n    wrong_hash = binascii.hexlify(dk_verify).decode()\n    if wrong_hash == password_hash:\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.basic_salted_hash",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función bcrypt_example: Ejemplo de hash de contraseñas usando bcrypt.\n\nCódigo:\ndef bcrypt_example():\n    \"\"\"Ejemplo de hash de contraseñas usando bcrypt.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH DE CONTRASEÑAS CON BCRYPT\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un hash bcrypt\n    # El parámetro rounds determina la complejidad (12 es un buen valor por defecto)\n    rounds = 12\n    start_time = time.time()\n    hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=rounds))\n    end_time = time.time()\n    print(f\"\\nHash bcrypt: {hashed.decode()}\")\n    print(f\"Tiempo de cálculo: {(end_time - start_time):.4f} segundos\")\n    print(f\"Factor de trabajo (rounds): {rounds}\")\n    # Explicar la estructura del hash bcrypt\n    print(\"\\nEstructura del hash bcrypt:\")\n    print(\"- $2b$: Identificador de versión de bcrypt\")\n    print(f\"- $12$: Factor de trabajo (2^{rounds} iteraciones)\")\n    print(\"- 22 caracteres siguientes: Salt codificado en base64\")\n    print(\"- 31 caracteres restantes: Hash codificado en base64\")\n    # Simulación de verificación\n    print(\"\\nVerificación de contraseña:\")\n    # Contraseña correcta\n    test_password = \"mi_contraseña_123\"\n    if bcrypt.checkpw(test_password.encode(), hashed):\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    if bcrypt.checkpw(wrong_password.encode(), hashed):\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    # Demostrar cómo bcrypt ajusta automáticamente la dificultad\n    print(\"\\nAjuste de dificultad en bcrypt:\")\n    for r in [10, 12, 14]:\n        start_time = time.time()\n        bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=r))\n        end_time = time.time()\n        print(f\"rounds={r}: {(end_time - start_time):.4f} segundos\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.bcrypt_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función insecure_password_storage: Ejemplo de almacenamiento inseguro de contraseñas (NO USAR EN PRODUCCIÓN).\n\nCódigo:\ndef insecure_password_storage():\n    \"\"\"Ejemplo de almacenamiento inseguro de contraseñas (NO USAR EN PRODUCCIÓN).\"\"\"\n    print(\"=\" * 50)\n    print(\"❌ ALMACENAMIENTO INSEGURO DE CONTRASEÑAS (NO USAR) ❌\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Método 1: Almacenamiento en texto plano (extremadamente inseguro)\n    print(\"\\n1. Almacenamiento en texto plano:\")\n    print(f\"Contraseña almacenada: {password}\")\n    print(\"⚠️ NUNCA almacenes contraseñas en texto plano.\")\n    # Método 2: Hash simple sin salt (inseguro)\n    print(\"\\n2. Hash simple sin salt (MD5):\")\n    md5_hash = hashlib.md5(password.encode()).hexdigest()\n    print(f\"Hash MD5: {md5_hash}\")\n    print(\"⚠️ MD5 es vulnerable a ataques de fuerza bruta y tablas rainbow.\")\n    # Método 3: Hash SHA-256 sin salt (inseguro)\n    print(\"\\n3. Hash SHA-256 sin salt:\")\n    sha256_hash = hashlib.sha256(password.encode()).hexdigest()\n    print(f\"Hash SHA-256: {sha256_hash}\")\n    print(\"⚠️ Aunque SHA-256 es criptográficamente más fuerte que MD5,\")\n    print(\"   sin salt sigue siendo vulnerable a ataques de diccionario y tablas rainbow.\")\n    print(\"\\nProblemas con estos métodos:\")\n    print(\"- Sin salt, contraseñas idénticas producen hashes idénticos\")\n    print(\"- Vulnerables a ataques de diccionario y tablas rainbow\")\n    print(\"- Los hashes simples son demasiado rápidos de calcular para los atacantes\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.insecure_password_storage",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función main: Función principal que ejecuta todos los ejemplos.\n\nCódigo:\ndef main():\n    \"\"\"Función principal que ejecuta todos los ejemplos.\"\"\"\n    print(\"\\n🔐 TÉCNICAS SEGURAS PARA EL ALMACENAMIENTO DE CONTRASEÑAS 🔐\\n\")\n    insecure_password_storage()\n    basic_salted_hash()\n    bcrypt_example()\n    pbkdf2_example()\n    password_storage_format()\n    password_upgrade_example()\n    print(\"=\" * 50)\n    print(\"CONCLUSIÓN\")\n    print(\"=\" * 50)\n    print(\"El almacenamiento seguro de contraseñas es crucial para proteger a los usuarios.\")\n    print(\"Recuerda:\")\n    print(\"- NUNCA almacenes contraseñas en texto plano o con hashes simples\")\n    print(\"- Usa algoritmos especializados como bcrypt, Argon2 o PBKDF2\")\n    print(\"- Asegúrate de usar un salt único para cada contraseña\")\n    print(\"- Ajusta los parámetros de costo para que el hash tome tiempo (100ms-500ms)\")\n    print(\"- Actualiza tus algoritmos de hash cuando surjan nuevas recomendaciones\")\n    print(\"=\" * 50)",
    "source": "hash_and_signatures.password_hashing.main",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función password_storage_format: Ejemplo de formato para almacenar hashes de contraseñas.\n\nCódigo:\ndef password_storage_format():\n    \"\"\"Ejemplo de formato para almacenar hashes de contraseñas.\"\"\"\n    print(\"=\" * 50)\n    print(\"FORMATO PARA ALMACENAR HASHES DE CONTRASEÑAS\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Método 1: Formato para PBKDF2\n    print(\"\\n1. Formato para PBKDF2:\")\n    # Parámetros\n    salt = os.urandom(16)\n    iterations = 100000\n    # Generar el hash\n    dk = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)\n    # Formato: algoritmo$iteraciones$salt_en_base64$hash_en_base64\n    salt_b64 = binascii.b2a_base64(salt, newline=False).decode()\n    dk_b64 = binascii.b2a_base64(dk, newline=False).decode()\n    stored_password = f\"pbkdf2_sha256${iterations}${salt_b64}${dk_b64}\"\n    print(f\"Hash almacenado: {stored_password}\")\n    # Simulación de verificación\n    print(\"\\nVerificación usando el formato almacenado:\")\n    # Extraer los componentes\n    algorithm, iter_count, salt_b64, hash_b64 = stored_password.split('$')\n    iter_count = int(iter_count)\n    salt = binascii.a2b_base64(salt_b64)\n    stored_hash = binascii.a2b_base64(hash_b64)\n    # Verificar la contraseña\n    test_password = \"mi_contraseña_123\"\n    computed_hash = hashlib.pbkdf2_hmac('sha256', test_password.encode(), salt, iter_count)\n    if computed_hash == stored_hash:\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Método 2: bcrypt ya incluye un formato estándar\n    print(\"\\n2. Formato para bcrypt (incorporado):\")\n    hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    print(f\"Hash almacenado: {hashed.decode()}\")\n    # Verificación\n    if bcrypt.checkpw(password.encode(), hashed):\n        print(f\"Contraseña '{password}' es correcta ✓\")\n    print(\"\\nVentajas de estos formatos:\")\n    print(\"- Incluyen toda la información necesaria para la verificación\")\n    print(\"- Permiten actualizar los parámetros (iteraciones, algoritmo) en el futuro\")\n    print(\"- Son autocontenidos (no requieren almacenar el salt por separado)\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.password_storage_format",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función password_upgrade_example: Ejemplo de cómo actualizar el hash de una contraseña cuando el usuario inicia sesión.\n\nCódigo:\ndef password_upgrade_example():\n    \"\"\"Ejemplo de cómo actualizar el hash de una contraseña cuando el usuario inicia sesión.\"\"\"\n    print(\"=\" * 50)\n    print(\"ACTUALIZACIÓN DE HASHES DE CONTRASEÑAS\")\n    print(\"=\" * 50)\n    print(\"Escenario: Actualizar de PBKDF2 con 10,000 iteraciones a bcrypt\")\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Hash antiguo (PBKDF2 con 10,000 iteraciones)\n    salt_old = os.urandom(16)\n    iterations_old = 10000\n    dk_old = hashlib.pbkdf2_hmac('sha256', password.encode(), salt_old, iterations_old)\n    # Formato antiguo\n    salt_b64_old = binascii.b2a_base64(salt_old, newline=False).decode()\n    dk_b64_old = binascii.b2a_base64(dk_old, newline=False).decode()\n    old_stored_password = f\"pbkdf2_sha256${iterations_old}${salt_b64_old}${dk_b64_old}\"\n    print(f\"\\nHash antiguo (PBKDF2): {old_stored_password}\")\n    # Simulación de inicio de sesión\n    print(\"\\nUsuario inicia sesión con la contraseña correcta...\")\n    # Verificar con el hash antiguo\n    algorithm, iter_count, salt_b64, hash_b64 = old_stored_password.split('$')\n    iter_count = int(iter_count)\n    salt = binascii.a2b_base64(salt_b64)\n    stored_hash = binascii.a2b_base64(hash_b64)\n    login_password = \"mi_contraseña_123\"\n    computed_hash = hashlib.pbkdf2_hmac('sha256', login_password.encode(), salt, iter_count)\n    if computed_hash == stored_hash:\n        print(\"✓ Autenticación exitosa con el hash antiguo\")\n        # Generar un nuevo hash con bcrypt\n        new_hash = bcrypt.hashpw(login_password.encode(), bcrypt.gensalt(rounds=12))\n        new_stored_password = new_hash.decode()\n        print(f\"✓ Hash actualizado a bcrypt: {new_stored_password}\")\n    else:\n        print(\"✗ Autenticación fallida\")\n    print(\"\\nVentajas de la actualización gradual:\")\n    print(\"- No requiere que todos los usuarios cambien sus contraseñas\")\n    print(\"- Actualiza los hashes a medida que los usuarios inician sesión\")\n    print(\"- Permite una transición suave a algoritmos más seguros\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.password_upgrade_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función pbkdf2_example: Ejemplo de hash de contraseñas usando PBKDF2 con la biblioteca cryptography.\n\nCódigo:\ndef pbkdf2_example():\n    \"\"\"Ejemplo de hash de contraseñas usando PBKDF2 con la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH DE CONTRASEÑAS CON PBKDF2\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un salt aleatorio\n    salt = os.urandom(16)\n    print(f\"Salt (en hexadecimal): {binascii.hexlify(salt).decode()}\")\n    # Configurar PBKDF2\n    iterations = 100000  # 100,000 iteraciones es un buen punto de partida en 2023\n    start_time = time.time()\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=iterations,\n        backend=default_backend()\n    )\n    key = kdf.derive(password.encode())\n    end_time = time.time()\n    print(f\"\\nPBKDF2 hash (en hexadecimal): {binascii.hexlify(key).decode()}\")\n    print(f\"Iteraciones: {iterations}\")\n    print(f\"Tiempo de cálculo: {(end_time - start_time):.4f} segundos\")\n    # Verificación de contraseña\n    print(\"\\nVerificación de contraseña:\")\n    # Crear un nuevo objeto PBKDF2HMAC para verificación\n    kdf_verify = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=iterations,\n        backend=default_backend()\n    )\n    # Contraseña correcta\n    test_password = \"mi_contraseña_123\"\n    try:\n        kdf_verify.verify(test_password.encode(), key)\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    except Exception:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    try:\n        kdf_verify.verify(wrong_password.encode(), key)\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    except Exception:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.pbkdf2_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función password_storage_format: Ejemplo de formato para almacenar hashes de contraseñas.\n\nCódigo:\ndef password_storage_format():\n    \"\"\"Ejemplo de formato para almacenar hashes de contraseñas.\"\"\"\n    print(\"=\" * 50)\n    print(\"FORMATO PARA ALMACENAR HASHES DE CONTRASEÑAS\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Método 1: Formato para PBKDF2\n    print(\"\\n1. Formato para PBKDF2:\")\n    # Parámetros\n    salt = os.urandom(16)\n    iterations = 100000\n    # Generar el hash\n    dk = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)\n    # Formato: algoritmo$iteraciones$salt_en_base64$hash_en_base64\n    salt_b64 = binascii.b2a_base64(salt, newline=False).decode()\n    dk_b64 = binascii.b2a_base64(dk, newline=False).decode()\n    stored_password = f\"pbkdf2_sha256${iterations}${salt_b64}${dk_b64}\"\n    print(f\"Hash almacenado: {stored_password}\")\n    # Simulación de verificación\n    print(\"\\nVerificación usando el formato almacenado:\")\n    # Extraer los componentes\n    algorithm, iter_count, salt_b64, hash_b64 = stored_password.split('$')\n    iter_count = int(iter_count)\n    salt = binascii.a2b_base64(salt_b64)\n    stored_hash = binascii.a2b_base64(hash_b64)\n    # Verificar la contraseña\n    test_password = \"mi_contraseña_123\"\n    computed_hash = hashlib.pbkdf2_hmac('sha256', test_password.encode(), salt, iter_count)\n    if computed_hash == stored_hash:\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    else:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Método 2: bcrypt ya incluye un formato estándar\n    print(\"\\n2. Formato para bcrypt (incorporado):\")\n    hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    print(f\"Hash almacenado: {hashed.decode()}\")\n    # Verificación\n    if bcrypt.checkpw(password.encode(), hashed):\n        print(f\"Contraseña '{password}' es correcta ✓\")\n    print(\"\\nVentajas de estos formatos:\")\n    print(\"- Incluyen toda la información necesaria para la verificación\")\n    print(\"- Permiten actualizar los parámetros (iteraciones, algoritmo) en el futuro\")\n    print(\"- Son autocontenidos (no requieren almacenar el salt por separado)\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.password_storage_format",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función password_upgrade_example: Ejemplo de cómo actualizar el hash de una contraseña cuando el usuario inicia sesión.\n\nCódigo:\ndef password_upgrade_example():\n    \"\"\"Ejemplo de cómo actualizar el hash de una contraseña cuando el usuario inicia sesión.\"\"\"\n    print(\"=\" * 50)\n    print(\"ACTUALIZACIÓN DE HASHES DE CONTRASEÑAS\")\n    print(\"=\" * 50)\n    print(\"Escenario: Actualizar de PBKDF2 con 10,000 iteraciones a bcrypt\")\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Hash antiguo (PBKDF2 con 10,000 iteraciones)\n    salt_old = os.urandom(16)\n    iterations_old = 10000\n    dk_old = hashlib.pbkdf2_hmac('sha256', password.encode(), salt_old, iterations_old)\n    # Formato antiguo\n    salt_b64_old = binascii.b2a_base64(salt_old, newline=False).decode()\n    dk_b64_old = binascii.b2a_base64(dk_old, newline=False).decode()\n    old_stored_password = f\"pbkdf2_sha256${iterations_old}${salt_b64_old}${dk_b64_old}\"\n    print(f\"\\nHash antiguo (PBKDF2): {old_stored_password}\")\n    # Simulación de inicio de sesión\n    print(\"\\nUsuario inicia sesión con la contraseña correcta...\")\n    # Verificar con el hash antiguo\n    algorithm, iter_count, salt_b64, hash_b64 = old_stored_password.split('$')\n    iter_count = int(iter_count)\n    salt = binascii.a2b_base64(salt_b64)\n    stored_hash = binascii.a2b_base64(hash_b64)\n    login_password = \"mi_contraseña_123\"\n    computed_hash = hashlib.pbkdf2_hmac('sha256', login_password.encode(), salt, iter_count)\n    if computed_hash == stored_hash:\n        print(\"✓ Autenticación exitosa con el hash antiguo\")\n        # Generar un nuevo hash con bcrypt\n        new_hash = bcrypt.hashpw(login_password.encode(), bcrypt.gensalt(rounds=12))\n        new_stored_password = new_hash.decode()\n        print(f\"✓ Hash actualizado a bcrypt: {new_stored_password}\")\n    else:\n        print(\"✗ Autenticación fallida\")\n    print(\"\\nVentajas de la actualización gradual:\")\n    print(\"- No requiere que todos los usuarios cambien sus contraseñas\")\n    print(\"- Actualiza los hashes a medida que los usuarios inician sesión\")\n    print(\"- Permite una transición suave a algoritmos más seguros\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.password_upgrade_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función pbkdf2_example: Ejemplo de hash de contraseñas usando PBKDF2 con la biblioteca cryptography.\n\nCódigo:\ndef pbkdf2_example():\n    \"\"\"Ejemplo de hash de contraseñas usando PBKDF2 con la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH DE CONTRASEÑAS CON PBKDF2\")\n    print(\"=\" * 50)\n    # Contraseña de ejemplo\n    password = \"mi_contraseña_123\"\n    print(f\"Contraseña original: {password}\")\n    # Generar un salt aleatorio\n    salt = os.urandom(16)\n    print(f\"Salt (en hexadecimal): {binascii.hexlify(salt).decode()}\")\n    # Configurar PBKDF2\n    iterations = 100000  # 100,000 iteraciones es un buen punto de partida en 2023\n    start_time = time.time()\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=iterations,\n        backend=default_backend()\n    )\n    key = kdf.derive(password.encode())\n    end_time = time.time()\n    print(f\"\\nPBKDF2 hash (en hexadecimal): {binascii.hexlify(key).decode()}\")\n    print(f\"Iteraciones: {iterations}\")\n    print(f\"Tiempo de cálculo: {(end_time - start_time):.4f} segundos\")\n    # Verificación de contraseña\n    print(\"\\nVerificación de contraseña:\")\n    # Crear un nuevo objeto PBKDF2HMAC para verificación\n    kdf_verify = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=iterations,\n        backend=default_backend()\n    )\n    # Contraseña correcta\n    test_password = \"mi_contraseña_123\"\n    try:\n        kdf_verify.verify(test_password.encode(), key)\n        print(f\"Contraseña '{test_password}' es correcta ✓\")\n    except Exception:\n        print(f\"Contraseña '{test_password}' es incorrecta ✗\")\n    # Contraseña incorrecta\n    wrong_password = \"contraseña_incorrecta\"\n    try:\n        kdf_verify.verify(wrong_password.encode(), key)\n        print(f\"Contraseña '{wrong_password}' es correcta ✓\")\n    except Exception:\n        print(f\"Contraseña '{wrong_password}' es incorrecta ✗\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.password_hashing.pbkdf2_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función pycrypto_hash_example: Ejemplo usando la biblioteca PyCryptodome.\n\nCódigo:\ndef pycrypto_hash_example():\n    \"\"\"Ejemplo usando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"HASH CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    mensaje = \"Ejemplo de mensaje para hashear con PyCryptodome.\"\n    print(f\"Mensaje original: {mensaje}\")\n    print(\"-\" * 50)\n    # SHA-256 con PyCryptodome\n    h = SHA256.new()\n    h.update(mensaje.encode())\n    print(f\"SHA-256 (PyCryptodome): {h.hexdigest()}\")\n    # BLAKE2b con PyCryptodome\n    h = BLAKE2b.new(digest_bits=256)\n    h.update(mensaje.encode())\n    print(f\"BLAKE2b-256 (PyCryptodome): {h.hexdigest()}\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.hash_functions.pycrypto_hash_example",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función rsa_signature_with_cryptography: Ejemplo de firma digital RSA usando la biblioteca cryptography.\n\nCódigo:\ndef rsa_signature_with_cryptography():\n    \"\"\"Ejemplo de firma digital RSA usando la biblioteca cryptography.\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL RSA CON CRYPTOGRAPHY\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n    )\n    public_key = private_key.public_key()\n    print(\"Par de claves RSA generado:\")\n    print(f\"- Tamaño de clave: 2048 bits\")\n    print(f\"- Exponente público: 65537\")\n    # Mensaje a firmar\n    mensaje = \"Este mensaje será firmado digitalmente para verificar su autenticidad e integridad.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Firmar el mensaje\n    signature = private_key.sign(\n        mensaje.encode('utf-8'),\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    print(f\"Firma digital (en base64): {base64.b64encode(signature).decode()[:50]}...\")\n    # Verificar la firma\n    print(\"\\nVerificación de la firma:\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except InvalidSignature:\n        print(\"✗ Firma inválida: El mensaje puede haber sido alterado.\")\n    # Demostrar qué sucede si el mensaje es alterado\n    print(\"\\nSimulación de alteración del mensaje:\")\n    # Mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"Mensaje alterado: {mensaje_alterado}\")\n    try:\n        public_key.verify(\n            signature,\n            mensaje_alterado.encode('utf-8'),\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except InvalidSignature:\n        print(\"✗ Firma inválida: El mensaje ha sido alterado.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.rsa_signature_with_cryptography",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función rsa_signature_with_pycryptodome: Ejemplo de firma digital RSA usando la biblioteca PyCryptodome.\n\nCódigo:\ndef rsa_signature_with_pycryptodome():\n    \"\"\"Ejemplo de firma digital RSA usando la biblioteca PyCryptodome.\"\"\"\n    print(\"=\" * 50)\n    print(\"FIRMA DIGITAL RSA CON PYCRYPTODOME\")\n    print(\"=\" * 50)\n    # Generar un par de claves RSA\n    key = RSA.generate(2048)\n    print(\"Par de claves RSA generado:\")\n    print(f\"- Tamaño de clave: {key.size_in_bits()} bits\")\n    print(f\"- Exponente público: {key.e}\")\n    # Mensaje a firmar\n    mensaje = \"Este es otro mensaje para firmar con RSA usando PyCryptodome.\"\n    print(f\"\\nMensaje original: {mensaje}\")\n    # Calcular el hash del mensaje\n    h = SHA256.new(mensaje.encode('utf-8'))\n    # Firmar el hash con la clave privada\n    signature = pkcs1_15.new(key).sign(h)\n    print(f\"Firma digital (en base64): {base64.b64encode(signature).decode()[:50]}...\")\n    # Verificar la firma con la clave pública\n    public_key = key.publickey()\n    print(\"\\nVerificación de la firma:\")\n    try:\n        # Calcular el hash del mensaje recibido\n        h = SHA256.new(mensaje.encode('utf-8'))\n        # Verificar la firma\n        pkcs1_15.new(public_key).verify(h, signature)\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El mensaje puede haber sido alterado.\")\n    # Demostrar qué sucede si el mensaje es alterado\n    print(\"\\nSimulación de alteración del mensaje:\")\n    # Mensaje alterado\n    mensaje_alterado = mensaje + \" (alterado)\"\n    print(f\"Mensaje alterado: {mensaje_alterado}\")\n    try:\n        # Calcular el hash del mensaje alterado\n        h = SHA256.new(mensaje_alterado.encode('utf-8'))\n        # Verificar la firma con el mensaje alterado\n        pkcs1_15.new(public_key).verify(h, signature)\n        print(\"✓ Firma válida: El mensaje es auténtico y no ha sido alterado.\")\n    except (ValueError, TypeError):\n        print(\"✗ Firma inválida: El mensaje ha sido alterado.\")\n    print(\"\\n\")",
    "source": "hash_and_signatures.digital_signatures.rsa_signature_with_pycryptodome",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "Función sign_verify_message: Firma o verifica un mensaje usando RSA con SHA-256.\n\nArgs:\n    message: Mensaje a firmar o verificar\n    key: Clave privada (para firmar) o pública (para verificar)\n    action: 'sign', 'verify' o 'generate_keys'\n    signature: Firma a verificar (solo para action='verify')\n    \nReturns:\n    Depende de la acción:\n    - 'generate_keys': (public_key, private_key)\n    - 'sign': firma en formato base64\n    - 'verify': True si la firma es válida, False en caso contrario\n\nCódigo:\ndef sign_verify_message(message, key, action='sign', signature=None):\n    \"\"\"\n    Firma o verifica un mensaje usando RSA con SHA-256.\n    Args:\n        message: Mensaje a firmar o verificar\n        key: Clave privada (para firmar) o pública (para verificar)\n        action: 'sign', 'verify' o 'generate_keys'\n        signature: Firma a verificar (solo para action='verify')\n    Returns:\n        Depende de la acción:\n        - 'generate_keys': (public_key, private_key)\n        - 'sign': firma en formato base64\n        - 'verify': True si la firma es válida, False en caso contrario\n    \"\"\"\n    if action == 'generate_keys':\n        # Generar par de claves RSA\n        key_obj = RSA.generate(2048)\n        private_key = key_obj.export_key().decode('utf-8')\n        public_key = key_obj.publickey().export_key().decode('utf-8')\n        return public_key, private_key\n    elif action == 'sign':\n        # Importar clave privada\n        if isinstance(key, str):\n            key_obj = RSA.import_key(key)\n        else:\n            key_obj = key\n        # Calcular el hash del mensaje\n        h = SHA256.new(message.encode('utf-8'))\n        # Firmar el hash con la clave privada\n        signature = pkcs1_15.new(key_obj).sign(h)\n        # Convertir a base64 para transmisión web\n        return base64.b64encode(signature).decode('utf-8')\n    elif action == 'verify':\n        # Importar clave pública\n        if isinstance(key, str):\n            key_obj = RSA.import_key(key)\n        else:\n            key_obj = key\n        # Calcular el hash del mensaje\n        h = SHA256.new(message.encode('utf-8'))\n        try:\n            # Decodificar la firma de base64\n            signature_bytes = base64.b64decode(signature)\n            # Verificar la firma\n            pkcs1_15.new(key_obj).verify(h, signature_bytes)\n            return True\n        except:\n            return False\n    else:\n        raise ValueError(f\"Acción no reconocida: {action}\")",
    "source": "hash_and_signatures.digital_signatures.sign_verify_message",
    "type": "function",
    "category": "Hash y Firmas Digitales"
  },
  {
    "content": "La criptografía simétrica utiliza la misma clave para cifrar y descifrar.\n                Algoritmos comunes incluyen AES, DES y 3DES. La principal ventaja es su velocidad,\n                pero el problema es la distribución segura de claves.",
    "source": "general_knowledge",
    "type": "concept",
    "category": "Conceptos de Criptografía"
  },
  {
    "content": "La criptografía asimétrica utiliza un par de claves: pública y privada.\n                La clave pública puede compartirse libremente, mientras que la privada debe mantenerse secreta.\n                Algoritmos comunes incluyen RSA, DSA y ECC. Son más lentos que los simétricos pero resuelven\n                el problema de distribución de claves.",
    "source": "general_knowledge",
    "type": "concept",
    "category": "Conceptos de Criptografía"
  },
  {
    "content": "Las funciones hash son algoritmos que convierten datos de cualquier tamaño\n                en una cadena de longitud fija. Son de un solo sentido (no pueden revertirse) y se utilizan\n                para verificar integridad de datos y almacenar contraseñas. Ejemplos incluyen MD5, SHA-1,\n                SHA-256 y BLAKE2.",
    "source": "general_knowledge",
    "type": "concept",
    "category": "Conceptos de Criptografía"
  },
  {
    "content": "La criptografía híbrida combina las ventajas de los sistemas simétricos y asimétricos.\n                Utiliza criptografía asimétrica para intercambiar una clave simétrica temporal, que luego se usa\n                para cifrar los datos reales. Es el enfoque utilizado en protocolos como SSL/TLS.",
    "source": "general_knowledge",
    "type": "concept",
    "category": "Conceptos de Criptografía"
  },
  {
    "content": "Las firmas digitales proporcionan autenticidad e integridad a los mensajes.\n                Funcionan mediante el cifrado de un hash del mensaje con la clave privada del remitente.\n                Cualquiera con la clave pública correspondiente puede verificar que el mensaje no ha sido\n                alterado y proviene del remitente correcto.",
    "source": "general_knowledge",
    "type": "concept",
    "category": "Conceptos de Criptografía"
  }
]